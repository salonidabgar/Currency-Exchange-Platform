import 'cross-fetch/dist/node-polyfill.js';
import { BigNumber, utils, constants, ethers, providers, Signer, Contract, ContractFactory } from 'ethers';
import { z } from 'zod';
import { v4 } from 'uuid';
import { decodeFirstSync } from 'cbor';
import { toB58String } from 'multihashes';
import EventEmitter from 'eventemitter3';
import { File as File$1 } from '@web-std/file';
import FormData from 'form-data';
import invariant13 from 'tiny-invariant';
import deepEqual from 'fast-deep-equal';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
  }
});

// node_modules/buffer-reverse/index.js
var require_buffer_reverse = __commonJS({
  "node_modules/buffer-reverse/index.js"(exports, module) {
    init_esm_shims();
    module.exports = /* @__PURE__ */ __name(function reverse(src) {
      var buffer = new Buffer(src.length);
      for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {
        buffer[i] = src[j];
        buffer[j] = src[i];
      }
      return buffer;
    }, "reverse");
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var create = Object.create || function() {
          function F() {
          }
          __name(F, "F");
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            var r = /* @__PURE__ */ __name(function(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += 0.5;
                return result * (Math2.random() > 0.5 ? 1 : -1);
              };
            }, "r");
            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r((rcache || Math2.random()) * 4294967296);
              rcache = _r() * 987654071;
              words.push(_r() * 4294967296 | 0);
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H1 = [];
        var K = [];
        (function() {
          function isPrime(n) {
            var sqrtN = Math2.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n % factor)) {
                return false;
              }
            }
            return true;
          }
          __name(isPrime, "isPrime");
          function getFractionalBits(n) {
            return (n - (n | 0)) * 4294967296 | 0;
          }
          __name(getFractionalBits, "getFractionalBits");
          var n1 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n1)) {
              if (nPrime < 8) {
                H1[nPrime] = getFractionalBits(Math2.pow(n1, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n1, 1 / 3));
              nPrime++;
            }
            n1++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H1.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
            H[5] = H[5] + f | 0;
            H[6] = H[6] + g | 0;
            H[7] = H[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        C_x64.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
        __name(swapEndian, "swapEndian");
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
        __name(parseLoop, "parseLoop");
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        __name(FF, "FF");
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        __name(GG, "GG");
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        __name(HH, "HH");
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        __name(II, "II");
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./sha256"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./x64-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        __name(X64Word_create, "X64Word_create");
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wi = W[i];
              if (i < 16) {
                var Wih = Wi.high = M[offset + i * 2] | 0;
                var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./x64-core",
          "./sha512"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./x64-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([
          0,
          1518500249,
          1859775393,
          2400959708,
          2840853838
        ]);
        var _hr = WordArray.create([
          1352829926,
          1548603684,
          1836072691,
          2053994217,
          0
        ]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z19) {
          return x ^ y ^ z19;
        }
        __name(f1, "f1");
        function f2(x, y, z19) {
          return x & y | ~x & z19;
        }
        __name(f2, "f2");
        function f3(x, y, z19) {
          return (x | ~y) ^ z19;
        }
        __name(f3, "f3");
        function f4(x, y, z19) {
          return x & z19 | y & ~z19;
        }
        __name(f4, "f4");
        function f5(x, y, z19) {
          return x ^ (y | ~z19);
        }
        __name(f5, "f5");
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        __name(rotl, "rotl");
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        C_algo.HMAC = Base.extend({
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./sha1",
          "./hmac"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([
              1
            ]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./sha1",
          "./hmac"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./evpkdf"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            __name(selectCipherStrategy, "selectCipherStrategy");
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC1 = C_mode.CBC = function() {
          var CBC = BlockCipherMode.extend();
          CBC.Encryptor = CBC.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC.Decryptor = CBC.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined2;
            } else {
              var block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          __name(xorBlock, "xorBlock");
          return CBC;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC1,
            padding: Pkcs7
          }),
          reset: function() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode.createEncryptor;
            } else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              var wordArray = WordArray.create([
                1398893684,
                1701076831
              ]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({
              ciphertext,
              salt
            });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({
              keySize: keySize + ivSize
            }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({
              key,
              iv,
              salt
            });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            var keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        __name(generateKeystreamAndEncrypt, "generateKeystreamAndEncrypt");
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        __name(incWord, "incWord");
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        __name(incCounter, "incCounter");
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([
            nPaddingBytes << 24
          ], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([
            2147483648
          ], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) {
            i--;
          }
          data.sigBytes = i + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({
              ciphertext
            });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./enc-base64",
          "./md5",
          "./evpkdf",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX1 = [];
        var INV_SBOX = [];
        var SUB_MIX_01 = [];
        var SUB_MIX_11 = [];
        var SUB_MIX_21 = [];
        var SUB_MIX_31 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX1[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_01[x] = t << 24 | t >>> 8;
            SUB_MIX_11[x] = t << 16 | t >>> 16;
            SUB_MIX_21[x] = t << 8 | t >>> 24;
            SUB_MIX_31[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [
          0,
          1,
          2,
          4,
          8,
          16,
          32,
          64,
          128,
          27,
          54
        ];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX1[t >>> 24] << 24 | SBOX1[t >>> 16 & 255] << 16 | SBOX1[t >>> 8 & 255] << 8 | SBOX1[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX1[t >>> 24] << 24 | SBOX1[t >>> 16 & 255] << 16 | SBOX1[t >>> 8 & 255] << 8 | SBOX1[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX1[t >>> 24]] ^ INV_SUB_MIX_1[SBOX1[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX1[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX1[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_01, SUB_MIX_11, SUB_MIX_21, SUB_MIX_31, SBOX1);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./enc-base64",
          "./md5",
          "./evpkdf",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [
          1,
          2,
          4,
          6,
          8,
          10,
          12,
          14,
          15,
          17,
          19,
          21,
          23,
          25,
          27,
          28
        ];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        __name(exchangeLR, "exchangeLR");
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        __name(exchangeRL, "exchangeRL");
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./enc-base64",
          "./md5",
          "./evpkdf",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        __name(generateKeystreamWord, "generateKeystreamWord");
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./enc-base64",
          "./md5",
          "./evpkdf",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C1 = CryptoJS;
        var C_lib = C1.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C1.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C[0] ^= i0;
              C[1] ^= i1;
              C[2] ^= i2;
              C[3] ^= i3;
              C[4] ^= i0;
              C[5] ^= i1;
              C[6] ^= i2;
              C[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C[i];
          }
          C[0] = C[0] + 1295307597 + this._b | 0;
          C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        __name(nextState, "nextState");
        C1.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./enc-base64",
          "./md5",
          "./evpkdf",
          "./cipher-core"
        ], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C1 = CryptoJS;
        var C_lib = C1.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C1.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C[0] ^= i0;
              C[1] ^= i1;
              C[2] ^= i2;
              C[3] ^= i3;
              C[4] ^= i0;
              C[5] ^= i1;
              C[6] ^= i2;
              C[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C[i];
          }
          C[0] = C[0] + 1295307597 + this._b | 0;
          C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        __name(nextState, "nextState");
        C1.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    init_esm_shims();
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define([
          "./core",
          "./x64-core",
          "./lib-typedarrays",
          "./enc-utf16",
          "./enc-base64",
          "./md5",
          "./sha1",
          "./sha256",
          "./sha224",
          "./sha512",
          "./sha384",
          "./sha3",
          "./ripemd160",
          "./hmac",
          "./pbkdf2",
          "./evpkdf",
          "./cipher-core",
          "./mode-cfb",
          "./mode-ctr",
          "./mode-ctr-gladman",
          "./mode-ofb",
          "./mode-ecb",
          "./pad-ansix923",
          "./pad-iso10126",
          "./pad-iso97971",
          "./pad-zeropadding",
          "./pad-nopadding",
          "./format-hex",
          "./aes",
          "./tripledes",
          "./rc4",
          "./rabbit",
          "./rabbit-legacy"
        ], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/merkletreejs/dist/Base.js
var require_Base = __commonJS({
  "node_modules/merkletreejs/dist/Base.js"(exports) {
    init_esm_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Base = void 0;
    var crypto_js_1 = __importDefault(require_crypto_js());
    var Base = /* @__PURE__ */ __name(class Base2 {
      print() {
        Base2.print(this);
      }
      _bufferIndexOf(array, element) {
        for (let i = 0; i < array.length; i++) {
          if (element.equals(array[i])) {
            return i;
          }
        }
        return -1;
      }
      static bufferify(value) {
        if (!Buffer.isBuffer(value)) {
          if (typeof value === "object" && value.words) {
            return Buffer.from(value.toString(crypto_js_1.default.enc.Hex), "hex");
          } else if (Base2.isHexString(value)) {
            return Buffer.from(value.replace(/^0x/, ""), "hex");
          } else if (typeof value === "string") {
            return Buffer.from(value);
          } else if (typeof value === "number") {
            let s = value.toString();
            if (s.length % 2) {
              s = `0${s}`;
            }
            return Buffer.from(s, "hex");
          } else if (ArrayBuffer.isView(value)) {
            return Buffer.from(value.buffer, value.byteOffset, value.byteLength);
          }
        }
        return value;
      }
      static isHexString(v) {
        return typeof v === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v);
      }
      static print(tree) {
        console.log(tree.toString());
      }
      bufferToHex(value, withPrefix = true) {
        return Base2.bufferToHex(value, withPrefix);
      }
      static bufferToHex(value, withPrefix = true) {
        return `${withPrefix ? "0x" : ""}${(value || Buffer.alloc(0)).toString("hex")}`;
      }
      bufferify(value) {
        return Base2.bufferify(value);
      }
      bufferifyFn(f) {
        return (value) => {
          const v = f(value);
          if (Buffer.isBuffer(v)) {
            return v;
          }
          if (this._isHexString(v)) {
            return Buffer.from(v.replace("0x", ""), "hex");
          }
          if (typeof v === "string") {
            return Buffer.from(v);
          }
          if (ArrayBuffer.isView(v)) {
            return Buffer.from(v.buffer, v.byteOffset, v.byteLength);
          }
          return Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString("hex"))).toString(crypto_js_1.default.enc.Hex), "hex");
        };
      }
      _isHexString(value) {
        return Base2.isHexString(value);
      }
      _log2(n) {
        return n === 1 ? 0 : 1 + this._log2(n / 2 | 0);
      }
      _zip(a, b) {
        return a.map((e, i) => [
          e,
          b[i]
        ]);
      }
    }, "Base");
    exports.Base = Base;
    exports.default = Base;
  }
});

// node_modules/treeify/treeify.js
var require_treeify = __commonJS({
  "node_modules/treeify/treeify.js"(exports, module) {
    init_esm_shims();
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.treeify = factory();
      }
    })(exports, function() {
      function makePrefix(key, last) {
        var str = last ? "\u2514" : "\u251C";
        if (key) {
          str += "\u2500 ";
        } else {
          str += "\u2500\u2500\u2510";
        }
        return str;
      }
      __name(makePrefix, "makePrefix");
      function filterKeys(obj, hideFunctions) {
        var keys = [];
        for (var branch in obj) {
          if (!obj.hasOwnProperty(branch)) {
            continue;
          }
          if (hideFunctions && typeof obj[branch] === "function") {
            continue;
          }
          keys.push(branch);
        }
        return keys;
      }
      __name(filterKeys, "filterKeys");
      function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([
          root,
          last
        ]) && lastStates.length > 0) {
          lastStates.forEach(function(lastState, idx) {
            if (idx > 0) {
              line += (lastState[1] ? " " : "\u2502") + "  ";
            }
            if (!circular && lastState[0] === root) {
              circular = true;
            }
          });
          line += makePrefix(key, last) + key;
          showValues && (typeof root !== "object" || root instanceof Date) && (line += ": " + root);
          circular && (line += " (circular ref.)");
          callback(line);
        }
        if (!circular && typeof root === "object") {
          var keys = filterKeys(root, hideFunctions);
          keys.forEach(function(branch) {
            lastKey = ++index === keys.length;
            growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
          });
        }
      }
      __name(growBranch, "growBranch");
      var Treeify = {};
      Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
        growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
      };
      Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = "";
        growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
          tree += line + "\n";
        });
        return tree;
      };
      return Treeify;
    });
  }
});

// node_modules/merkletreejs/dist/MerkleTree.js
var require_MerkleTree = __commonJS({
  "node_modules/merkletreejs/dist/MerkleTree.js"(exports) {
    init_esm_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MerkleTree = void 0;
    var buffer_reverse_1 = __importDefault(require_buffer_reverse());
    var sha256_1 = __importDefault(require_sha256());
    var Base_1 = __importDefault(require_Base());
    var treeify_1 = __importDefault(require_treeify());
    var MerkleTree2 = /* @__PURE__ */ __name(class MerkleTree3 extends Base_1.default {
      constructor(leaves, hashFn = sha256_1.default, options = {}) {
        super();
        this.duplicateOdd = false;
        this.hashLeaves = false;
        this.isBitcoinTree = false;
        this.leaves = [];
        this.layers = [];
        this.sortLeaves = false;
        this.sortPairs = false;
        this.sort = false;
        this.fillDefaultHash = null;
        this.isBitcoinTree = !!options.isBitcoinTree;
        this.hashLeaves = !!options.hashLeaves;
        this.sortLeaves = !!options.sortLeaves;
        this.sortPairs = !!options.sortPairs;
        if (options.fillDefaultHash) {
          if (typeof options.fillDefaultHash === "function") {
            this.fillDefaultHash = options.fillDefaultHash;
          } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === "string") {
            this.fillDefaultHash = (idx, hashFn2) => options.fillDefaultHash;
          } else {
            throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
          }
        }
        this.sort = !!options.sort;
        if (this.sort) {
          this.sortLeaves = true;
          this.sortPairs = true;
        }
        this.duplicateOdd = !!options.duplicateOdd;
        this.hashFn = this.bufferifyFn(hashFn);
        this.processLeaves(leaves);
      }
      processLeaves(leaves) {
        if (this.hashLeaves) {
          leaves = leaves.map(this.hashFn);
        }
        this.leaves = leaves.map(this.bufferify);
        if (this.sortLeaves) {
          this.leaves = this.leaves.sort(Buffer.compare);
        }
        if (this.fillDefaultHash) {
          for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {
            if (i >= this.leaves.length) {
              this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));
            }
          }
        }
        this.layers = [
          this.leaves
        ];
        this._createHashes(this.leaves);
      }
      _createHashes(nodes) {
        while (nodes.length > 1) {
          const layerIndex = this.layers.length;
          this.layers.push([]);
          for (let i = 0; i < nodes.length; i += 2) {
            if (i + 1 === nodes.length) {
              if (nodes.length % 2 === 1) {
                let data2 = nodes[nodes.length - 1];
                let hash2 = data2;
                if (this.isBitcoinTree) {
                  data2 = Buffer.concat([
                    buffer_reverse_1.default(data2),
                    buffer_reverse_1.default(data2)
                  ]);
                  hash2 = this.hashFn(data2);
                  hash2 = buffer_reverse_1.default(this.hashFn(hash2));
                  this.layers[layerIndex].push(hash2);
                  continue;
                } else {
                  if (this.duplicateOdd) ; else {
                    this.layers[layerIndex].push(nodes[i]);
                    continue;
                  }
                }
              }
            }
            const left = nodes[i];
            const right = i + 1 === nodes.length ? left : nodes[i + 1];
            let data = null;
            let combined = null;
            if (this.isBitcoinTree) {
              combined = [
                buffer_reverse_1.default(left),
                buffer_reverse_1.default(right)
              ];
            } else {
              combined = [
                left,
                right
              ];
            }
            if (this.sortPairs) {
              combined.sort(Buffer.compare);
            }
            data = Buffer.concat(combined);
            let hash = this.hashFn(data);
            if (this.isBitcoinTree) {
              hash = buffer_reverse_1.default(this.hashFn(hash));
            }
            this.layers[layerIndex].push(hash);
          }
          nodes = this.layers[layerIndex];
        }
      }
      addLeaf(leaf, shouldHash = false) {
        if (shouldHash) {
          leaf = this.hashFn(leaf);
        }
        this.processLeaves(this.leaves.concat(leaf));
      }
      addLeaves(leaves, shouldHash = false) {
        if (shouldHash) {
          leaves = leaves.map(this.hashFn);
        }
        this.processLeaves(this.leaves.concat(leaves));
      }
      getLeaves(values) {
        if (Array.isArray(values)) {
          if (this.hashLeaves) {
            values = values.map(this.hashFn);
            if (this.sortLeaves) {
              values = values.sort(Buffer.compare);
            }
          }
          return this.leaves.filter((leaf) => this._bufferIndexOf(values, leaf) !== -1);
        }
        return this.leaves;
      }
      getLeaf(index) {
        if (index < 0 || index > this.leaves.length - 1) {
          return Buffer.from([]);
        }
        return this.leaves[index];
      }
      getLeafIndex(target) {
        target = this.bufferify(target);
        const leaves = this.getLeaves();
        for (let i = 0; i < leaves.length; i++) {
          const leaf = leaves[i];
          if (leaf.equals(target)) {
            return i;
          }
        }
        return -1;
      }
      getLeafCount() {
        return this.leaves.length;
      }
      getHexLeaves() {
        return this.leaves.map((leaf) => this.bufferToHex(leaf));
      }
      static marshalLeaves(leaves) {
        return JSON.stringify(leaves.map((leaf) => MerkleTree3.bufferToHex(leaf)), null, 2);
      }
      static unmarshalLeaves(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map(MerkleTree3.bufferify);
      }
      getLayers() {
        return this.layers;
      }
      getHexLayers() {
        return this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.push(item.map((layer) => this.bufferToHex(layer)));
          } else {
            acc.push(item);
          }
          return acc;
        }, []);
      }
      getLayersFlat() {
        const layers = this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.unshift(...item);
          } else {
            acc.unshift(item);
          }
          return acc;
        }, []);
        layers.unshift(Buffer.from([
          0
        ]));
        return layers;
      }
      getHexLayersFlat() {
        return this.getLayersFlat().map((layer) => this.bufferToHex(layer));
      }
      getLayerCount() {
        return this.getLayers().length;
      }
      getRoot() {
        if (this.layers.length === 0) {
          return Buffer.from([]);
        }
        return this.layers[this.layers.length - 1][0] || Buffer.from([]);
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      getProof(leaf, index) {
        if (typeof leaf === "undefined") {
          throw new Error("leaf is required");
        }
        leaf = this.bufferify(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
          index = -1;
          for (let i = 0; i < this.leaves.length; i++) {
            if (Buffer.compare(leaf, this.leaves[i]) === 0) {
              index = i;
            }
          }
        }
        if (index <= -1) {
          return [];
        }
        for (let i = 0; i < this.layers.length; i++) {
          const layer = this.layers[i];
          const isRightNode = index % 2;
          const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? index : index + 1;
          if (pairIndex < layer.length) {
            proof.push({
              position: isRightNode ? "left" : "right",
              data: layer[pairIndex]
            });
          }
          index = index / 2 | 0;
        }
        return proof;
      }
      getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => this.bufferToHex(item.data));
      }
      getPositionalHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => {
          return [
            item.position === "left" ? 0 : 1,
            this.bufferToHex(item.data)
          ];
        });
      }
      static marshalProof(proof) {
        const json = proof.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          if (Buffer.isBuffer(item)) {
            return MerkleTree3.bufferToHex(item);
          }
          return {
            position: item.position,
            data: MerkleTree3.bufferToHex(item.data)
          };
        });
        return JSON.stringify(json, null, 2);
      }
      static unmarshalProof(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map((item) => {
          if (typeof item === "string") {
            return MerkleTree3.bufferify(item);
          } else if (item instanceof Object) {
            return {
              position: item.position,
              data: MerkleTree3.bufferify(item.data)
            };
          } else {
            throw new Error("Expected item to be of type string or object");
          }
        });
      }
      getProofIndices(treeIndices, depth) {
        const leafCount = Math.pow(2, depth);
        let maximalIndices = /* @__PURE__ */ new Set();
        for (const index2 of treeIndices) {
          let x = leafCount + index2;
          while (x > 1) {
            maximalIndices.add(x ^ 1);
            x = x / 2 | 0;
          }
        }
        const a1 = treeIndices.map((index) => leafCount + index);
        const b1 = Array.from(maximalIndices).sort((a, b) => a - b).reverse();
        maximalIndices = a1.concat(b1);
        const redundantIndices = /* @__PURE__ */ new Set();
        const proof = [];
        for (let index1 of maximalIndices) {
          if (!redundantIndices.has(index1)) {
            proof.push(index1);
            while (index1 > 1) {
              redundantIndices.add(index1);
              if (!redundantIndices.has(index1 ^ 1))
                break;
              index1 = index1 / 2 | 0;
            }
          }
        }
        return proof.filter((index) => {
          return !treeIndices.includes(index - leafCount);
        });
      }
      getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
        const depth = Math.ceil(Math.log2(leavesCount));
        const unevenLayers = [];
        for (let index3 = 0; index3 < depth; index3++) {
          const unevenLayer = leavesCount % 2 !== 0;
          if (unevenLayer) {
            unevenLayers.push({
              index: index3,
              leavesCount
            });
          }
          leavesCount = Math.ceil(leavesCount / 2);
        }
        const proofIndices = [];
        let layerNodes = sortedLeafIndices;
        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {
          const siblingIndices = layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index + 1;
            }
            return index - 1;
          });
          let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));
          const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);
          if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
            proofNodeIndices = proofNodeIndices.slice(0, -1);
          }
          proofIndices.push(proofNodeIndices);
          layerNodes = [
            ...new Set(layerNodes.map((index) => {
              if (index % 2 === 0) {
                return index / 2;
              }
              if (index % 2 === 0) {
                return (index + 1) / 2;
              }
              return (index - 1) / 2;
            }))
          ];
        }
        return proofIndices;
      }
      getMultiProof(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayersFlat();
        }
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          if (indices.every(Number.isInteger)) {
            return this.getMultiProofForUnevenTree(indices);
          }
        }
        if (!indices.every(Number.isInteger)) {
          let els = indices;
          if (this.sortPairs) {
            els = els.sort(Buffer.compare);
          }
          let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
          if (!ids.every((idx) => idx !== -1)) {
            throw new Error("Element does not exist in Merkle tree");
          }
          const hashes = [];
          const proof = [];
          let nextIds = [];
          for (let i1 = 0; i1 < this.layers.length; i1++) {
            const layer = this.layers[i1];
            for (let j = 0; j < ids.length; j++) {
              const idx = ids[j];
              const pairElement = this._getPairNode(layer, idx);
              hashes.push(layer[idx]);
              if (pairElement) {
                proof.push(pairElement);
              }
              nextIds.push(idx / 2 | 0);
            }
            ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);
            nextIds = [];
          }
          return proof.filter((value) => !hashes.includes(value));
        }
        return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map((index) => tree[index]);
      }
      getMultiProofForUnevenTree(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayers();
        }
        let proofHashes = [];
        let currentLayerIndices = indices;
        for (const treeLayer of tree) {
          const siblings = [];
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              const idx2 = index + 1;
              if (!currentLayerIndices.includes(idx2)) {
                if (treeLayer[idx2]) {
                  siblings.push(treeLayer[idx2]);
                  continue;
                }
              }
            }
            const idx = index - 1;
            if (!currentLayerIndices.includes(idx)) {
              if (treeLayer[idx]) {
                siblings.push(treeLayer[idx]);
                continue;
              }
            }
          }
          proofHashes = proofHashes.concat(siblings);
          const uniqueIndices = /* @__PURE__ */ new Set();
          for (const index4 of currentLayerIndices) {
            if (index4 % 2 === 0) {
              uniqueIndices.add(index4 / 2);
              continue;
            }
            if (index4 % 2 === 0) {
              uniqueIndices.add((index4 + 1) / 2);
              continue;
            }
            uniqueIndices.add((index4 - 1) / 2);
          }
          currentLayerIndices = Array.from(uniqueIndices);
        }
        return proofHashes;
      }
      getHexMultiProof(tree, indices) {
        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));
      }
      getProofFlags(leaves, proofs) {
        if (!Array.isArray(leaves) || leaves.length <= 0) {
          throw new Error("Invalid Inputs!");
        }
        let ids1;
        if (leaves.every(Number.isInteger)) {
          ids1 = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
        } else {
          ids1 = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
        }
        if (!ids1.every((idx) => idx !== -1)) {
          throw new Error("Element does not exist in Merkle tree");
        }
        const _proofs = proofs.map((item) => this.bufferify(item));
        const tested = [];
        const flags = [];
        for (let index = 0; index < this.layers.length; index++) {
          const layer = this.layers[index];
          ids1 = ids1.reduce((ids, idx) => {
            const skipped = tested.includes(layer[idx]);
            if (!skipped) {
              const pairElement = this._getPairNode(layer, idx);
              const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
              pairElement && flags.push(!proofUsed);
              tested.push(layer[idx]);
              tested.push(pairElement);
            }
            ids.push(idx / 2 | 0);
            return ids;
          }, []);
        }
        return flags;
      }
      verify(proof, targetNode, root) {
        let hash = this.bufferify(targetNode);
        root = this.bufferify(root);
        if (!Array.isArray(proof) || !targetNode || !root) {
          return false;
        }
        for (let i = 0; i < proof.length; i++) {
          const node = proof[i];
          let data = null;
          let isLeftNode = null;
          if (typeof node === "string") {
            data = this.bufferify(node);
            isLeftNode = true;
          } else if (Array.isArray(node)) {
            isLeftNode = node[0] === 0;
            data = this.bufferify(node[1]);
          } else if (Buffer.isBuffer(node)) {
            data = node;
            isLeftNode = true;
          } else if (node instanceof Object) {
            data = this.bufferify(node.data);
            isLeftNode = node.position === "left";
          } else {
            throw new Error("Expected node to be of type string or object");
          }
          const buffers = [];
          if (this.isBitcoinTree) {
            buffers.push(buffer_reverse_1.default(hash));
            buffers[isLeftNode ? "unshift" : "push"](buffer_reverse_1.default(data));
            hash = this.hashFn(Buffer.concat(buffers));
            hash = buffer_reverse_1.default(this.hashFn(hash));
          } else {
            if (this.sortPairs) {
              if (Buffer.compare(hash, data) === -1) {
                buffers.push(hash, data);
                hash = this.hashFn(Buffer.concat(buffers));
              } else {
                buffers.push(data, hash);
                hash = this.hashFn(Buffer.concat(buffers));
              }
            } else {
              buffers.push(hash);
              buffers[isLeftNode ? "unshift" : "push"](data);
              hash = this.hashFn(Buffer.concat(buffers));
            }
          }
        }
        return Buffer.compare(hash, root) === 0;
      }
      verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
        }
        const depth = Math.ceil(Math.log2(leavesCount));
        root = this.bufferify(root);
        proofLeaves = proofLeaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const tree = {};
        for (const [index, leaf1] of this._zip(proofIndices, proofLeaves)) {
          tree[Math.pow(2, depth) + index] = leaf1;
        }
        for (const [index5, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {
          tree[index5] = proofitem;
        }
        let indexqueue = Object.keys(tree).map((value) => +value).sort((a, b) => a - b);
        indexqueue = indexqueue.slice(0, indexqueue.length - 1);
        let i = 0;
        while (i < indexqueue.length) {
          const index = indexqueue[i];
          if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {
            let pair = [
              tree[index - index % 2],
              tree[index - index % 2 + 1]
            ];
            if (this.sortPairs) {
              pair = pair.sort(Buffer.compare);
            }
            const hash = pair[1] ? this.hashFn(Buffer.concat(pair)) : pair[0];
            tree[index / 2 | 0] = hash;
            indexqueue.push(index / 2 | 0);
          }
          i += 1;
        }
        return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);
      }
      verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
        root = this.bufferify(root);
        leaves = leaves.map(this.bufferify);
        proofs = proofs.map(this.bufferify);
        const leavesLen = leaves.length;
        const totalHashes = proofFlag.length;
        const hashes = [];
        let leafPos = 0;
        let hashPos = 0;
        let proofPos = 0;
        for (let i = 0; i < totalHashes; i++) {
          const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
          const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
          const buffers = [
            bufA,
            bufB
          ].sort(Buffer.compare);
          hashes[i] = this.hashFn(Buffer.concat(buffers));
        }
        return Buffer.compare(hashes[totalHashes - 1], root) === 0;
      }
      verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
        root = this.bufferify(root);
        leaves = leaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
        return root.equals(computedRoot);
      }
      getDepth() {
        return this.getLayers().length - 1;
      }
      getLayersAsObject() {
        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));
        const objs = [];
        for (let i = 0; i < layers.length; i++) {
          const arr = [];
          for (let j = 0; j < layers[i].length; j++) {
            const obj = {
              [layers[i][j]]: null
            };
            if (objs.length) {
              obj[layers[i][j]] = {};
              const a = objs.shift();
              const akey = Object.keys(a)[0];
              obj[layers[i][j]][akey] = a[akey];
              if (objs.length) {
                const b = objs.shift();
                const bkey = Object.keys(b)[0];
                obj[layers[i][j]][bkey] = b[bkey];
              }
            }
            arr.push(obj);
          }
          objs.push(...arr);
        }
        return objs[0];
      }
      static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {
        const tree = new MerkleTree3([], hashFn, options);
        return tree.verify(proof, targetNode, root);
      }
      static getMultiProof(tree, indices) {
        const t = new MerkleTree3([]);
        return t.getMultiProof(tree, indices);
      }
      resetTree() {
        this.leaves = [];
        this.layers = [];
      }
      _getPairNode(layer, idx) {
        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
        if (pairIdx < layer.length) {
          return layer[pairIdx];
        } else {
          return null;
        }
      }
      _toTreeString() {
        const obj = this.getLayersAsObject();
        return treeify_1.default.asTree(obj, true);
      }
      toString() {
        return this._toTreeString();
      }
      isUnevenTree(treeLayers) {
        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();
        return !this.isPowOf2(depth);
      }
      isPowOf2(v) {
        return v && !(v & v - 1);
      }
      calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
        const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);
        const leafTupleIndices = leafTuples.map(([index]) => index);
        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
        let nextSliceStart = 0;
        const proofTuplesByLayers = [];
        for (let i = 0; i < proofIndices.length; i++) {
          const indices = proofIndices[i];
          const sliceStart = nextSliceStart;
          nextSliceStart += indices.length;
          proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
        }
        const tree = [
          leafTuples
        ];
        for (let layerIndex1 = 0; layerIndex1 < proofTuplesByLayers.length; layerIndex1++) {
          const currentLayer = proofTuplesByLayers[layerIndex1].concat(tree[layerIndex1]).sort(([indexA], [indexB]) => indexA - indexB).map(([, hash]) => hash);
          const s = tree[layerIndex1].map(([layerIndex]) => layerIndex);
          const parentIndices = [
            ...new Set(s.map((index) => {
              if (index % 2 === 0) {
                return index / 2;
              }
              if (index % 2 === 0) {
                return (index + 1) / 2;
              }
              return (index - 1) / 2;
            }))
          ];
          const parentLayer = [];
          for (let i = 0; i < parentIndices.length; i++) {
            const parentNodeTreeIndex = parentIndices[i];
            const bufA = currentLayer[i * 2];
            const bufB = currentLayer[i * 2 + 1];
            const hash = bufB ? this.hashFn(Buffer.concat([
              bufA,
              bufB
            ])) : bufA;
            parentLayer.push([
              parentNodeTreeIndex,
              hash
            ]);
          }
          tree.push(parentLayer);
        }
        return tree[tree.length - 1][0][1];
      }
    }, "MerkleTree");
    exports.MerkleTree = MerkleTree2;
    if (typeof window !== "undefined") {
      window.MerkleTree = MerkleTree2;
    }
    exports.default = MerkleTree2;
  }
});

// node_modules/merkletreejs/dist/MerkleMountainRange.js
var require_MerkleMountainRange = __commonJS({
  "node_modules/merkletreejs/dist/MerkleMountainRange.js"(exports) {
    init_esm_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MerkleMountainRange = void 0;
    var Base_1 = __importDefault(require_Base());
    var sha256_1 = __importDefault(require_sha256());
    var MerkleMountainRange = /* @__PURE__ */ __name(class MerkleMountainRange extends Base_1.default {
      constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {
        super();
        this.root = Buffer.alloc(0);
        this.size = 0;
        this.width = 0;
        this.hashes = {};
        this.data = {};
        leaves = leaves.map(this.bufferify);
        this.hashFn = this.bufferifyFn(hashFn);
        this.hashLeafFn = hashLeafFn;
        this.peakBaggingFn = peakBaggingFn;
        this.hashBranchFn = hashBranchFn;
        for (const leaf of leaves) {
          this.append(leaf);
        }
      }
      append(data) {
        data = this.bufferify(data);
        const dataHash = this.hashFn(data);
        const dataHashHex = this.bufferToHex(dataHash);
        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {
          this.data[dataHashHex] = data;
        }
        const leaf = this.hashLeaf(this.size + 1, dataHash);
        this.hashes[this.size + 1] = leaf;
        this.width += 1;
        const peakIndexes = this.getPeakIndexes(this.width);
        this.size = this.getSize(this.width);
        const peaks = [];
        for (let i = 0; i < peakIndexes.length; i++) {
          peaks[i] = this._getOrCreateNode(peakIndexes[i]);
        }
        this.root = this.peakBagging(this.width, peaks);
      }
      hashLeaf(index, dataHash) {
        dataHash = this.bufferify(dataHash);
        if (this.hashLeafFn) {
          return this.bufferify(this.hashLeafFn(index, dataHash));
        }
        return this.hashFn(Buffer.concat([
          this.bufferify(index),
          dataHash
        ]));
      }
      hashBranch(index, left, right) {
        if (this.hashBranchFn) {
          return this.bufferify(this.hashBranchFn(index, left, right));
        }
        return this.hashFn(Buffer.concat([
          this.bufferify(index),
          this.bufferify(left),
          this.bufferify(right)
        ]));
      }
      getPeaks() {
        const peakIndexes = this.getPeakIndexes(this.width);
        const peaks = [];
        for (let i = 0; i < peakIndexes.length; i++) {
          peaks[i] = this.hashes[peakIndexes[i]];
        }
        return peaks;
      }
      getLeafIndex(width) {
        if (width % 2 === 1) {
          return this.getSize(width);
        }
        return this.getSize(width - 1) + 1;
      }
      getPeakIndexes(width) {
        const numPeaks = this.numOfPeaks(width);
        const peakIndexes = [];
        let count = 0;
        let size = 0;
        for (let i = 255; i > 0; i--) {
          if ((width & 1 << i - 1) !== 0) {
            size = size + (1 << i) - 1;
            peakIndexes[count++] = size;
            if (peakIndexes.length >= numPeaks) {
              break;
            }
          }
        }
        if (count !== peakIndexes.length) {
          throw new Error("invalid bit calculation");
        }
        return peakIndexes;
      }
      numOfPeaks(width) {
        let bits = width;
        let num = 0;
        while (bits > 0) {
          if (bits % 2 === 1) {
            num++;
          }
          bits = bits >> 1;
        }
        return num;
      }
      peakBagging(width, peaks) {
        const size = this.getSize(width);
        if (this.numOfPeaks(width) !== peaks.length) {
          throw new Error("received invalid number of peaks");
        }
        if (width === 0 && !peaks.length) {
          return Buffer.alloc(0);
        }
        if (this.peakBaggingFn) {
          return this.bufferify(this.peakBaggingFn(size, peaks));
        }
        return this.hashFn(Buffer.concat([
          this.bufferify(size),
          ...peaks.map(this.bufferify)
        ]));
      }
      getSize(width) {
        return (width << 1) - this.numOfPeaks(width);
      }
      getRoot() {
        return this.root;
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      getNode(index) {
        return this.hashes[index];
      }
      mountainHeight(size) {
        let height = 1;
        while (1 << height <= size + height) {
          height++;
        }
        return height - 1;
      }
      heightAt(index) {
        let reducedIndex = index;
        let peakIndex = 0;
        let height = 0;
        while (reducedIndex > peakIndex) {
          reducedIndex -= (1 << height) - 1;
          height = this.mountainHeight(reducedIndex);
          peakIndex = (1 << height) - 1;
        }
        return height - (peakIndex - reducedIndex);
      }
      isLeaf(index) {
        return this.heightAt(index) === 1;
      }
      getChildren(index) {
        const left = index - (1 << this.heightAt(index) - 1);
        const right = index - 1;
        if (left === right) {
          throw new Error("not a parent");
        }
        return [
          left,
          right
        ];
      }
      getMerkleProof(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.isLeaf(index)) {
          throw new Error("not a leaf");
        }
        const root = this.root;
        const width = this.width;
        const peaks = this.getPeakIndexes(this.width);
        const peakBagging = [];
        let cursor = 0;
        for (let i = 0; i < peaks.length; i++) {
          peakBagging[i] = this.hashes[peaks[i]];
          if (peaks[i] >= index && cursor === 0) {
            cursor = peaks[i];
          }
        }
        let left = 0;
        let right = 0;
        let height = this.heightAt(cursor);
        const siblings = [];
        while (cursor !== index) {
          height--;
          [left, right] = this.getChildren(cursor);
          cursor = index <= left ? left : right;
          siblings[height - 1] = this.hashes[index <= left ? right : left];
        }
        return {
          root,
          width,
          peakBagging,
          siblings
        };
      }
      verify(root, width, index, value, peaks, siblings) {
        value = this.bufferify(value);
        const size = this.getSize(width);
        if (size < index) {
          throw new Error("index is out of range");
        }
        if (!root.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let cursor = 0;
        let targetPeak;
        const peakIndexes = this.getPeakIndexes(width);
        for (let i = 0; i < peakIndexes.length; i++) {
          if (peakIndexes[i] >= index) {
            targetPeak = peaks[i];
            cursor = peakIndexes[i];
            break;
          }
        }
        if (!targetPeak) {
          throw new Error("target not found");
        }
        let height = siblings.length + 1;
        const path = new Array(height);
        let left = 0;
        let right = 0;
        while (height > 0) {
          path[--height] = cursor;
          if (cursor === index) {
            break;
          } else {
            [left, right] = this.getChildren(cursor);
            cursor = index > left ? right : left;
            continue;
          }
        }
        let node;
        while (height < path.length) {
          cursor = path[height];
          if (height === 0) {
            node = this.hashLeaf(cursor, this.hashFn(value));
          } else if (cursor - 1 === path[height - 1]) {
            node = this.hashBranch(cursor, siblings[height - 1], node);
          } else {
            node = this.hashBranch(cursor, node, siblings[height - 1]);
          }
          height++;
        }
        if (!node.equals(targetPeak)) {
          throw new Error("hashed peak is invalid");
        }
        return true;
      }
      peaksToPeakMap(width, peaks) {
        const peakMap = {};
        let bitIndex = 0;
        let peakRef = 0;
        let count = peaks.length;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          peakRef = 1 << height - 1;
          if ((width & peakRef) !== 0) {
            peakMap[bitIndex] = peaks[--count];
          } else {
            peakMap[bitIndex] = 0;
          }
        }
        if (count !== 0) {
          throw new Error("invalid number of peaks");
        }
        return peakMap;
      }
      peakMapToPeaks(width, peakMap) {
        const arrLength = this.numOfPeaks(width);
        const peaks = new Array(arrLength);
        let count = 0;
        for (let i = 0; i < 32; i++) {
          if (peakMap[i] !== 0) {
            peaks[count++] = peakMap[i];
          }
        }
        if (count !== arrLength) {
          throw new Error("invalid number of peaks");
        }
        return peaks;
      }
      peakUpdate(width, prevPeakMap, itemHash) {
        const nextPeakMap = {};
        const newWidth = width + 1;
        let cursorIndex = this.getLeafIndex(newWidth);
        let cursorNode = this.hashLeaf(cursorIndex, itemHash);
        let bitIndex = 0;
        let peakRef = 0;
        let prevPeakExist = false;
        let nextPeakExist = false;
        let obtained = false;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          if (obtained) {
            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
          } else {
            peakRef = 1 << height - 1;
            prevPeakExist = (width & peakRef) !== 0;
            nextPeakExist = (newWidth & peakRef) !== 0;
            cursorIndex++;
            if (prevPeakExist) {
              cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);
            }
            if (nextPeakExist) {
              if (prevPeakExist) {
                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
              } else {
                nextPeakMap[bitIndex] = cursorNode;
              }
              obtained = true;
            } else {
              nextPeakMap[bitIndex] = 0;
            }
          }
        }
        return nextPeakMap;
      }
      rollUp(root, width, peaks, itemHashes) {
        if (!root.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let tmpWidth = width;
        let tmpPeakMap = this.peaksToPeakMap(width, peaks);
        for (let i = 0; i < itemHashes.length; i++) {
          tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);
          tmpWidth++;
        }
        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));
      }
      _getOrCreateNode(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.hashes[index]) {
          const [leftIndex, rightIndex] = this.getChildren(index);
          const leftHash = this._getOrCreateNode(leftIndex);
          const rightHash = this._getOrCreateNode(rightIndex);
          this.hashes[index] = this.hashBranch(index, leftHash, rightHash);
        }
        return this.hashes[index];
      }
    }, "MerkleMountainRange");
    exports.MerkleMountainRange = MerkleMountainRange;
    exports.default = MerkleMountainRange;
  }
});

// node_modules/merkletreejs/dist/index.js
var require_dist = __commonJS({
  "node_modules/merkletreejs/dist/index.js"(exports) {
    init_esm_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MerkleTree = void 0;
    var MerkleTree_1 = __importDefault(require_MerkleTree());
    exports.MerkleTree = MerkleTree_1.default;
    var MerkleMountainRange_1 = require_MerkleMountainRange();
    Object.defineProperty(exports, "MerkleMountainRange", {
      enumerable: true,
      get: function() {
        return MerkleMountainRange_1.MerkleMountainRange;
      }
    });
    exports.default = MerkleTree_1.default;
  }
});

// abis/TokenERC721.json
var require_TokenERC721 = __commonJS({
  "abis/TokenERC721.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_thirdwebFee",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "approved",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdMinted",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "uri",
            type: "string"
          }
        ],
        name: "TokensMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdMinted",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct ITokenERC721.MintRequest",
            name: "mintRequest",
            type: "tuple"
          }
        ],
        name: "TokensMintedWithSignature",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "_royaltyBps",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "_platformFeeBps",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "mintTo",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ITokenERC721.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "mintWithSignature",
        outputs: [
          {
            internalType: "uint256",
            name: "tokenIdMinted",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "platformFeeBps",
        outputs: [
          {
            internalType: "uint128",
            name: "",
            type: "uint128"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "platformFeeRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "thirdwebFee",
        outputs: [
          {
            internalType: "contract ITWFee",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenOfOwnerByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ITokenERC721.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "verify",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/DropERC1155.json
var require_DropERC1155 = __commonJS({
  "abis/DropERC1155.json"(exports, module) {
    module.exports = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            indexed: false,
            internalType: "struct IDropClaimCondition.ClaimCondition[]",
            name: "claimConditions",
            type: "tuple[]"
          }
        ],
        name: "ClaimConditionsUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "maxTotalSupply",
            type: "uint256"
          }
        ],
        name: "MaxTotalSupplyUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        name: "MaxWalletClaimCountUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "address",
            name: "saleRecipient",
            type: "address"
          }
        ],
        name: "SaleRecipientForTokenUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "claimConditionIndex",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "claimer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityClaimed",
            type: "uint256"
          }
        ],
        name: "TokensClaimed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "startTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "endTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "baseURI",
            type: "string"
          }
        ],
        name: "TokensLazyMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "TransferBatch",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TransferSingle",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "value",
            type: "string"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "URI",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "wallet",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        name: "WalletClaimCountUpdated",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "accounts",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          }
        ],
        name: "balanceOfBatch",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "burnBatch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_proofs",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "_proofMaxQuantityPerTransaction",
            type: "uint256"
          }
        ],
        name: "claim",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "claimCondition",
        outputs: [
          {
            internalType: "uint256",
            name: "currentStartId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getActiveClaimConditionId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          }
        ],
        name: "getClaimConditionById",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IDropClaimCondition.ClaimCondition",
            name: "condition",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          }
        ],
        name: "getClaimTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "lastClaimTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nextValidClaimTimestamp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "_royaltyBps",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "_platformFeeBps",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "_baseURIForTokens",
            type: "string"
          }
        ],
        name: "lazyMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "maxTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "maxWalletClaimCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeBatchTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "saleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IDropClaimCondition.ClaimCondition[]",
            name: "_phases",
            type: "tuple[]"
          },
          {
            internalType: "bool",
            name: "_resetClaimEligibility",
            type: "bool"
          }
        ],
        name: "setClaimConditions",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_maxTotalSupply",
            type: "uint256"
          }
        ],
        name: "setMaxTotalSupply",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_count",
            type: "uint256"
          }
        ],
        name: "setMaxWalletClaimCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setSaleRecipientForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_count",
            type: "uint256"
          }
        ],
        name: "setWalletClaimCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "uri",
        outputs: [
          {
            internalType: "string",
            name: "_tokenURI",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "verifyMaxQuantityPerTransaction",
            type: "bool"
          }
        ],
        name: "verifyClaim",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_proofs",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "_proofMaxQuantityPerTransaction",
            type: "uint256"
          }
        ],
        name: "verifyClaimMerkleProof",
        outputs: [
          {
            internalType: "bool",
            name: "validMerkleProof",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "merkleProofIndex",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "walletClaimCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/TokenERC1155.json
var require_TokenERC1155 = __commonJS({
  "abis/TokenERC1155.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_thirdwebFee",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdMinted",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityMinted",
            type: "uint256"
          }
        ],
        name: "TokensMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdMinted",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct ITokenERC1155.MintRequest",
            name: "mintRequest",
            type: "tuple"
          }
        ],
        name: "TokensMintedWithSignature",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "TransferBatch",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TransferSingle",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "value",
            type: "string"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "URI",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "accounts",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          }
        ],
        name: "balanceOfBatch",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "burnBatch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "_royaltyBps",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "_platformFeeBps",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "mintTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ITokenERC1155.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "mintWithSignature",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "platformFeeBps",
        outputs: [
          {
            internalType: "uint128",
            name: "",
            type: "uint128"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "platformFeeRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeBatchTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "saleRecipientForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "thirdwebFee",
        outputs: [
          {
            internalType: "contract ITWFee",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "uri",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ITokenERC1155.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "verify",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/TokenERC20.json
var require_TokenERC20 = __commonJS({
  "abis/TokenERC20.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_thirdwebFee",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "fromDelegate",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "toDelegate",
            type: "address"
          }
        ],
        name: "DelegateChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegate",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "previousBalance",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newBalance",
            type: "uint256"
          }
        ],
        name: "DelegateVotesChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Paused",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityMinted",
            type: "uint256"
          }
        ],
        name: "TokensMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct ITokenERC20.MintRequest",
            name: "mintRequest",
            type: "tuple"
          }
        ],
        name: "TokensMintedWithSignature",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Unpaused",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burnFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint32",
            name: "pos",
            type: "uint32"
          }
        ],
        name: "checkpoints",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "fromBlock",
                type: "uint32"
              },
              {
                internalType: "uint224",
                name: "votes",
                type: "uint224"
              }
            ],
            internalType: "struct ERC20VotesUpgradeable.Checkpoint",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "subtractedValue",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          }
        ],
        name: "delegate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expiry",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "delegateBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "delegates",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getPastTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getPastVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "mintTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ITokenERC20.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "mintWithSignature",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "numCheckpoints",
        outputs: [
          {
            internalType: "uint32",
            name: "",
            type: "uint32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "paused",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ITokenERC20.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "verify",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/VoteERC20.json
var require_VoteERC20 = __commonJS({
  "abis/VoteERC20.json"(exports, module) {
    module.exports = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        name: "ProposalCanceled",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "address",
            name: "proposer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address[]",
            name: "targets",
            type: "address[]"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          },
          {
            indexed: false,
            internalType: "string[]",
            name: "signatures",
            type: "string[]"
          },
          {
            indexed: false,
            internalType: "bytes[]",
            name: "calldatas",
            type: "bytes[]"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "startBlock",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "endBlock",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "description",
            type: "string"
          }
        ],
        name: "ProposalCreated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        name: "ProposalExecuted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "oldProposalThreshold",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newProposalThreshold",
            type: "uint256"
          }
        ],
        name: "ProposalThresholdSet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "oldQuorumNumerator",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newQuorumNumerator",
            type: "uint256"
          }
        ],
        name: "QuorumNumeratorUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "voter",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint8",
            name: "support",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "weight",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "reason",
            type: "string"
          }
        ],
        name: "VoteCast",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "oldVotingDelay",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newVotingDelay",
            type: "uint256"
          }
        ],
        name: "VotingDelaySet",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "oldVotingPeriod",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newVotingPeriod",
            type: "uint256"
          }
        ],
        name: "VotingPeriodSet",
        type: "event"
      },
      {
        inputs: [],
        name: "BALLOT_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "COUNTING_MODE",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "support",
            type: "uint8"
          }
        ],
        name: "castVote",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "support",
            type: "uint8"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "castVoteBySig",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "support",
            type: "uint8"
          },
          {
            internalType: "string",
            name: "reason",
            type: "string"
          }
        ],
        name: "castVoteWithReason",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "targets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "calldatas",
            type: "bytes[]"
          },
          {
            internalType: "bytes32",
            name: "descriptionHash",
            type: "bytes32"
          }
        ],
        name: "execute",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "getAllProposals",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "proposalId",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "proposer",
                type: "address"
              },
              {
                internalType: "address[]",
                name: "targets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "values",
                type: "uint256[]"
              },
              {
                internalType: "string[]",
                name: "signatures",
                type: "string[]"
              },
              {
                internalType: "bytes[]",
                name: "calldatas",
                type: "bytes[]"
              },
              {
                internalType: "uint256",
                name: "startBlock",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endBlock",
                type: "uint256"
              },
              {
                internalType: "string",
                name: "description",
                type: "string"
              }
            ],
            internalType: "struct VoteERC20.Proposal[]",
            name: "allProposals",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasVoted",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "targets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "calldatas",
            type: "bytes[]"
          },
          {
            internalType: "bytes32",
            name: "descriptionHash",
            type: "bytes32"
          }
        ],
        name: "hashProposal",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_initialVotingDelay",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_initialVotingPeriod",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_initialProposalThreshold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_initialVoteQuorumFraction",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        name: "proposalDeadline",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "proposalIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        name: "proposalSnapshot",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "proposalThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        name: "proposalVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "againstVotes",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "forVotes",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "abstainVotes",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "proposals",
        outputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "proposer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "startBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endBlock",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "targets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          },
          {
            internalType: "bytes[]",
            name: "calldatas",
            type: "bytes[]"
          },
          {
            internalType: "string",
            name: "description",
            type: "string"
          }
        ],
        name: "propose",
        outputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "quorum",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "quorumDenominator",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "quorumNumerator",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "relay",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newProposalThreshold",
            type: "uint256"
          }
        ],
        name: "setProposalThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newVotingDelay",
            type: "uint256"
          }
        ],
        name: "setVotingDelay",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newVotingPeriod",
            type: "uint256"
          }
        ],
        name: "setVotingPeriod",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          }
        ],
        name: "state",
        outputs: [
          {
            internalType: "enum IGovernorUpgradeable.ProposalState",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "contract IVotesUpgradeable",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newQuorumNumerator",
            type: "uint256"
          }
        ],
        name: "updateQuorumNumerator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "version",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "votingDelay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "votingPeriod",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
  }
});

// abis/Split.json
var require_Split = __commonJS({
  "abis/Split.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_thirdwebFee",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "contract IERC20Upgradeable",
            name: "token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "ERC20PaymentReleased",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "shares",
            type: "uint256"
          }
        ],
        name: "PayeeAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "PaymentReceived",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "PaymentReleased",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20Upgradeable",
            name: "token",
            type: "address"
          }
        ],
        name: "distribute",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "distribute",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "_payees",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "_shares",
            type: "uint256[]"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "payee",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "payeeCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "account",
            type: "address"
          }
        ],
        name: "release",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20Upgradeable",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "release",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20Upgradeable",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "released",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "released",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "shares",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "thirdwebFee",
        outputs: [
          {
            internalType: "contract ITWFee",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20Upgradeable",
            name: "token",
            type: "address"
          }
        ],
        name: "totalReleased",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalReleased",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalShares",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
  }
});

// abis/Marketplace.json
var require_Marketplace = __commonJS({
  "abis/Marketplace.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_nativeTokenWrapper",
            type: "address"
          },
          {
            internalType: "address",
            name: "_thirdwebFee",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "timeBuffer",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "bidBufferBps",
            type: "uint256"
          }
        ],
        name: "AuctionBuffersUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "closer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "bool",
            name: "cancelled",
            type: "bool"
          },
          {
            indexed: false,
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "winningBidder",
            type: "address"
          }
        ],
        name: "AuctionClosed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "lister",
            type: "address"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "listingId",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "tokenOwner",
                type: "address"
              },
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "startTime",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endTime",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "reservePricePerToken",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "buyoutPricePerToken",
                type: "uint256"
              },
              {
                internalType: "enum IMarketplace.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "enum IMarketplace.ListingType",
                name: "listingType",
                type: "uint8"
              }
            ],
            indexed: false,
            internalType: "struct IMarketplace.Listing",
            name: "listing",
            type: "tuple"
          }
        ],
        name: "ListingAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "listingCreator",
            type: "address"
          }
        ],
        name: "ListingRemoved",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "listingCreator",
            type: "address"
          }
        ],
        name: "ListingUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            indexed: true,
            internalType: "enum IMarketplace.ListingType",
            name: "listingType",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityWanted",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalOfferAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        name: "NewOffer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "lister",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "buyer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityBought",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalPricePaid",
            type: "uint256"
          }
        ],
        name: "NewSale",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "MAX_BPS",
        outputs: [
          {
            internalType: "uint64",
            name: "",
            type: "uint64"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          }
        ],
        name: "acceptOffer",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "bidBufferBps",
        outputs: [
          {
            internalType: "uint64",
            name: "",
            type: "uint64"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_buyFor",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantityToBuy",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_totalPrice",
            type: "uint256"
          }
        ],
        name: "buy",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_listingId",
            type: "uint256"
          }
        ],
        name: "cancelDirectListing",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_closeFor",
            type: "address"
          }
        ],
        name: "closeAuction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "startTime",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "secondsUntilEndTime",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityToList",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currencyToAccept",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "reservePricePerToken",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "buyoutPricePerToken",
                type: "uint256"
              },
              {
                internalType: "enum IMarketplace.ListingType",
                name: "listingType",
                type: "uint8"
              }
            ],
            internalType: "struct IMarketplace.ListingParameters",
            name: "_params",
            type: "tuple"
          }
        ],
        name: "createListing",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "listings",
        outputs: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "tokenOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reservePricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutPricePerToken",
            type: "uint256"
          },
          {
            internalType: "enum IMarketplace.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IMarketplace.ListingType",
            name: "listingType",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_quantityWanted",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_expirationTimestamp",
            type: "uint256"
          }
        ],
        name: "offer",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "offers",
        outputs: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantityWanted",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_timeBuffer",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_bidBufferBps",
            type: "uint256"
          }
        ],
        name: "setAuctionBuffers",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "thirdwebFee",
        outputs: [
          {
            internalType: "contract ITWFee",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "timeBuffer",
        outputs: [
          {
            internalType: "uint64",
            name: "",
            type: "uint64"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalListings",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_listingId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_quantityToList",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_reservePricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_buyoutPricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currencyToAccept",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_startTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_secondsUntilEndTime",
            type: "uint256"
          }
        ],
        name: "updateListing",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "winningBid",
        outputs: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantityWanted",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
  }
});

// abis/Pack.json
var require_Pack = __commonJS({
  "abis/Pack.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_nativeTokenWrapper",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "prevURI",
            type: "string"
          },
          {
            indexed: false,
            internalType: "string",
            name: "newURI",
            type: "string"
          }
        ],
        name: "ContractURIUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "packId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "packCreator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalPacksCreated",
            type: "uint256"
          }
        ],
        name: "PackCreated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "packId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "opener",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "numOfPacksOpened",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            indexed: false,
            internalType: "struct ITokenBundle.Token[]",
            name: "rewardUnitsDistributed",
            type: "tuple[]"
          }
        ],
        name: "PackOpened",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Paused",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            indexed: false,
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "TransferBatch",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TransferSingle",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "value",
            type: "string"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "URI",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Unpaused",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "NATIVE_TOKEN",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "accounts",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          }
        ],
        name: "balanceOfBatch",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token[]",
            name: "_contents",
            type: "tuple[]"
          },
          {
            internalType: "uint256[]",
            name: "_numOfRewardUnits",
            type: "uint256[]"
          },
          {
            internalType: "string",
            name: "_packUri",
            type: "string"
          },
          {
            internalType: "uint128",
            name: "_openStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "_amountDistributedPerOpen",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "createPack",
        outputs: [
          {
            internalType: "uint256",
            name: "packId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "packTotalSupply",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_packId",
            type: "uint256"
          }
        ],
        name: "getPackContents",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token[]",
            name: "contents",
            type: "tuple[]"
          },
          {
            internalType: "uint256[]",
            name: "perUnitAmounts",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "member",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_bundleId",
            type: "uint256"
          }
        ],
        name: "getTokenCountOfBundle",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_bundleId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getTokenOfBundle",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_bundleId",
            type: "uint256"
          }
        ],
        name: "getUriOfBundle",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRoleWithSwitch",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_packId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_amountToOpen",
            type: "uint256"
          }
        ],
        name: "openPack",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "paused",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeBatchTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "uri",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
  }
});

// abis/DropERC721.json
var require_DropERC721 = __commonJS({
  "abis/DropERC721.json"(exports, module) {
    module.exports = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "approved",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            indexed: false,
            internalType: "struct IDropClaimCondition.ClaimCondition[]",
            name: "claimConditions",
            type: "tuple[]"
          }
        ],
        name: "ClaimConditionsUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "maxTotalSupply",
            type: "uint256"
          }
        ],
        name: "MaxTotalSupplyUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        name: "MaxWalletClaimCountUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "endTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "revealedURI",
            type: "string"
          }
        ],
        name: "NFTRevealed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "claimConditionIndex",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "claimer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "startTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityClaimed",
            type: "uint256"
          }
        ],
        name: "TokensClaimed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "startTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "endTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "baseURI",
            type: "string"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "encryptedBaseURI",
            type: "bytes"
          }
        ],
        name: "TokensLazyMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "wallet",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        name: "WalletClaimCountUpdated",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "baseURIIndices",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_proofs",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "_proofMaxQuantityPerTransaction",
            type: "uint256"
          }
        ],
        name: "claim",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "claimCondition",
        outputs: [
          {
            internalType: "uint256",
            name: "currentStartId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "key",
            type: "bytes"
          }
        ],
        name: "encryptDecrypt",
        outputs: [
          {
            internalType: "bytes",
            name: "result",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "encryptedData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getActiveClaimConditionId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getBaseURICount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          }
        ],
        name: "getClaimConditionById",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IDropClaimCondition.ClaimCondition",
            name: "condition",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          }
        ],
        name: "getClaimTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "lastClaimTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nextValidClaimTimestamp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "_royaltyBps",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "_platformFeeBps",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "_baseURIForTokens",
            type: "string"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "lazyMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "maxTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "maxWalletClaimCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToClaim",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_key",
            type: "bytes"
          }
        ],
        name: "reveal",
        outputs: [
          {
            internalType: "string",
            name: "revealedURI",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IDropClaimCondition.ClaimCondition[]",
            name: "_phases",
            type: "tuple[]"
          },
          {
            internalType: "bool",
            name: "_resetClaimEligibility",
            type: "bool"
          }
        ],
        name: "setClaimConditions",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_maxTotalSupply",
            type: "uint256"
          }
        ],
        name: "setMaxTotalSupply",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_count",
            type: "uint256"
          }
        ],
        name: "setMaxWalletClaimCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_count",
            type: "uint256"
          }
        ],
        name: "setWalletClaimCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "tokenOfOwnerByIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "verifyMaxQuantityPerTransaction",
            type: "bool"
          }
        ],
        name: "verifyClaim",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_proofs",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "_proofMaxQuantityPerTransaction",
            type: "uint256"
          }
        ],
        name: "verifyClaimMerkleProof",
        outputs: [
          {
            internalType: "bool",
            name: "validMerkleProof",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "merkleProofIndex",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "walletClaimCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/DropERC20.json
var require_DropERC20 = __commonJS({
  "abis/DropERC20.json"(exports, module) {
    module.exports = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            indexed: false,
            internalType: "struct IDropClaimCondition.ClaimCondition[]",
            name: "claimConditions",
            type: "tuple[]"
          }
        ],
        name: "ClaimConditionsUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "fromDelegate",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "toDelegate",
            type: "address"
          }
        ],
        name: "DelegateChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegate",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "previousBalance",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newBalance",
            type: "uint256"
          }
        ],
        name: "DelegateVotesChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "maxTotalSupply",
            type: "uint256"
          }
        ],
        name: "MaxTotalSupplyUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        name: "MaxWalletClaimCountUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "claimConditionIndex",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "claimer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityClaimed",
            type: "uint256"
          }
        ],
        name: "TokensClaimed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "wallet",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        name: "WalletClaimCountUpdated",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burnFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint32",
            name: "pos",
            type: "uint32"
          }
        ],
        name: "checkpoints",
        outputs: [
          {
            components: [
              {
                internalType: "uint32",
                name: "fromBlock",
                type: "uint32"
              },
              {
                internalType: "uint224",
                name: "votes",
                type: "uint224"
              }
            ],
            internalType: "struct ERC20VotesUpgradeable.Checkpoint",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_proofs",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "_proofMaxQuantityPerTransaction",
            type: "uint256"
          }
        ],
        name: "claim",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "claimCondition",
        outputs: [
          {
            internalType: "uint256",
            name: "currentStartId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "subtractedValue",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          }
        ],
        name: "delegate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expiry",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "delegateBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "delegates",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getActiveClaimConditionId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          }
        ],
        name: "getClaimConditionById",
        outputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IDropClaimCondition.ClaimCondition",
            name: "condition",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          }
        ],
        name: "getClaimTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "lastClaimTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nextValidClaimTimestamp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getPastTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getPastVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getVotes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "maxTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "maxWalletClaimCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "numCheckpoints",
        outputs: [
          {
            internalType: "uint32",
            name: "",
            type: "uint32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IDropClaimCondition.ClaimCondition[]",
            name: "_phases",
            type: "tuple[]"
          },
          {
            internalType: "bool",
            name: "_resetClaimEligibility",
            type: "bool"
          }
        ],
        name: "setClaimConditions",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_maxTotalSupply",
            type: "uint256"
          }
        ],
        name: "setMaxTotalSupply",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_count",
            type: "uint256"
          }
        ],
        name: "setMaxWalletClaimCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_count",
            type: "uint256"
          }
        ],
        name: "setWalletClaimCount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "verifyMaxQuantityPerTransaction",
            type: "bool"
          }
        ],
        name: "verifyClaim",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_conditionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_proofs",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "_proofMaxQuantityPerTransaction",
            type: "uint256"
          }
        ],
        name: "verifyClaimMerkleProof",
        outputs: [
          {
            internalType: "bool",
            name: "validMerkleProof",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "merkleProofIndex",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "walletClaimCount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/SignatureDrop.json
var require_SignatureDrop = __commonJS({
  "abis/SignatureDrop.json"(exports, module) {
    module.exports = [
      {
        inputs: [],
        name: "ApprovalCallerNotOwnerNorApproved",
        type: "error"
      },
      {
        inputs: [],
        name: "ApprovalQueryForNonexistentToken",
        type: "error"
      },
      {
        inputs: [],
        name: "ApprovalToCurrentOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "ApproveToCaller",
        type: "error"
      },
      {
        inputs: [],
        name: "BalanceQueryForZeroAddress",
        type: "error"
      },
      {
        inputs: [],
        name: "MintToZeroAddress",
        type: "error"
      },
      {
        inputs: [],
        name: "MintZeroQuantity",
        type: "error"
      },
      {
        inputs: [],
        name: "OwnerQueryForNonexistentToken",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferCallerNotOwnerNorApproved",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferFromIncorrectOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferToNonERC721ReceiverImplementer",
        type: "error"
      },
      {
        inputs: [],
        name: "TransferToZeroAddress",
        type: "error"
      },
      {
        inputs: [],
        name: "URIQueryForNonexistentToken",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "approved",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            indexed: false,
            internalType: "struct IClaimCondition.ClaimCondition",
            name: "condition",
            type: "tuple"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "resetEligibility",
            type: "bool"
          }
        ],
        name: "ClaimConditionUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "prevURI",
            type: "string"
          },
          {
            indexed: false,
            internalType: "string",
            name: "newURI",
            type: "string"
          }
        ],
        name: "ContractURIUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "platformFeeRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "platformFeeBps",
            type: "uint256"
          }
        ],
        name: "PlatformFeeInfoUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "PrimarySaleRecipientUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "revealedURI",
            type: "string"
          }
        ],
        name: "TokenURIRevealed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "claimer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "startTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "quantityClaimed",
            type: "uint256"
          }
        ],
        name: "TokensClaimed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "startTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "endTokenId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "baseURI",
            type: "string"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "encryptedBaseURI",
            type: "bytes"
          }
        ],
        name: "TokensLazyMinted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "signer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "mintedTo",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdMinted",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct ISignatureMintERC721.MintRequest",
            name: "mintRequest",
            type: "tuple"
          }
        ],
        name: "TokensMintedWithSignature",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "bytes32[]",
                name: "proof",
                type: "bytes32[]"
              },
              {
                internalType: "uint256",
                name: "maxQuantityInAllowlist",
                type: "uint256"
              }
            ],
            internalType: "struct IDropSinglePhase.AllowlistProof",
            name: "_allowlistProof",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "claim",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "claimCondition",
        outputs: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "key",
            type: "bytes"
          }
        ],
        name: "encryptDecrypt",
        outputs: [
          {
            internalType: "bytes",
            name: "result",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "encryptedData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getBaseURICount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          }
        ],
        name: "getBatchIdAtIndex",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          }
        ],
        name: "getClaimTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "lastClaimedAt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nextValidClaimTimestamp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPlatformFeeInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_batchId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_key",
            type: "bytes"
          }
        ],
        name: "getRevealURI",
        outputs: [
          {
            internalType: "string",
            name: "revealedURI",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "member",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRoleWithSwitch",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "_royaltyBps",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "_platformFeeBps",
            type: "uint128"
          },
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_batchId",
            type: "uint256"
          }
        ],
        name: "isEncryptedBatch",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "_baseURIForTokens",
            type: "string"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "lazyMint",
        outputs: [
          {
            internalType: "uint256",
            name: "batchId",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ISignatureMintERC721.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "mintWithSignature",
        outputs: [
          {
            internalType: "address",
            name: "signer",
            type: "address"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "primarySaleRecipient",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_key",
            type: "bytes"
          }
        ],
        name: "reveal",
        outputs: [
          {
            internalType: "string",
            name: "revealedURI",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint256",
                name: "startTimestamp",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxClaimableSupply",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplyClaimed",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "quantityLimitPerTransaction",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "waitTimeInSecondsBetweenClaims",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "merkleRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              }
            ],
            internalType: "struct IClaimCondition.ClaimCondition",
            name: "_condition",
            type: "tuple"
          },
          {
            internalType: "bool",
            name: "_resetClaimEligibility",
            type: "bool"
          }
        ],
        name: "setClaimConditions",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_platformFeeRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_platformFeeBps",
            type: "uint256"
          }
        ],
        name: "setPlatformFeeInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_saleRecipient",
            type: "address"
          }
        ],
        name: "setPrimarySaleRecipient",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalMinted",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "address",
                name: "royaltyRecipient",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "royaltyBps",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "primarySaleRecipient",
                type: "address"
              },
              {
                internalType: "string",
                name: "uri",
                type: "string"
              },
              {
                internalType: "uint256",
                name: "quantity",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pricePerToken",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "currency",
                type: "address"
              },
              {
                internalType: "uint128",
                name: "validityStartTimestamp",
                type: "uint128"
              },
              {
                internalType: "uint128",
                name: "validityEndTimestamp",
                type: "uint128"
              },
              {
                internalType: "bytes32",
                name: "uid",
                type: "bytes32"
              }
            ],
            internalType: "struct ISignatureMintERC721.MintRequest",
            name: "_req",
            type: "tuple"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "verify",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "address",
            name: "signer",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_pricePerToken",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "verifyMaxQuantityPerTransaction",
            type: "bool"
          }
        ],
        name: "verifyClaim",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_claimer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_quantity",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "bytes32[]",
                name: "proof",
                type: "bytes32[]"
              },
              {
                internalType: "uint256",
                name: "maxQuantityInAllowlist",
                type: "uint256"
              }
            ],
            internalType: "struct IDropSinglePhase.AllowlistProof",
            name: "_allowlistProof",
            type: "tuple"
          }
        ],
        name: "verifyClaimMerkleProof",
        outputs: [
          {
            internalType: "bool",
            name: "validMerkleProof",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "merkleProofIndex",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// abis/Multiwrap.json
var require_Multiwrap = __commonJS({
  "abis/Multiwrap.json"(exports, module) {
    module.exports = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_nativeTokenWrapper",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "approved",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "prevURI",
            type: "string"
          },
          {
            indexed: false,
            internalType: "string",
            name: "newURI",
            type: "string"
          }
        ],
        name: "ContractURIUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "newRoyaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newRoyaltyBps",
            type: "uint256"
          }
        ],
        name: "DefaultRoyalty",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnerUpdated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
          }
        ],
        name: "RoleAdminChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleGranted",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "RoleRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          }
        ],
        name: "RoyaltyForToken",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "unwrapper",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "recipientOfWrappedContents",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdOfWrappedToken",
            type: "uint256"
          }
        ],
        name: "TokensUnwrapped",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "wrapper",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "recipientOfWrappedToken",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenIdOfWrappedToken",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            indexed: false,
            internalType: "struct ITokenBundle.Token[]",
            name: "wrappedContents",
            type: "tuple[]"
          }
        ],
        name: "TokensWrapped",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "NATIVE_TOKEN",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractType",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "contractURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "contractVersion",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDefaultRoyaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleAdmin",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getRoleMember",
        outputs: [
          {
            internalType: "address",
            name: "member",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          }
        ],
        name: "getRoleMemberCount",
        outputs: [
          {
            internalType: "uint256",
            name: "count",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getRoyaltyInfoForToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint16",
            name: "",
            type: "uint16"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_bundleId",
            type: "uint256"
          }
        ],
        name: "getTokenCountOfBundle",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_bundleId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "getTokenOfBundle",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_bundleId",
            type: "uint256"
          }
        ],
        name: "getUriOfBundle",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "getWrappedContents",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token[]",
            name: "contents",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRole",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "hasRoleWithSwitch",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_defaultAdmin",
            type: "address"
          },
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "string",
            name: "_contractURI",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "_trustedForwarders",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "forwarder",
            type: "address"
          }
        ],
        name: "isTrustedForwarder",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nextTokenIdToMint",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "salePrice",
            type: "uint256"
          }
        ],
        name: "royaltyInfo",
        outputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyAmount",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_uri",
            type: "string"
          }
        ],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_royaltyBps",
            type: "uint256"
          }
        ],
        name: "setDefaultRoyaltyInfo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newOwner",
            type: "address"
          }
        ],
        name: "setOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_bps",
            type: "uint256"
          }
        ],
        name: "setRoyaltyInfoForToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "unwrap",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "assetContract",
                type: "address"
              },
              {
                internalType: "enum ITokenBundle.TokenType",
                name: "tokenType",
                type: "uint8"
              },
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              }
            ],
            internalType: "struct ITokenBundle.Token[]",
            name: "_tokensToWrap",
            type: "tuple[]"
          },
          {
            internalType: "string",
            name: "_uriForWrappedToken",
            type: "string"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "wrap",
        outputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
  }
});

// src/index.ts
init_esm_shims();

// src/schema/contracts/common/index.ts
init_esm_shims();

// src/schema/shared.ts
init_esm_shims();

// src/common/utils.ts
init_esm_shims();
var isBrowser = /* @__PURE__ */ __name(() => typeof window !== "undefined", "isBrowser");
var isNode = /* @__PURE__ */ __name(() => !isBrowser(), "isNode");

// src/schema/shared.ts
var MAX_BPS = 1e4;
var fileOrBufferUnion = isBrowser() ? [
  z.instanceof(File),
  z.string()
] : [
  z.instanceof(Buffer),
  z.string()
];
var FileBufferOrStringSchema = z.union(fileOrBufferUnion);
var BytesLikeSchema = z.union([
  z.array(z.number()),
  z.string()
]);
var BigNumberSchema = z.union([
  z.string(),
  z.number(),
  z.bigint(),
  z.custom((data) => {
    return BigNumber.isBigNumber(data);
  })
]).transform((arg) => BigNumber.from(arg));
var BigNumberishSchema = BigNumberSchema.transform((arg) => arg.toString());
var BasisPointsSchema = z.number().max(MAX_BPS, "Cannot exeed 100%").min(0, "Cannot be below 0%");
var PercentSchema = z.number().max(100, "Cannot exeed 100%").min(0, "Cannot be below 0%");
var JsonLiteral = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.null()
]);
var JsonSchema = z.lazy(() => z.union([
  JsonLiteral,
  z.array(JsonSchema),
  z.record(JsonSchema)
]));
var JsonObjectSchema = z.record(JsonSchema);
var HexColor = z.union([
  z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform((val) => val.replace("#", "")),
  z.string().length(0)
]);
var AddressSchema = z.string().refine((arg) => utils.isAddress(arg), (out) => {
  return {
    message: `${out} is not a valid address`
  };
});
var PriceSchema = z.union([
  z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid price"),
  z.number().min(0, "Price cannot be negative")
]).transform((arg) => typeof arg === "number" ? arg.toString() : arg);
var RawDateSchema = z.date().transform((i) => {
  return BigNumber.from(Math.floor(i.getTime() / 1e3));
});
var StartDateSchema = RawDateSchema.default(new Date(0));
var EndDateSchema = RawDateSchema.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10));
var CallOverrideSchema = z.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: z.union([
    z.string(),
    z.number()
  ]).optional(),
  from: AddressSchema.optional(),
  type: z.number().optional()
}).strict();

// src/schema/contracts/common/claim-conditions.ts
init_esm_shims();

// src/constants/currency.ts
init_esm_shims();

// src/constants/chains.ts
init_esm_shims();
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Rinkeby"] = 4] = "Rinkeby";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
  ChainId2[ChainId2["Mumbai"] = 80001] = "Mumbai";
  ChainId2[ChainId2["Harmony"] = 16666e5] = "Harmony";
  ChainId2[ChainId2["Localhost"] = 1337] = "Localhost";
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Fantom"] = 250] = "Fantom";
  ChainId2[ChainId2["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId2[ChainId2["Avalanche"] = 43114] = "Avalanche";
  ChainId2[ChainId2["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId2[ChainId2["Optimism"] = 10] = "Optimism";
  ChainId2[ChainId2["OptimismTestnet"] = 69] = "OptimismTestnet";
  ChainId2[ChainId2["Arbitrum"] = 42161] = "Arbitrum";
  ChainId2[ChainId2["ArbitrumTestnet"] = 421611] = "ArbitrumTestnet";
})(ChainId || (ChainId = {}));
var SUPPORTED_CHAIN_IDS = [
  ChainId.Mainnet,
  ChainId.Rinkeby,
  ChainId.Goerli,
  ChainId.Polygon,
  ChainId.Mumbai,
  ChainId.Fantom,
  ChainId.FantomTestnet,
  ChainId.Avalanche,
  ChainId.AvalancheFujiTestnet,
  ChainId.Optimism,
  ChainId.OptimismTestnet,
  ChainId.Arbitrum,
  ChainId.ArbitrumTestnet
];

// src/constants/currency.ts
var NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Rinkeby]: {
    name: "Rinkeby Ether",
    symbol: "RIN",
    decimals: 18,
    wrapped: {
      address: "0xc778417E063141139Fce010982780140Aa0cD5Ab",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "G\xF6rli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0x0bb7509324ce409f7bbc4b701f932eaca9736ab7",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumTestnet]: {
    name: "Arbitrum Rinkeby Ether",
    symbol: "ARETH",
    decimals: 18,
    wrapped: {
      address: "0xEBbc3452Cc911591e4F18f3b36727Df45d6bd1f9",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismTestnet]: {
    name: "Kovan Ether",
    symbol: "KOR",
    decimals: 18,
    wrapped: {
      address: "0xbC6F6b680bc61e30dB47721c6D1c5cde19C1300d",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  }
};
function getNativeTokenByChainId(chainId) {
  return NATIVE_TOKENS[chainId];
}
__name(getNativeTokenByChainId, "getNativeTokenByChainId");

// src/schema/contracts/common/currency.ts
init_esm_shims();
var CurrencySchema = z.object({
  name: z.string(),
  symbol: z.string(),
  decimals: z.number()
});
var CurrencyValueSchema = CurrencySchema.extend({
  value: BigNumberSchema,
  displayValue: z.string()
});

// src/schema/contracts/common/snapshots.ts
init_esm_shims();
var MerkleSchema = z.object({
  merkle: z.record(z.string()).default({})
});
var SnapshotAddressInput = z.object({
  address: AddressSchema,
  maxClaimable: PriceSchema.default(0)
});
var SnapshotInputSchema = z.union([
  z.array(z.string()).transform((strings) => strings.map((address) => SnapshotAddressInput.parse({
    address
  }))),
  z.array(SnapshotAddressInput)
]);
var SnapshotSchema = z.object({
  merkleRoot: z.string(),
  claims: z.array(SnapshotAddressInput.extend({
    proof: z.array(z.string())
  }))
});
var SnapshotInfoSchema = z.object({
  merkleRoot: z.string(),
  snapshotUri: z.string(),
  snapshot: SnapshotSchema
});

// src/schema/contracts/common/claim-conditions.ts
var QuantitySchema = z.union([
  PriceSchema,
  z.literal("unlimited")
]).default("unlimited");
var ClaimConditionInputSchema = z.object({
  startTime: StartDateSchema,
  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),
  price: PriceSchema.default(0),
  maxQuantity: QuantitySchema,
  quantityLimitPerTransaction: QuantitySchema,
  waitInSeconds: BigNumberishSchema.default(0),
  merkleRootHash: BytesLikeSchema.default(utils.hexZeroPad([
    0
  ], 32)),
  snapshot: z.optional(SnapshotInputSchema)
});
var ClaimConditionInputArray = z.array(ClaimConditionInputSchema);
var PartialClaimConditionInputSchema = ClaimConditionInputSchema.partial();
var ClaimConditionOutputSchema = ClaimConditionInputSchema.extend({
  availableSupply: QuantitySchema,
  currentMintSupply: QuantitySchema,
  currencyMetadata: CurrencyValueSchema.default({
    value: BigNumber.from("0"),
    displayValue: "0",
    symbol: "",
    decimals: 18,
    name: ""
  }),
  price: BigNumberSchema,
  waitInSeconds: BigNumberSchema,
  startTime: BigNumberSchema.transform((n) => new Date(n.toNumber() * 1e3))
});

// src/schema/contracts/common/signature.ts
init_esm_shims();

// src/schema/tokens/common/index.ts
init_esm_shims();

// src/schema/tokens/common/properties.ts
init_esm_shims();
var OptionalPropertiesInput = z.union([
  z.array(JsonObjectSchema),
  JsonObjectSchema
]).optional();

// src/schema/tokens/common/index.ts
var CommonTokenInput = z.object({
  name: z.string().optional(),
  description: z.string().nullable().optional(),
  image: FileBufferOrStringSchema.nullable().optional(),
  external_url: FileBufferOrStringSchema.nullable().optional()
}).catchall(z.lazy(() => JsonSchema));
var CommonTokenOutput = CommonTokenInput.extend({
  id: BigNumberSchema,
  uri: z.string(),
  image: z.string().nullable().optional(),
  external_url: z.string().nullable().optional()
});
var CommonNFTInput = CommonTokenInput.extend({
  animation_url: FileBufferOrStringSchema.optional(),
  background_color: HexColor.optional(),
  properties: OptionalPropertiesInput,
  attributes: OptionalPropertiesInput
});
var NFTInputOrUriSchema = z.union([
  CommonNFTInput,
  z.string()
]);
var CommonNFTOutput = CommonTokenOutput.extend({
  animation_url: z.string().nullable().optional()
});

// src/common/signature-minting.ts
init_esm_shims();
function resolveOrGenerateId(requestUId) {
  if (requestUId === void 0) {
    const buffer = Buffer.alloc(16);
    v4({}, buffer);
    return utils.hexlify(utils.toUtf8Bytes(buffer.toString("hex")));
  } else {
    return utils.hexlify(requestUId);
  }
}
__name(resolveOrGenerateId, "resolveOrGenerateId");

// src/schema/contracts/common/signature.ts
var BaseSignaturePayloadInput = z.object({
  to: z.string().default(constants.AddressZero),
  price: PriceSchema.default(0),
  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),
  mintStartTime: StartDateSchema,
  mintEndTime: EndDateSchema,
  uid: z.string().optional().transform((arg) => resolveOrGenerateId(arg)),
  primarySaleRecipient: z.string().default(constants.AddressZero)
});
var Signature20PayloadInput = BaseSignaturePayloadInput.extend({
  quantity: PriceSchema
});
var Signature20PayloadOutput = Signature20PayloadInput.extend({
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
});
var Signature721PayloadInput = BaseSignaturePayloadInput.extend({
  metadata: NFTInputOrUriSchema,
  royaltyRecipient: z.string().default(constants.AddressZero),
  royaltyBps: BasisPointsSchema.default(0)
});
var Signature721PayloadOutput = Signature721PayloadInput.extend({
  uri: z.string(),
  royaltyBps: BigNumberSchema,
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
});
var Signature1155PayloadInput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberishSchema
});
var Signature1155PayloadInputWithTokenId = Signature1155PayloadInput.extend({
  tokenId: BigNumberishSchema
});
var Signature1155PayloadOutput = Signature721PayloadOutput.extend({
  tokenId: BigNumberSchema,
  quantity: BigNumberSchema
});
var Signature721WithQuantityInput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberSchema.default(1)
});
var Signature721WithQuantityOutput = Signature721PayloadOutput.extend({
  quantity: BigNumberSchema.default(1)
});
var MintRequest20 = [
  {
    name: "to",
    type: "address"
  },
  {
    name: "primarySaleRecipient",
    type: "address"
  },
  {
    name: "quantity",
    type: "uint256"
  },
  {
    name: "price",
    type: "uint256"
  },
  {
    name: "currency",
    type: "address"
  },
  {
    name: "validityStartTimestamp",
    type: "uint128"
  },
  {
    name: "validityEndTimestamp",
    type: "uint128"
  },
  {
    name: "uid",
    type: "bytes32"
  }
];
var MintRequest721 = [
  {
    name: "to",
    type: "address"
  },
  {
    name: "royaltyRecipient",
    type: "address"
  },
  {
    name: "royaltyBps",
    type: "uint256"
  },
  {
    name: "primarySaleRecipient",
    type: "address"
  },
  {
    name: "uri",
    type: "string"
  },
  {
    name: "price",
    type: "uint256"
  },
  {
    name: "currency",
    type: "address"
  },
  {
    name: "validityStartTimestamp",
    type: "uint128"
  },
  {
    name: "validityEndTimestamp",
    type: "uint128"
  },
  {
    name: "uid",
    type: "bytes32"
  }
];
var MintRequest1155 = [
  {
    name: "to",
    type: "address"
  },
  {
    name: "royaltyRecipient",
    type: "address"
  },
  {
    name: "royaltyBps",
    type: "uint256"
  },
  {
    name: "primarySaleRecipient",
    type: "address"
  },
  {
    name: "tokenId",
    type: "uint256"
  },
  {
    name: "uri",
    type: "string"
  },
  {
    name: "quantity",
    type: "uint256"
  },
  {
    name: "pricePerToken",
    type: "uint256"
  },
  {
    name: "currency",
    type: "address"
  },
  {
    name: "validityStartTimestamp",
    type: "uint128"
  },
  {
    name: "validityEndTimestamp",
    type: "uint128"
  },
  {
    name: "uid",
    type: "bytes32"
  }
];
var MintRequest721withQuantity = [
  {
    name: "to",
    type: "address"
  },
  {
    name: "royaltyRecipient",
    type: "address"
  },
  {
    name: "royaltyBps",
    type: "uint256"
  },
  {
    name: "primarySaleRecipient",
    type: "address"
  },
  {
    name: "uri",
    type: "string"
  },
  {
    name: "quantity",
    type: "uint256"
  },
  {
    name: "pricePerToken",
    type: "uint256"
  },
  {
    name: "currency",
    type: "address"
  },
  {
    name: "validityStartTimestamp",
    type: "uint128"
  },
  {
    name: "validityEndTimestamp",
    type: "uint128"
  },
  {
    name: "uid",
    type: "bytes32"
  }
];

// src/schema/contracts/common/index.ts
var CommonContractSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  image: FileBufferOrStringSchema.optional(),
  external_link: z.string().url().optional()
});
var CommonContractOutputSchema = CommonContractSchema.extend({
  image: z.string().optional()
}).catchall(z.lazy(() => JsonSchema));
var CommonRoyaltySchema = z.object({
  seller_fee_basis_points: BasisPointsSchema.default(0),
  fee_recipient: AddressSchema.default(constants.AddressZero)
});
var CommonPrimarySaleSchema = z.object({
  primary_sale_recipient: AddressSchema
});
var CommonPlatformFeeSchema = z.object({
  platform_fee_basis_points: BasisPointsSchema.default(0),
  platform_fee_recipient: AddressSchema.default(constants.AddressZero)
});
var CommonTrustedForwarderSchema = z.object({
  trusted_forwarders: z.array(AddressSchema).default([])
});
var CommonSymbolSchema = z.object({
  symbol: z.string().optional().default("")
});

// src/schema/tokens/token.ts
init_esm_shims();
var TokenMintInputSchema = z.object({
  toAddress: AddressSchema,
  amount: PriceSchema
});

// src/schema/tokens/edition.ts
init_esm_shims();
var EditionMetadataOutputSchema = z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
});
var EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
});
var EditionMetadataInputSchema = z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});
var EditionMetadataInputOrUriSchema = z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});

// src/schema/contracts/custom.ts
init_esm_shims();

// src/common/error.ts
init_esm_shims();

// src/constants/addresses.ts
init_esm_shims();
var OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";
var TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
var TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";
var ContractPublisher_address = "0x58c892e6bc196371f7fb425177b0E2aA906BC007";
var CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: constants.AddressZero
  },
  [ChainId.Rinkeby]: {
    biconomyForwarder: "0xFD4973FeB2031D4409fB57afEE5dF2051b171104",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Goerli]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: constants.AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: constants.AddressZero
  },
  [ChainId.FantomTestnet]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: constants.AddressZero
  },
  [ChainId.ArbitrumTestnet]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: "0xb0435b47ad26115A39c59735b814f3769F07C2c1",
    twRegistry: "0xcF4c511551aE4dab1F997866FC3900cd2aaeC40D",
    twBYOCRegistry: constants.AddressZero
  },
  [ChainId.Optimism]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: constants.AddressZero
  },
  [ChainId.OptimismTestnet]: {
    biconomyForwarder: constants.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: constants.AddressZero
  }
};
function getContractAddressByChainId(chainId, contractName) {
  if (chainId === ChainId.Hardhat) {
    if (contractName === "twFactory") {
      return process.env.factoryAddress;
    } else if (contractName === "twRegistry") {
      return process.env.registryAddress;
    } else {
      return constants.AddressZero;
    }
  }
  return CONTRACT_ADDRESSES[chainId][contractName];
}
__name(getContractAddressByChainId, "getContractAddressByChainId");
function getContractPublisherAddress() {
  if (process.env.contractPublisherAddress) {
    return process.env.contractPublisherAddress;
  } else {
    return ContractPublisher_address;
  }
}
__name(getContractPublisherAddress, "getContractPublisherAddress");

// src/constants/contract.ts
init_esm_shims();
var InterfaceId_IERC721 = utils.arrayify("0x80ac58cd");
var InterfaceId_IERC1155 = utils.arrayify("0xd9b67a26");

// src/constants/events.ts
init_esm_shims();
var EventType;
(function(EventType2) {
  EventType2["Transaction"] = "transaction";
  EventType2["Signature"] = "signature";
})(EventType || (EventType = {}));

// src/constants/urls.ts
init_esm_shims();
var DEFAULT_IPFS_GATEWAY = "https://gateway.ipfscdn.io/ipfs/";
var PUBLIC_GATEWAYS = [
  "https://gateway.ipfscdn.io/ipfs/",
  "https://cloudflare-ipfs.com/ipfs/",
  "https://ipfs.io/ipfs/"
];
var TW_IPFS_SERVER_URL = "https://upload.nftlabs.co";
var PINATA_IPFS_URL = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
var DEFAULT_API_KEY = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getProviderForNetwork(network) {
  if (typeof network !== "string") {
    return network;
  }
  switch (network) {
    case "mumbai":
      return `https://polygon-mumbai.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "rinkeby":
      return `https://eth-rinkeby.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "goerli":
      return `https://eth-goerli.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "polygon":
    case "matic":
      return `https://polygon-mainnet.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "mainnet":
    case "ethereum":
      return `https://eth-mainnet.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "optimism":
      return `https://opt-mainnet.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "optimism-testnet":
      return "https://kovan.optimism.io";
    case "arbitrum":
      return `https://arb-mainnet.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "arbitrum-testnet":
      return `https://arb-rinkeby.g.alchemy.com/v2/${DEFAULT_API_KEY}`;
    case "fantom":
      return "https://rpc.ftm.tools";
    case "fantom-testnet":
      return "https://rpc.testnet.fantom.network/";
    case "avalanche":
      return "https://api.avax.network/ext/bc/C/rpc";
    case "avalanche-testnet":
    case "avalanche-fuji":
      return "https://api.avax-test.network/ext/bc/C/rpc";
    default:
      if (network.startsWith("http") || network.startsWith("ws")) {
        return network;
      } else {
        throw new Error(`Unrecognized chain name or RPC url: ${network}`);
      }
  }
}
__name(getProviderForNetwork, "getProviderForNetwork");
function getReadOnlyProvider(network, chainId) {
  try {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new providers.JsonRpcBatchProvider(network, chainId);
        case "ws":
          return new providers.WebSocketProvider(network, chainId);
        default:
          return ethers.getDefaultProvider(network);
      }
    } else {
      return ethers.getDefaultProvider(network);
    }
  } catch (e) {
    return ethers.getDefaultProvider(network);
  }
}
__name(getReadOnlyProvider, "getReadOnlyProvider");

// src/common/error.ts
var NotFoundError = class extends Error {
  constructor(identifier) {
    super(identifier ? `Object with id ${identifier} NOT FOUND` : "NOT_FOUND");
  }
};
__name(NotFoundError, "NotFoundError");
var InvalidAddressError = class extends Error {
  constructor(address) {
    super(address ? `'${address}' is an invalid address` : "Invalid address passed");
  }
};
__name(InvalidAddressError, "InvalidAddressError");
var MissingRoleError = class extends Error {
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
};
__name(MissingRoleError, "MissingRoleError");
var AssetNotFoundError = class extends Error {
  constructor(message = "The asset you're trying to use could not be found.") {
    super(`message: ${message}`);
  }
};
__name(AssetNotFoundError, "AssetNotFoundError");
var UploadError = class extends Error {
  constructor(message) {
    super(`UPLOAD_FAILED: ${message}`);
  }
};
__name(UploadError, "UploadError");
var FileNameMissingError = class extends Error {
  constructor() {
    super("File name is required when object is not a `File` type object.");
  }
};
__name(FileNameMissingError, "FileNameMissingError");
var DuplicateFileNameError = class extends Error {
  constructor(fileName) {
    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);
  }
};
__name(DuplicateFileNameError, "DuplicateFileNameError");
var NotEnoughTokensError = class extends Error {
  constructor(contractAddress, quantity, available) {
    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);
  }
};
__name(NotEnoughTokensError, "NotEnoughTokensError");
var MissingOwnerRoleError = class extends Error {
  constructor() {
    super(`LIST ERROR: you should be the owner of the token to list it.`);
  }
};
__name(MissingOwnerRoleError, "MissingOwnerRoleError");
var QuantityAboveLimitError = class extends Error {
  constructor(quantity) {
    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);
  }
};
__name(QuantityAboveLimitError, "QuantityAboveLimitError");
var FetchError = class extends Error {
  constructor(message, innerError) {
    super(`FETCH_FAILED: ${message}`);
    this.innerError = innerError;
  }
};
__name(FetchError, "FetchError");
var DuplicateLeafsError = class extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
};
__name(DuplicateLeafsError, "DuplicateLeafsError");
var AuctionAlreadyStartedError = class extends Error {
  constructor(id) {
    super(`Auction already started with existing bid${id ? `, id: ${id}` : ""}`);
  }
};
__name(AuctionAlreadyStartedError, "AuctionAlreadyStartedError");
var FunctionDeprecatedError = class extends Error {
  constructor(message) {
    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : ""}`);
  }
};
__name(FunctionDeprecatedError, "FunctionDeprecatedError");
var ListingNotFoundError = class extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
};
__name(ListingNotFoundError, "ListingNotFoundError");
var WrongListingTypeError = class extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
};
__name(WrongListingTypeError, "WrongListingTypeError");
var RestrictedTransferError = class extends Error {
  constructor(assetAddress) {
    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : ""}`);
  }
};
__name(RestrictedTransferError, "RestrictedTransferError");
var AdminRoleMissingError = class extends Error {
  constructor(address, contractAddress, message = "Failed to execute transaction") {
    super(`${message}, admin role is missing${address ? ` on address: ${address}` : ""}${contractAddress ? ` on contract: ${contractAddress}` : ""}`);
  }
};
__name(AdminRoleMissingError, "AdminRoleMissingError");
var AuctionHasNotEndedError = class extends Error {
  constructor(id, endTime) {
    super(`Auction has not ended yet${id ? `, id: ${id}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
};
__name(AuctionHasNotEndedError, "AuctionHasNotEndedError");
var TransactionError = class extends Error {
  constructor(reason, from, to, data, network, rpcUrl, raw, functionInfo) {
    var _a3;
    let builtErrorMsg = "Contract transaction failed\n\n";
    builtErrorMsg += `Message: ${reason}`;
    builtErrorMsg += "\n\n| Transaction info |\n";
    builtErrorMsg += withSpaces("from", from);
    builtErrorMsg += withSpaces("to", to);
    builtErrorMsg += withSpaces(`chain`, `${network.name} (${network.chainId})`);
    if (functionInfo) {
      builtErrorMsg += "\n\n| Failed contract call info |\n";
      builtErrorMsg += withSpaces("function", functionInfo.signature);
      builtErrorMsg += withSpaces(`arguments`, JSON.stringify(functionInfo.inputs, null, 2));
      if (functionInfo.value.gt(0)) {
        builtErrorMsg += withSpaces("value", `${ethers.utils.formatEther(functionInfo.value)} ${(_a3 = NATIVE_TOKENS[network.chainId]) == null ? void 0 : _a3.symbol}`);
      }
    }
    try {
      const url = new URL(rpcUrl);
      builtErrorMsg += withSpaces(`RPC`, url.hostname);
    } catch (e2) {
    }
    builtErrorMsg += "\n\n";
    builtErrorMsg += "Need help with this error? Join our community: https://discord.gg/thirdweb";
    builtErrorMsg += "\n\n\n\n";
    builtErrorMsg += "| Raw error |";
    builtErrorMsg += "\n\n";
    builtErrorMsg += raw;
    super(builtErrorMsg);
    this.reason = reason;
    this.from = from;
    this.to = to;
    this.data = data;
    this.chain = network;
    this.rpcUrl = rpcUrl;
    this.functionInfo = functionInfo;
  }
};
__name(TransactionError, "TransactionError");
function parseFunctionInfo(data, contractInterface) {
  try {
    const fnFragment = contractInterface.parseTransaction({
      data
    });
    const results = {};
    const args = fnFragment.args;
    fnFragment.functionFragment.inputs.forEach((param, index) => {
      if (Array.isArray(args[index])) {
        const obj = {};
        const components = param.components;
        if (components) {
          const arr = args[index];
          for (let i = 0; i < components.length; i++) {
            const name = components[i].name;
            obj[name] = arr[i];
          }
          results[param.name] = obj;
        }
      } else {
        results[param.name] = args[index];
      }
    });
    return {
      signature: fnFragment.signature,
      inputs: results,
      value: fnFragment.value
    };
  } catch (e) {
    return void 0;
  }
}
__name(parseFunctionInfo, "parseFunctionInfo");
async function convertToTWError(error, network, signerAddress, contractAddress, contractInterface) {
  let raw;
  if (error.data) {
    raw = JSON.stringify(error.data);
  } else if (error instanceof Error) {
    raw = error.message;
  } else {
    raw = error.toString();
  }
  const reason = error.reason || parseMessageParts(/.*?"message[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  const data = parseMessageParts(/.*?"data[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  const rpcUrl = parseMessageParts(/.*?"url[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  let from = parseMessageParts(/.*?"from[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  let to = parseMessageParts(/.*?"to[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  if (to === "") {
    to = contractAddress;
  }
  if (from === "") {
    from = signerAddress;
  }
  const functionInfo = data.length > 0 ? parseFunctionInfo(data, contractInterface) : void 0;
  return new TransactionError(reason, from, to, data, network, rpcUrl, raw, functionInfo);
}
__name(convertToTWError, "convertToTWError");
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  return `
${label}:${spaces}${content}`;
}
__name(withSpaces, "withSpaces");
function parseMessageParts(regex, raw) {
  const msgMatches = raw.match(regex) || [];
  let extracted = "";
  if ((msgMatches == null ? void 0 : msgMatches.length) > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}
__name(parseMessageParts, "parseMessageParts");
function includesErrorMessage(err, message) {
  return err && err.toString().includes(message) || err.message && err.message.toString().includes(message) || err.error && err.error.toString().includes(message);
}
__name(includesErrorMessage, "includesErrorMessage");

// src/common/snapshots.ts
init_esm_shims();
var import_merkletreejs = __toESM(require_dist());
async function createSnapshot(snapshotInput, tokenDecimals, storage) {
  const input = SnapshotInputSchema.parse(snapshotInput);
  const addresses = input.map((i) => i.address);
  const hasDuplicates = new Set(addresses).size < addresses.length;
  if (hasDuplicates) {
    throw new DuplicateLeafsError();
  }
  const hashedLeafs = input.map((i) => hashLeafNode(i.address, utils.parseUnits(i.maxClaimable, tokenDecimals)));
  const tree = new import_merkletreejs.default(hashedLeafs, utils.keccak256, {
    sort: true
  });
  const snapshot = SnapshotSchema.parse({
    merkleRoot: tree.getHexRoot(),
    claims: input.map((i, index) => {
      const proof = tree.getHexProof(hashedLeafs[index]);
      return {
        address: i.address,
        maxClaimable: i.maxClaimable,
        proof
      };
    })
  });
  const uri = await storage.uploadMetadata(snapshot);
  return {
    merkleRoot: tree.getHexRoot(),
    snapshotUri: uri,
    snapshot
  };
}
__name(createSnapshot, "createSnapshot");
function hashLeafNode(address, maxClaimableAmount) {
  return utils.solidityKeccak256([
    "address",
    "uint256"
  ], [
    address,
    BigNumber.from(maxClaimableAmount)
  ]);
}
__name(hashLeafNode, "hashLeafNode");

// src/common/role.ts
init_esm_shims();
var roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE"
};
var ALL_ROLES = Object.keys(roleMap);
function getRoleHash(role) {
  if (role === "admin") {
    return ethers.utils.hexZeroPad([
      0
    ], 32);
  }
  return ethers.utils.id(roleMap[role]);
}
__name(getRoleHash, "getRoleHash");

// src/common/feature-detection.ts
init_esm_shims();

// src/constants/contract-features.ts
init_esm_shims();

// src/constants/erc721-features.ts
init_esm_shims();

// abis/IERC721.json
var IERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IERC721Enumerable.json
var IERC721Enumerable_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenOfOwnerByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IERC721Supply.json
var IERC721Supply_default = [
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IMintableERC721.json
var IMintableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IMulticall.json
var IMulticall_default = [
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/DelayedReveal.json
var DelayedReveal_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "encryptedData",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_batchId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_key",
        type: "bytes"
      }
    ],
    name: "getRevealURI",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_batchId",
        type: "uint256"
      }
    ],
    name: "isEncryptedBatch",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/ILazyMint.json
var ILazyMint_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "extraData",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IDropSinglePhase.json
var IDropSinglePhase_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/SignatureMintERC721.json
var SignatureMintERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IBurnableERC721.json
var IBurnableERC721_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/constants/erc721-features.ts
var FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "IBurnableERC721"
  },
  abis: [
    IERC721_default,
    IBurnableERC721_default
  ],
  features: {}
};
var FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "DelayedReveal"
  },
  abis: [
    IERC721_default,
    ILazyMint_default,
    DelayedReveal_default
  ],
  features: {}
};
var FEATURE_NFT_CLAIMABLE = {
  name: "ERC721Claimable",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "DropSinglePhase"
  },
  abis: [
    IERC721_default,
    ILazyMint_default,
    IDropSinglePhase_default
  ],
  features: {}
};
var FEATURE_NFT_DROPPABLE = {
  name: "ERC721Droppable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721droppable",
    contracts: "LazyMint"
  },
  abis: [
    IERC721_default,
    ILazyMint_default
  ],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE,
    [FEATURE_NFT_CLAIMABLE.name]: FEATURE_NFT_CLAIMABLE
  }
};
var FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "IMulticall"
  },
  abis: [
    IERC721_default,
    IMintableERC721_default,
    IMulticall_default
  ],
  features: {}
};
var FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "IMintableERC721"
  },
  abis: [
    IERC721_default,
    IMintableERC721_default
  ],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
var FEATURE_NFT_SIGNATURE_MINTABLE = {
  name: "ERC721SignatureMint",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "ISignatureMintERC721"
  },
  abis: [
    IERC721_default,
    SignatureMintERC721_default
  ],
  features: {}
};
var FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "IERC721Enumerable"
  },
  abis: [
    IERC721_default,
    IERC721Enumerable_default
  ],
  features: {}
};
var FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "IERC721Supply"
  },
  abis: [
    IERC721_default,
    IERC721Supply_default
  ],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE
  }
};
var FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "IERC721"
  },
  abis: [
    IERC721_default
  ],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_DROPPABLE.name]: FEATURE_NFT_DROPPABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE.name]: FEATURE_NFT_SIGNATURE_MINTABLE
  }
};

// src/constants/erc20-features.ts
init_esm_shims();

// abis/IERC20.json
var IERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "who",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IMintableERC20.json
var IMintableERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/ISignatureMintERC20.json
var ISignatureMintERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IBurnableERC20.json
var IBurnableERC20_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burnFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/constants/erc20-features.ts
var FEATURE_TOKEN_DROPPABLE = {
  name: "ERC20Droppable",
  namespace: "token.drop",
  docLinks: {
    sdk: "sdk.erc20droppable",
    contracts: "DropSinglePhase"
  },
  abis: [
    IERC20_default,
    IDropSinglePhase_default
  ],
  features: {}
};
var FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "IBurnableERC20"
  },
  abis: [
    IERC20_default,
    IBurnableERC20_default
  ],
  features: {}
};
var FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "ISignatureMintERC20"
  },
  abis: [
    IERC20_default,
    ISignatureMintERC20_default
  ],
  features: {}
};
var FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "IMulticall"
  },
  abis: [
    IERC20_default,
    IMintableERC20_default,
    IMulticall_default
  ],
  features: {}
};
var FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "IMintableERC20"
  },
  abis: [
    IERC20_default,
    IMintableERC20_default
  ],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
var FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "IERC20"
  },
  abis: [
    IERC20_default
  ],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_DROPPABLE.name]: FEATURE_TOKEN_DROPPABLE,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE
  }
};

// src/constants/erc1155-features.ts
init_esm_shims();

// abis/IERC1155Enumerable.json
var IERC1155Enumerable_default = [
  {
    inputs: [],
    name: "nextTokenIdToMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IERC1155.json
var IERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "_value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_owners",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IMintableERC1155.json
var IMintableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/ISignatureMintERC1155.json
var ISignatureMintERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IBurnableERC1155.json
var IBurnableERC1155_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "burnBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/DropSinglePhase1155.json
var DropSinglePhase1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase1155.AllowlistProof",
        name: "_allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "claimCondition",
    outputs: [
      {
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxClaimableSupply",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "supplyClaimed",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantityLimitPerTransaction",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "waitTimeInSecondsBetweenClaims",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "merkleRoot",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      }
    ],
    name: "getClaimTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "lastClaimedAt",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "nextValidClaimTimestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "_condition",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "_resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "verifyMaxQuantityPerTransaction",
        type: "bool"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase1155.AllowlistProof",
        name: "_allowlistProof",
        type: "tuple"
      }
    ],
    name: "verifyClaimMerkleProof",
    outputs: [
      {
        internalType: "bool",
        name: "validMerkleProof",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "merkleProofIndex",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/constants/erc1155-features.ts
var FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "IBurnableERC1155"
  },
  abis: [
    IERC1155_default,
    IBurnableERC1155_default
  ],
  features: {}
};
var FEATURE_EDITION_CLAIMABLE = {
  name: "ERC1155Claimable",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: ""
  },
  abis: [
    IERC1155_default,
    ILazyMint_default,
    DropSinglePhase1155_default
  ],
  features: {}
};
var FEATURE_EDITION_DROPPABLE = {
  name: "ERC1155Droppable",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "LazyMint"
  },
  abis: [
    IERC1155_default,
    ILazyMint_default
  ],
  features: {
    [FEATURE_EDITION_CLAIMABLE.name]: FEATURE_EDITION_CLAIMABLE
  }
};
var FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "DelayedReveal"
  },
  abis: [
    IERC1155_default,
    ILazyMint_default,
    DelayedReveal_default
  ],
  features: {}
};
var FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "ISignatureMintERC1155"
  },
  abis: [
    IERC1155_default,
    ISignatureMintERC1155_default
  ],
  features: {}
};
var FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "IMulticall"
  },
  abis: [
    IERC1155_default,
    IMintableERC1155_default,
    IMulticall_default
  ],
  features: {}
};
var FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "IMintableERC1155"
  },
  abis: [
    IERC1155_default,
    IMintableERC1155_default
  ],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
var FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "IERC1155"
  },
  abis: [
    IERC1155_default,
    IERC1155Enumerable_default
  ],
  features: {}
};
var FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "IERC1155Enumerable"
  },
  abis: [
    IERC1155_default
  ],
  features: {
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_DROPPABLE.name]: FEATURE_EDITION_DROPPABLE,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE
  }
};

// src/constants/thirdweb-features.ts
init_esm_shims();

// abis/IPrimarySale.json
var IPrimarySale_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "PrimarySaleRecipientUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "primarySaleRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_saleRecipient",
        type: "address"
      }
    ],
    name: "setPrimarySaleRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IPlatformFee.json
var IPlatformFee_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "platformFeeBps",
        type: "uint256"
      }
    ],
    name: "PlatformFeeInfoUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getPlatformFeeInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_platformFeeRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_platformFeeBps",
        type: "uint256"
      }
    ],
    name: "setPlatformFeeInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IRoyalty.json
var IRoyalty_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRoyaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRoyaltyBps",
        type: "uint256"
      }
    ],
    name: "DefaultRoyalty",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "royaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "royaltyBps",
        type: "uint256"
      }
    ],
    name: "RoyaltyForToken",
    type: "event"
  },
  {
    inputs: [],
    name: "getDefaultRoyaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getRoyaltyInfoForToken",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salePrice",
        type: "uint256"
      }
    ],
    name: "royaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "royaltyAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_royaltyRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_royaltyBps",
        type: "uint256"
      }
    ],
    name: "setDefaultRoyaltyInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bps",
        type: "uint256"
      }
    ],
    name: "setRoyaltyInfoForToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IPermissionsEnumerable.json
var IPermissionsEnumerable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// abis/IContractMetadata.json
var IContractMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/constants/thirdweb-features.ts
var FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "Royalty"
  },
  abis: [
    IRoyalty_default
  ],
  features: {}
};
var FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "PrimarySale"
  },
  abis: [
    IPrimarySale_default
  ],
  features: {}
};
var FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFee",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "PlatformFee"
  },
  abis: [
    IPlatformFee_default
  ],
  features: {}
};
var FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "PermissionsEnumerable"
  },
  abis: [
    IPermissionsEnumerable_default
  ],
  features: {}
};
var FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "ContractMetadata"
  },
  abis: [
    IContractMetadata_default
  ],
  features: {}
};

// src/constants/contract-features.ts
var SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA
};
function matchesAbiInterface(abi, feature) {
  const contractFn = [
    ...new Set(extractFunctionsFromAbi(abi).map((f) => f.name))
  ];
  const interfaceFn = [
    ...new Set(feature.abis.flatMap((i) => extractFunctionsFromAbi(i)).map((f) => f.name))
  ];
  return contractFn.filter((k) => interfaceFn.includes(k)).length === interfaceFn.length;
}
__name(matchesAbiInterface, "matchesAbiInterface");
async function extractConstructorParams(predeployMetadataUri, storage) {
  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractConstructorParamsFromAbi(meta.abi);
}
__name(extractConstructorParams, "extractConstructorParams");
async function extractFunctions(predeployMetadataUri, storage) {
  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);
}
__name(extractFunctions, "extractFunctions");
function extractCommentFromMetadata(name, metadata, type) {
  var _a3, _b2, _c2, _d, _e, _f, _g, _h, _i, _j;
  return ((_e = (_d = (_b2 = (_a3 = metadata == null ? void 0 : metadata.output) == null ? void 0 : _a3.userdoc) == null ? void 0 : _b2[type]) == null ? void 0 : _d[Object.keys(((_c2 = metadata == null ? void 0 : metadata.output) == null ? void 0 : _c2.userdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _e.notice) || ((_j = (_i = (_g = (_f = metadata == null ? void 0 : metadata.output) == null ? void 0 : _f.devdoc) == null ? void 0 : _g[type]) == null ? void 0 : _i[Object.keys(((_h = metadata == null ? void 0 : metadata.output) == null ? void 0 : _h.devdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _j.details);
}
__name(extractCommentFromMetadata, "extractCommentFromMetadata");
function extractConstructorParamsFromAbi(abi) {
  for (const input of abi) {
    if (input.type === "constructor") {
      return input.inputs ?? [];
    }
  }
  return [];
}
__name(extractConstructorParamsFromAbi, "extractConstructorParamsFromAbi");
function extractFunctionParamsFromAbi(abi, functionName) {
  for (const input of abi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs ?? [];
    }
  }
  return [];
}
__name(extractFunctionParamsFromAbi, "extractFunctionParamsFromAbi");
function extractFunctionsFromAbi(abi, metadata) {
  var _a3, _b2, _c2, _d;
  const functions = abi.filter((el) => el.type === "function");
  const parsed = [];
  for (const f of functions) {
    const doc = extractCommentFromMetadata(f.name, metadata, "methods");
    const args = ((_b2 = (_a3 = f.inputs) == null ? void 0 : _a3.map((i) => `${i.name || "key"}: ${toJSType(i)}`)) == null ? void 0 : _b2.join(", ")) || "";
    const fargs = args ? `, ${args}` : "";
    const out = (_d = (_c2 = f.outputs) == null ? void 0 : _c2.map((o) => toJSType(o, true))) == null ? void 0 : _d.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature = `contract.call("${f.name}"${fargs})${promise}`;
    parsed.push({
      inputs: f.inputs ?? [],
      outputs: f.outputs ?? [],
      name: f.name ?? "unknown",
      signature,
      stateMutability: f.stateMutability ?? "",
      comment: doc
    });
  }
  return parsed;
}
__name(extractFunctionsFromAbi, "extractFunctionsFromAbi");
function extractEventsFromAbi(abi, metadata) {
  const events = abi.filter((el) => el.type === "event");
  const parsed = [];
  for (const e of events) {
    const doc = extractCommentFromMetadata(e.name, metadata, "events");
    parsed.push({
      inputs: e.inputs ?? [],
      outputs: e.outputs ?? [],
      name: e.name ?? "unknown",
      comment: doc
    });
  }
  return parsed;
}
__name(extractEventsFromAbi, "extractEventsFromAbi");
function toJSType(contractType, isReturnType = false, withName = false) {
  let jsType = contractType.type;
  let isArray = false;
  if (jsType.endsWith("[]")) {
    isArray = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType.components) {
      jsType = `{ ${contractType.components.map((a) => toJSType(a, false, true)).join(", ")} }`;
    }
  }
  if (isArray) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType.name}: ${jsType}`;
  }
  return jsType;
}
__name(toJSType, "toJSType");
async function resolveContractUriFromAddress(address, provider) {
  const bytecode = await provider.getCode(address);
  if (bytecode === "0x") {
    const chain = await provider.getNetwork();
    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
  }
  if (bytecode.startsWith("0x363d3d373d3d3d363d")) {
    const implementationAddress = bytecode.slice(22, 62);
    return resolveContractUriFromAddress(`0x${implementationAddress}`, provider);
  }
  return extractIPFSHashFromBytecode(bytecode);
}
__name(resolveContractUriFromAddress, "resolveContractUriFromAddress");
function extractIPFSHashFromBytecode(bytecode) {
  const numericBytecode = hexToBytes(bytecode);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 256 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Buffer.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decodeFirstSync(bytecodeBuffer);
  if (cborData["ipfs"]) {
    return `ipfs://${toB58String(cborData["ipfs"])}`;
  }
  return void 0;
}
__name(extractIPFSHashFromBytecode, "extractIPFSHashFromBytecode");
function hexToBytes(hex) {
  hex = hex.toString(16);
  if (!hex.startsWith("0x")) {
    hex = `0x${hex}`;
  }
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }
  hex = hex.replace(/^0x/i, "");
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.slice(c, c + 2), 16));
  }
  return bytes;
}
__name(hexToBytes, "hexToBytes");
function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());
}
__name(isHexStrict, "isHexStrict");
async function fetchContractMetadataFromAddress(address, provider, storage) {
  const compilerMetadataUri = await resolveContractUriFromAddress(address, provider);
  if (!compilerMetadataUri) {
    throw new Error(`Could not resolve metadata for contract at ${address}`);
  }
  return await fetchContractMetadata(compilerMetadataUri, storage);
}
__name(fetchContractMetadataFromAddress, "fetchContractMetadataFromAddress");
async function fetchContractMetadata(compilerMetadataUri, storage) {
  const metadata = await storage.get(compilerMetadataUri);
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [
    ...new Set(Object.entries(metadata.sources).map(([_, src]) => src.license))
  ];
  return {
    name,
    abi,
    metadata,
    info,
    licenses
  };
}
__name(fetchContractMetadata, "fetchContractMetadata");
async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async ([path, info]) => {
    const urls = info.urls;
    const ipfsLink = urls.find((url) => url.includes("ipfs"));
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 5e3));
      const source = await Promise.race([
        storage.getRaw(`ipfs://${ipfsHash}`),
        timeout
      ]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: "Could not find source for this contract"
      };
    }
  }));
}
__name(fetchSourceFilesFromMetadata, "fetchSourceFilesFromMetadata");
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await storage.getRaw(publishMetadataUri)));
}
__name(fetchRawPredeployMetadata, "fetchRawPredeployMetadata");
async function fetchPreDeployMetadata(publishMetadataUri, storage) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  const deployBytecode = await storage.getRaw(rawMeta.bytecodeUri);
  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);
  return PreDeployMetadataFetchedSchema.parse(__spreadProps(__spreadValues(__spreadValues({}, rawMeta), parsedMeta), {
    bytecode: deployBytecode
  }));
}
__name(fetchPreDeployMetadata, "fetchPreDeployMetadata");
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await storage.getRaw(publishMetadataUri);
  return FullPublishMetadataSchema.parse(JSON.parse(meta));
}
__name(fetchExtendedReleaseMetadata, "fetchExtendedReleaseMetadata");
function detectFeatures(abi, features = SUPPORTED_FEATURES) {
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeatures(abi, feature.features);
    results[featureKey] = __spreadProps(__spreadValues({}, feature), {
      features: childResults,
      enabled
    });
  }
  return results;
}
__name(detectFeatures, "detectFeatures");
function isFeatureEnabled(abi, featureName) {
  const features = detectFeatures(abi);
  return _featureEnabled(features, featureName);
}
__name(isFeatureEnabled, "isFeatureEnabled");
function detectContractFeature(contractWrapper, featureName) {
  return isFeatureEnabled(AbiSchema.parse(contractWrapper.abi), featureName);
}
__name(detectContractFeature, "detectContractFeature");
function _featureEnabled(features, featureName) {
  const keys = Object.keys(features);
  if (!keys.includes(featureName)) {
    let found = false;
    for (const key of keys) {
      const f = features[key];
      found = _featureEnabled(f.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}
__name(_featureEnabled, "_featureEnabled");
function hasFunction(functionName, contractWrapper) {
  return functionName in contractWrapper.readContract.functions;
}
__name(hasFunction, "hasFunction");

// src/common/version-checker.ts
init_esm_shims();
var MAX_LENGTH = 256;
var NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
var MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
var REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);
function toSemver(version) {
  if (version.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version.trim().match(REGEX_MAIN_VERSION);
  if (!matches || (matches == null ? void 0 : matches.length) !== 4) {
    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [
    major,
    minor,
    patch
  ].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}
__name(toSemver, "toSemver");
function isIncrementalVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}
__name(isIncrementalVersion, "isIncrementalVersion");

// src/schema/contracts/custom.ts
var BYOCContractMetadataSchema = CommonContractSchema.catchall(z.lazy(() => JsonSchema));
var CustomContractInput = BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());
var CustomContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());
var CustomContractDeploy = CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial());
var CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};
var AbiTypeBaseSchema = z.object({
  type: z.string(),
  name: z.string()
}).catchall(z.any());
var AbiTypeSchema = AbiTypeBaseSchema.extend({
  stateMutability: z.string().optional(),
  components: z.array(AbiTypeBaseSchema).optional()
}).catchall(z.any());
var AbiObjectSchema = z.object({
  type: z.string(),
  name: z.string().default(""),
  inputs: z.array(AbiTypeSchema).default([]),
  outputs: z.array(AbiTypeSchema).default([])
}).catchall(z.any());
var AbiSchema = z.array(AbiObjectSchema);
var PreDeployMetadata = z.object({
  name: z.string(),
  metadataUri: z.string(),
  bytecodeUri: z.string(),
  analytics: z.any().optional()
}).catchall(z.any());
var ChainIdToAddressSchema = z.record(z.string(), z.string());
var FactoryDeploymentSchema = z.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: z.string().default("initialize"),
  factoryAddresses: ChainIdToAddressSchema.default({
    [ChainId.Mainnet]: CONTRACT_ADDRESSES[ChainId.Mainnet].twFactory,
    [ChainId.Goerli]: CONTRACT_ADDRESSES[ChainId.Goerli].twFactory,
    [ChainId.Rinkeby]: CONTRACT_ADDRESSES[ChainId.Rinkeby].twFactory,
    [ChainId.Polygon]: CONTRACT_ADDRESSES[ChainId.Polygon].twFactory,
    [ChainId.Mumbai]: CONTRACT_ADDRESSES[ChainId.Mumbai].twFactory,
    [ChainId.Fantom]: CONTRACT_ADDRESSES[ChainId.Fantom].twFactory,
    [ChainId.FantomTestnet]: CONTRACT_ADDRESSES[ChainId.FantomTestnet].twFactory,
    [ChainId.Optimism]: CONTRACT_ADDRESSES[ChainId.Optimism].twFactory,
    [ChainId.OptimismTestnet]: CONTRACT_ADDRESSES[ChainId.OptimismTestnet].twFactory,
    [ChainId.Arbitrum]: CONTRACT_ADDRESSES[ChainId.Arbitrum].twFactory,
    [ChainId.ArbitrumTestnet]: CONTRACT_ADDRESSES[ChainId.ArbitrumTestnet].twFactory
  })
});
var ExtraPublishMetadataSchema = z.object({
  version: z.string().refine((v) => {
    try {
      toSemver(v);
      return true;
    } catch (e) {
      return false;
    }
  }, (out) => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: z.string().optional(),
  description: z.string().optional(),
  readme: z.string().optional(),
  license: z.string().optional(),
  changelog: z.string().optional(),
  tags: z.array(z.string()).optional(),
  logo: FileBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: z.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.partial().optional()
}).catchall(z.any());
var FullPublishMetadataSchema = PreDeployMetadata.merge(ExtraPublishMetadataSchema).extend({
  publisher: AddressSchema.optional()
});
var ProfileSchemaInput = z.object({
  name: z.string().optional(),
  bio: z.string().optional(),
  avatar: FileBufferOrStringSchema.nullable().optional(),
  website: z.string().optional(),
  twitter: z.string().optional(),
  telegram: z.string().optional(),
  facebook: z.string().optional(),
  github: z.string().optional(),
  medium: z.string().optional(),
  linkedin: z.string().optional(),
  reddit: z.string().optional(),
  discord: z.string().optional()
});
var ProfileSchemaOutput = ProfileSchemaInput.extend({
  avatar: z.string().nullable().optional()
});
var PublishedContractSchema = z.object({
  id: z.string(),
  timestamp: BigNumberishSchema,
  metadataUri: z.string()
});
var ContractInfoSchema = z.object({
  title: z.string().optional(),
  author: z.string().optional(),
  details: z.string().optional(),
  notice: z.string().optional()
});
var CompilerMetadataFetchedSchema = z.object({
  name: z.string(),
  abi: AbiSchema,
  metadata: z.record(z.string(), z.any()),
  info: ContractInfoSchema,
  licenses: z.array(z.string().optional()).default([]).transform((v) => {
    return v.filter((license) => license !== void 0);
  })
});
var PreDeployMetadataFetchedSchema = PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: z.string()
});

// src/core/auth/wallet-authenticator.ts
init_esm_shims();

// src/schema/auth.ts
init_esm_shims();
var LoginOptionsSchema = z.object({
  nonce: z.string().optional(),
  expirationTime: z.date().optional(),
  chainId: z.number().optional()
}).optional();
var LoginPayloadDataSchema = z.object({
  domain: z.string(),
  address: AddressSchema,
  nonce: z.string().default(v4()),
  expiration_time: z.date().transform((d) => d.toISOString()),
  chain_id: z.number().optional()
});
z.object({
  payload: LoginPayloadDataSchema,
  signature: z.string()
});
var VerifyOptionsSchema = z.object({
  chainId: z.number().optional()
}).optional();
var AuthenticationOptionsSchema = z.object({
  invalidBefore: z.date().optional(),
  expirationTime: z.date().optional()
}).optional();
var AuthenticationPayloadDataSchema = z.object({
  iss: z.string(),
  sub: z.string(),
  aud: z.string(),
  exp: RawDateSchema.transform((b) => b.toNumber()),
  nbf: RawDateSchema.transform((b) => b.toNumber()),
  iat: RawDateSchema.transform((b) => b.toNumber()),
  jti: z.string().default(v4())
});
z.object({
  payload: AuthenticationPayloadDataSchema,
  signature: z.string()
});

// src/core/classes/rpc-connection-handler.ts
init_esm_shims();

// src/schema/sdk-options.ts
init_esm_shims();
var SDKOptionsSchema = z.object({
  readonlySettings: z.object({
    rpcUrl: z.string().url(),
    chainId: z.number().optional()
  }).optional(),
  gasSettings: z.object({
    maxPriceInGwei: z.number().min(1, "gas price cannot be less than 1").default(300),
    speed: z.enum([
      "standard",
      "fast",
      "fastest"
    ]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: z.union([
    z.object({
      openzeppelin: z.object({
        relayerUrl: z.string().url(),
        relayerForwarderAddress: z.string().default(OZ_DEFENDER_FORWARDER_ADDRESS)
      })
    }),
    z.object({
      biconomy: z.object({
        apiId: z.string(),
        apiKey: z.string(),
        deadlineSeconds: z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
      })
    })
  ]).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
});

// src/core/classes/rpc-connection-handler.ts
var RPCConnectionHandler = class extends EventEmitter {
  constructor(network, options) {
    super();
    const [signer, provider] = this.getSignerAndProvider(network, options);
    this.signer = signer;
    this.provider = provider;
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
  }
  updateSignerOrProvider(network) {
    const [signer, provider] = this.getSignerAndProvider(network, this.options);
    this.signer = signer;
    this.provider = provider;
  }
  isReadOnly() {
    return !Signer.isSigner(this.signer);
  }
  getSigner() {
    return this.signer;
  }
  getProvider() {
    return this.provider;
  }
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
  getSignerAndProvider(network, options) {
    var _a3;
    let signer;
    let provider;
    if (Signer.isSigner(network)) {
      signer = network;
      if (network.provider) {
        provider = network.provider;
      }
    }
    if (options == null ? void 0 : options.readonlySettings) {
      provider = getReadOnlyProvider(options.readonlySettings.rpcUrl, options.readonlySettings.chainId);
    }
    if (!provider) {
      if (providers.Provider.isProvider(network)) {
        provider = network;
      } else if (!Signer.isSigner(network)) {
        if (typeof network === "string") {
          provider = getReadOnlyProvider(network, (_a3 = options == null ? void 0 : options.readonlySettings) == null ? void 0 : _a3.chainId);
        } else {
          provider = ethers.getDefaultProvider(network);
        }
      }
    }
    if (!provider) {
      provider = ethers.getDefaultProvider();
      console.error("No provider found, using default provider on default chain!");
    }
    return [
      signer,
      provider
    ];
  }
};
__name(RPCConnectionHandler, "RPCConnectionHandler");

// src/core/auth/wallet-authenticator.ts
var WalletAuthenticator = class extends RPCConnectionHandler {
  constructor(network, wallet, options) {
    super(network, options);
    this.wallet = wallet;
  }
  async login(domain, options) {
    const parsedOptions = LoginOptionsSchema.parse(options);
    const signerAddress = await this.wallet.getAddress();
    const expirationTime = (parsedOptions == null ? void 0 : parsedOptions.expirationTime) || new Date(Date.now() + 1e3 * 60 * 5);
    const payloadData = LoginPayloadDataSchema.parse({
      domain,
      address: signerAddress,
      nonce: parsedOptions == null ? void 0 : parsedOptions.nonce,
      expiration_time: expirationTime,
      chain_id: parsedOptions == null ? void 0 : parsedOptions.chainId
    });
    const message = this.generateMessage(payloadData);
    const signature = await this.wallet.sign(message);
    return {
      payload: payloadData,
      signature
    };
  }
  verify(domain, payload, options) {
    const parsedOptions = VerifyOptionsSchema.parse(options);
    if (payload.payload.domain !== domain) {
      throw new Error(`Expected domain '${domain}' does not match domain on payload '${payload.payload.domain}'`);
    }
    const currentTime = new Date();
    if (currentTime > new Date(payload.payload.expiration_time)) {
      throw new Error(`Login request has expired`);
    }
    if ((parsedOptions == null ? void 0 : parsedOptions.chainId) !== void 0 && parsedOptions.chainId !== payload.payload.chain_id) {
      throw new Error(`Chain ID '${parsedOptions.chainId}' does not match payload chain ID '${payload.payload.chain_id}'`);
    }
    const message = this.generateMessage(payload.payload);
    const userAddress = this.wallet.recoverAddress(message, payload.signature);
    if (userAddress.toLowerCase() !== payload.payload.address.toLowerCase()) {
      throw new Error(`Signer address '${userAddress.toLowerCase()}' does not match payload address '${payload.payload.address.toLowerCase()}'`);
    }
    return userAddress;
  }
  async generateAuthToken(domain, payload, options) {
    if (isBrowser()) {
      throw new Error("Authentication tokens should not be generated in the browser, as they must be signed by a server-side admin wallet.");
    }
    const parsedOptions = AuthenticationOptionsSchema.parse(options);
    const userAddress = this.verify(domain, payload);
    const adminAddress = await this.wallet.getAddress();
    const payloadData = AuthenticationPayloadDataSchema.parse({
      iss: adminAddress,
      sub: userAddress,
      aud: domain,
      nbf: (parsedOptions == null ? void 0 : parsedOptions.invalidBefore) || new Date(),
      exp: (parsedOptions == null ? void 0 : parsedOptions.expirationTime) || new Date(Date.now() + 1e3 * 60 * 60 * 5),
      iat: new Date()
    });
    const message = JSON.stringify(payloadData);
    const signature = await this.wallet.sign(message);
    const header = {
      alg: "ES256",
      typ: "JWT"
    };
    const encodedHeader = Buffer.from(JSON.stringify(header)).toString("base64");
    const encodedData = Buffer.from(JSON.stringify(payloadData)).toString("base64").replace(/=/g, "");
    const encodedSignature = Buffer.from(signature).toString("base64");
    const token = `${encodedHeader}.${encodedData}.${encodedSignature}`;
    return token;
  }
  async authenticate(domain, token) {
    if (isBrowser()) {
      throw new Error("Should not authenticate tokens in the browser, as they must be verified by the server-side admin wallet.");
    }
    const encodedPayload = token.split(".")[1];
    const encodedSignature = token.split(".")[2];
    const payload = JSON.parse(Buffer.from(encodedPayload, "base64").toString());
    const signature = Buffer.from(encodedSignature, "base64").toString();
    if (payload.aud !== domain) {
      throw new Error(`Expected token to be for the domain '${domain}', but found token with domain '${payload.aud}'`);
    }
    const currentTime = Math.floor(new Date().getTime() / 1e3);
    if (currentTime < payload.nbf) {
      throw new Error(`This token is invalid before epoch time '${payload.nbf}', current epoch time is '${currentTime}'`);
    }
    if (currentTime > payload.exp) {
      throw new Error(`This token expired at epoch time '${payload.exp}', current epoch time is '${currentTime}'`);
    }
    const connectedAddress = await this.wallet.getAddress();
    if (connectedAddress.toLowerCase() !== payload.iss.toLowerCase()) {
      throw new Error(`Expected the connected wallet address '${connectedAddress}' to match the token issuer address '${payload.iss}'`);
    }
    const adminAddress = this.wallet.recoverAddress(JSON.stringify(payload), signature);
    if (connectedAddress.toLowerCase() !== adminAddress.toLowerCase()) {
      throw new Error(`The connected wallet address '${connectedAddress}' did not sign the token`);
    }
    return payload.sub;
  }
  generateMessage(payload) {
    let message = ``;
    message += `${payload.domain} wants you to sign in with your account:
${payload.address}

`;
    message += `Make sure that the requesting domain above matches the URL of the current website.

`;
    if (payload.chain_id) {
      message += `Chain ID: ${payload.chain_id}
`;
    }
    message += `Nonce: ${payload.nonce}
`;
    message += `Expiration Time: ${payload.expiration_time}
`;
    return message;
  }
};
__name(WalletAuthenticator, "WalletAuthenticator");

// src/core/classes/ipfs-storage.ts
init_esm_shims();

// src/core/helpers/storage.ts
init_esm_shims();
function replaceFilePropertiesWithHashes(object, cids) {
  const keys = Object.keys(object);
  for (const key in keys) {
    const val = object[keys[key]];
    const isFile = val instanceof File$1 || val instanceof Buffer;
    if (typeof val === "object" && !isFile) {
      replaceFilePropertiesWithHashes(val, cids);
      continue;
    }
    if (!isFile) {
      continue;
    }
    object[keys[key]] = `ipfs://${cids.splice(0, 1)[0]}`;
  }
  return object;
}
__name(replaceFilePropertiesWithHashes, "replaceFilePropertiesWithHashes");
function replaceHashWithGatewayUrl(object, scheme, gatewayUrl) {
  if (object === null || !object) {
    return {};
  }
  const keys = Object.keys(object);
  for (const key in keys) {
    const val = object[keys[key]];
    object[keys[key]] = resolveGatewayUrl(val, scheme, gatewayUrl);
    if (Array.isArray(val)) {
      object[keys[key]] = val.map((el) => {
        if (typeof el === "object") {
          return replaceHashWithGatewayUrl(el, scheme, gatewayUrl);
        } else {
          return resolveGatewayUrl(el, scheme, gatewayUrl);
        }
      });
    }
    if (typeof val === "object") {
      replaceHashWithGatewayUrl(val, scheme, gatewayUrl);
    }
  }
  return object;
}
__name(replaceHashWithGatewayUrl, "replaceHashWithGatewayUrl");
function replaceGatewayUrlWithHash(object, scheme, gatewayUrl) {
  if (object === null || !object) {
    return {};
  }
  const keys = Object.keys(object);
  for (const key in keys) {
    const val = object[keys[key]];
    object[keys[key]] = toIPFSHash(val, scheme, gatewayUrl);
    if (Array.isArray(val)) {
      object[keys[key]] = val.map((el) => {
        const isFile = el instanceof File$1 || el instanceof Buffer;
        if (typeof el === "object" && !isFile) {
          return replaceGatewayUrlWithHash(el, scheme, gatewayUrl);
        } else {
          return toIPFSHash(el, scheme, gatewayUrl);
        }
      });
    }
    const isFile1 = val instanceof File$1 || val instanceof Buffer;
    if (typeof val === "object" && !isFile1) {
      replaceGatewayUrlWithHash(val, scheme, gatewayUrl);
    }
  }
  return object;
}
__name(replaceGatewayUrlWithHash, "replaceGatewayUrlWithHash");
function resolveGatewayUrl(object, scheme, gatewayUrl) {
  if (typeof object === "string") {
    return object && object.toLowerCase().includes(scheme) ? object.replace(scheme, gatewayUrl) : object;
  } else {
    return object;
  }
}
__name(resolveGatewayUrl, "resolveGatewayUrl");
function toIPFSHash(object, scheme, gatewayUrl) {
  if (typeof object === "string") {
    return object && object.toLowerCase().includes(gatewayUrl) ? object.replace(gatewayUrl, scheme) : object;
  } else {
    return object;
  }
}
__name(toIPFSHash, "toIPFSHash");

// src/core/uploaders/pinata-uploader.ts
init_esm_shims();
var PinataUploader = class {
  async getUploadToken(contractAddress) {
    const headers = {
      "X-App-Name": `CONSOLE-TS-SDK-${contractAddress}`
    };
    const res = await fetch(`${TW_IPFS_SERVER_URL}/grant`, {
      method: "GET",
      headers
    });
    if (!res.ok) {
      throw new FetchError(`Failed to get upload token`);
    }
    const body = await res.text();
    return body;
  }
  async uploadBatchWithCid(files, fileStartNumber = 0, contractAddress, signerAddress, options) {
    const token = await this.getUploadToken(contractAddress || "");
    const formData = new FormData();
    const { data, fileNames } = this.buildFormData(formData, files, fileStartNumber, contractAddress, signerAddress);
    if (typeof window === "undefined") {
      if (options == null ? void 0 : options.onProgress) {
        console.warn("The onProgress option is only supported in the browser");
      }
      const res = await fetch(PINATA_IPFS_URL, {
        method: "POST",
        headers: __spreadValues({
          Authorization: `Bearer ${token}`
        }, data.getHeaders()),
        body: data.getBuffer()
      });
      const body = await res.json();
      if (!res.ok) {
        throw new UploadError("Failed to upload files to IPFS");
      }
      const cid = body.IpfsHash;
      if (!cid) {
        throw new UploadError("Failed to upload files to IPFS");
      }
      return {
        cid,
        fileNames
      };
    } else {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", PINATA_IPFS_URL);
        xhr.setRequestHeader("Authorization", `Bearer ${token}`);
        xhr.onloadend = () => {
          if (xhr.status !== 200) {
            throw new UploadError("Failed to upload files to IPFS");
          }
          const cid = JSON.parse(xhr.responseText).IpfsHash;
          if (!cid) {
            throw new UploadError("Failed to upload files to IPFS");
          }
          resolve({
            cid,
            fileNames
          });
        };
        xhr.onerror = (err) => {
          reject(err);
        };
        if (xhr.upload) {
          xhr.upload.onprogress = (event) => {
            if (options == null ? void 0 : options.onProgress) {
              options == null ? void 0 : options.onProgress({
                progress: event.loaded,
                total: event.total
              });
            }
          };
        }
        xhr.send(data);
      });
    }
  }
  buildFormData(data, files, fileStartNumber = 0, contractAddress, signerAddress) {
    const metadata = {
      name: `CONSOLE-TS-SDK-${contractAddress}`,
      keyvalues: {
        sdk: "typescript",
        contractAddress,
        signerAddress
      }
    };
    const fileNames = [];
    files.forEach((file, i) => {
      let fileName = "";
      let fileData = file;
      if (file instanceof File$1) {
        let extensions = "";
        if (file.name) {
          const extensionStartIndex = file.name.lastIndexOf(".");
          if (extensionStartIndex > -1) {
            extensions = file.name.substring(extensionStartIndex);
          }
        }
        fileName = `${i + fileStartNumber}${extensions}`;
      } else if (file instanceof Buffer || typeof file === "string") {
        fileName = `${i + fileStartNumber}`;
      } else if (file && file.name && (file == null ? void 0 : file.data)) {
        fileData = file == null ? void 0 : file.data;
        fileName = `${file.name}`;
      } else {
        fileName = `${i + fileStartNumber}`;
      }
      const filepath = `files/${fileName}`;
      if (fileNames.indexOf(fileName) > -1) {
        throw new DuplicateFileNameError(fileName);
      }
      fileNames.push(fileName);
      if (typeof window === "undefined") {
        data.append("file", fileData, {
          filepath
        });
      } else {
        data.append("file", new Blob([
          fileData
        ]), filepath);
      }
    });
    data.append("pinataMetadata", JSON.stringify(metadata));
    return {
      data,
      fileNames
    };
  }
};
__name(PinataUploader, "PinataUploader");
var IpfsStorage = class {
  failedUrls = [];
  constructor(gatewayUrl = DEFAULT_IPFS_GATEWAY, uploader = new PinataUploader()) {
    this.gatewayUrl = `${gatewayUrl.replace(/\/$/, "")}/`;
    this.uploader = uploader;
  }
  getNextPublicGateway() {
    const urlsToTry = PUBLIC_GATEWAYS.filter((url) => !this.failedUrls.includes(url)).filter((url) => url !== this.gatewayUrl);
    if (urlsToTry.length > 0) {
      return urlsToTry[0];
    } else {
      this.failedUrls = [];
      return void 0;
    }
  }
  async upload(data, contractAddress, signerAddress, options) {
    const { cid, fileNames } = await this.uploader.uploadBatchWithCid([
      data
    ], 0, contractAddress, signerAddress, options);
    const baseUri = `ipfs://${cid}/`;
    return `${baseUri}${fileNames[0]}`;
  }
  async uploadBatch(files, fileStartNumber = 0, contractAddress, signerAddress, options) {
    const { cid, fileNames } = await this.uploader.uploadBatchWithCid(files, fileStartNumber, contractAddress, signerAddress, options);
    const baseUri = `ipfs://${cid}/`;
    const uris = fileNames.map((filename) => `${baseUri}${filename}`);
    return {
      baseUri,
      uris
    };
  }
  async get(hash) {
    const res = await this._get(hash);
    const json = await res.json();
    return replaceHashWithGatewayUrl(json, "ipfs://", this.gatewayUrl);
  }
  async getRaw(hash) {
    const res = await this._get(hash);
    return await res.text();
  }
  async uploadMetadata(metadata, contractAddress, signerAddress, options) {
    const { uris } = await this.uploadMetadataBatch([
      metadata
    ], 0, contractAddress, signerAddress, options);
    return uris[0];
  }
  async uploadMetadataBatch(metadatas, fileStartNumber, contractAddress, signerAddress, options) {
    const metadataToUpload = (await this.batchUploadProperties(metadatas, options)).map((m) => JSON.stringify(m));
    const { cid, fileNames } = await this.uploader.uploadBatchWithCid(metadataToUpload, fileStartNumber, contractAddress, signerAddress);
    const baseUri = `ipfs://${cid}/`;
    const uris = fileNames.map((filename) => `${baseUri}${filename}`);
    return {
      baseUri,
      uris
    };
  }
  async _get(hash) {
    let uri = hash;
    if (hash) {
      uri = resolveGatewayUrl(hash, "ipfs://", this.gatewayUrl);
    }
    const result = await fetch(uri);
    if (!result.ok && result.status === 500) {
      throw new Error(`Error fetching ${uri} - Status code ${result.status}`);
    }
    if (!result.ok && result.status !== 404) {
      const nextUrl = this.getNextPublicGateway();
      if (nextUrl) {
        this.failedUrls.push(this.gatewayUrl);
        this.gatewayUrl = nextUrl;
        return this._get(hash);
      } else {
        throw new Error(`Error fetching ${uri} - Status code ${result.status}`);
      }
    }
    return result;
  }
  async batchUploadProperties(metadatas, options) {
    const sanitizedMetadatas = replaceGatewayUrlWithHash(metadatas, "ipfs://", this.gatewayUrl);
    const filesToUpload = sanitizedMetadatas.flatMap((m) => this.buildFilePropertiesMap(m, []));
    if (filesToUpload.length === 0) {
      return sanitizedMetadatas;
    }
    const { cid, fileNames } = await this.uploader.uploadBatchWithCid(filesToUpload, void 0, void 0, void 0, options);
    const cids = [];
    for (const filename of fileNames) {
      cids.push(`${cid}/${filename}`);
    }
    return replaceFilePropertiesWithHashes(sanitizedMetadatas, cids);
  }
  buildFilePropertiesMap(object, files = []) {
    if (Array.isArray(object)) {
      object.forEach((element) => {
        this.buildFilePropertiesMap(element, files);
      });
    } else if (object) {
      const values = Object.values(object);
      for (const val of values) {
        if (val instanceof File$1 || val instanceof Buffer) {
          files.push(val);
        } else if (typeof val === "object") {
          this.buildFilePropertiesMap(val, files);
        }
      }
    }
    return files;
  }
  async uploadSingle(data, contractAddress, signerAddress) {
    const token = await this.uploader.getUploadToken(contractAddress || "");
    const metadata = {
      name: `CONSOLE-TS-SDK-${contractAddress}`,
      keyvalues: {
        sdk: "typescript",
        contractAddress,
        signerAddress
      }
    };
    const formData = new FormData();
    const filepath = `files`;
    formData.append("file", data, filepath);
    formData.append("pinataMetadata", JSON.stringify(metadata));
    formData.append("pinataOptions", JSON.stringify({
      wrapWithDirectory: false
    }));
    const res = await fetch(PINATA_IPFS_URL, {
      method: "POST",
      headers: __spreadValues({
        Authorization: `Bearer ${token}`
      }, formData.getHeaders()),
      body: formData.getBuffer()
    });
    if (!res.ok) {
      throw new Error(`Failed to upload to IPFS [status code = ${res.status}]`);
    }
    const body = await res.json();
    return body.IpfsHash;
  }
};
__name(IpfsStorage, "IpfsStorage");

// src/core/classes/remote-storage.ts
init_esm_shims();
var RemoteStorage = class {
  constructor(storage) {
    this.storage = storage;
  }
  async fetch(hash) {
    return this.storage.get(hash);
  }
  async upload(data, options) {
    if (!Array.isArray(data)) {
      if (data instanceof File$1 || data instanceof Buffer || data.name && data.data && data.data instanceof Buffer) {
        return this.uploadBatch([
          data
        ], options);
      } else {
        return this.uploadMetadataBatch([
          data
        ], options);
      }
    }
    const allFiles = data.filter((item) => item instanceof File$1 || item instanceof Buffer || item.name && item.data && item.data instanceof Buffer);
    const allObjects = data.filter((item) => !(item instanceof File$1) && !(item instanceof Buffer));
    if (allFiles.length === data.length) {
      return this.uploadBatch(data, options);
    } else if (allObjects.length === data.length) {
      return this.uploadMetadataBatch(data, options);
    } else {
      throw new Error("Data to upload must be either all files or all JSON objects");
    }
  }
  async uploadBatch(files, options) {
    return await this.storage.uploadBatch(files, void 0, void 0, void 0, options);
  }
  async uploadMetadataBatch(metadatas, options) {
    return await this.storage.uploadMetadataBatch(metadatas, void 0, void 0, void 0, options);
  }
};
__name(RemoteStorage, "RemoteStorage");

// src/core/classes/contract-encoder.ts
init_esm_shims();
var ContractEncoder = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  encode(fn, args) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);
  }
  decode(fn, encodedArgs) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);
  }
};
__name(ContractEncoder, "ContractEncoder");

// src/core/classes/contract-metadata.ts
init_esm_shims();
var ContractMetadata = class {
  featureName = FEATURE_METADATA.name;
  constructor(contractWrapper, schema, storage) {
    this.contractWrapper = contractWrapper;
    this.schema = schema;
    this.storage = storage;
  }
  parseOutputMetadata(metadata) {
    return this.schema.output.parse(metadata);
  }
  parseInputMetadata(metadata) {
    return this.schema.input.parse(metadata);
  }
  async get() {
    let data;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const uri = await this.contractWrapper.readContract.contractURI();
      if (uri && uri.includes("://")) {
        data = await this.storage.get(uri);
      }
    }
    if (!data) {
      try {
        let contractName;
        try {
          if (hasFunction("name", this.contractWrapper)) {
            contractName = await this.contractWrapper.readContract.name();
          }
        } catch (err) {
        }
        const publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);
        data = {
          name: contractName || publishedMetadata.name,
          description: publishedMetadata.info.title
        };
      } catch (e) {
        throw new Error("Could not fetch contract metadata");
      }
    }
    return this.parseOutputMetadata(data);
  }
  async set(metadata) {
    const uri = await this._parseAndUploadMetadata(metadata);
    const wrapper = this.contractWrapper;
    if (this.supportsContractMetadata(wrapper)) {
      const receipt = await wrapper.sendTransaction("setContractURI", [
        uri
      ]);
      return {
        receipt,
        data: this.get
      };
    } else {
      throw new Error("Contract does not support updating contract metadata");
    }
  }
  async update(metadata) {
    return await this.set(__spreadValues(__spreadValues({}, await this.get()), metadata));
  }
  async _parseAndUploadMetadata(metadata) {
    const parsedMetadata = this.parseInputMetadata(metadata);
    return this.storage.uploadMetadata(parsedMetadata);
  }
  supportsContractMetadata(contractWrapper) {
    return detectContractFeature(contractWrapper, "ContractMetadata");
  }
};
__name(ContractMetadata, "ContractMetadata");

// src/core/classes/contract-roles.ts
init_esm_shims();
var ContractRoles = class {
  featureName = FEATURE_PERMISSIONS.name;
  constructor(contractWrapper, roles) {
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  async getAll() {
    invariant13(this.roles.length, "this contract has no support for roles");
    const roles = {};
    for (const role of this.roles) {
      roles[role] = await this.get(role);
    }
    return roles;
  }
  async get(role) {
    invariant13(this.roles.includes(role), `this contract does not support the "${role}" role`);
    const roleHash = getRoleHash(role);
    const count = (await this.contractWrapper.readContract.getRoleMemberCount(roleHash)).toNumber();
    return await Promise.all(Array.from(Array(count).keys()).map((i) => this.contractWrapper.readContract.getRoleMember(roleHash, i)));
  }
  async setAll(rolesWithAddresses) {
    const roles = Object.keys(rolesWithAddresses);
    invariant13(roles.length, "you must provide at least one role to set");
    invariant13(roles.every((role) => this.roles.includes(role)), "this contract does not support the given role");
    const currentRoles = await this.getAll();
    const encoded = [];
    const sortedRoles = roles.sort((role) => role === "admin" ? 1 : -1);
    for (let i = 0; i < sortedRoles.length; i++) {
      const role = sortedRoles[i];
      const addresses = rolesWithAddresses[role] || [];
      const currentAddresses = currentRoles[role] || [];
      const toAdd = addresses.filter((address) => !currentAddresses.includes(address));
      const toRemove = currentAddresses.filter((address) => !addresses.includes(address));
      if (toAdd.length) {
        toAdd.forEach((address) => {
          encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("grantRole", [
            getRoleHash(role),
            address
          ]));
        });
      }
      if (toRemove.length) {
        for (let j = 0; j < toRemove.length; j++) {
          const address = toRemove[j];
          const revokeFunctionName = await this.getRevokeRoleFunctionName(address);
          encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(revokeFunctionName, [
            getRoleHash(role),
            address
          ]));
        }
      }
    }
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async verify(roles, address) {
    await Promise.all(roles.map(async (role) => {
      const members = await this.get(role);
      if (!members.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new MissingRoleError(address, role);
      }
    }));
  }
  async grant(role, address) {
    invariant13(this.roles.includes(role), `this contract does not support the "${role}" role`);
    return {
      receipt: await this.contractWrapper.sendTransaction("grantRole", [
        getRoleHash(role),
        address
      ])
    };
  }
  async revoke(role, address) {
    invariant13(this.roles.includes(role), `this contract does not support the "${role}" role`);
    const revokeFunctionName = await this.getRevokeRoleFunctionName(address);
    return {
      receipt: await this.contractWrapper.sendTransaction(revokeFunctionName, [
        getRoleHash(role),
        address
      ])
    };
  }
  async getRevokeRoleFunctionName(address) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    if (signerAddress.toLowerCase() === address.toLowerCase()) {
      return "renounceRole";
    }
    return "revokeRole";
  }
};
__name(ContractRoles, "ContractRoles");

// src/core/classes/contract-royalty.ts
init_esm_shims();
var ContractRoyalty = class {
  featureName = FEATURE_ROYALTY.name;
  constructor(contractWrapper, metadata) {
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getDefaultRoyaltyInfo() {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getDefaultRoyaltyInfo();
    return CommonRoyaltySchema.parse({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  async getTokenRoyaltyInfo(tokenId) {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getRoyaltyInfoForToken(tokenId);
    return CommonRoyaltySchema.parse({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  async setDefaultRoyaltyInfo(royaltyData) {
    const oldMetadata = await this.metadata.get();
    const mergedMetadata = this.metadata.parseInputMetadata(__spreadValues(__spreadValues({}, oldMetadata), royaltyData));
    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
    if (hasFunction("setContractURI", this.contractWrapper)) {
      const encoded = [
        this.contractWrapper.readContract.interface.encodeFunctionData("setDefaultRoyaltyInfo", [
          mergedMetadata.fee_recipient,
          mergedMetadata.seller_fee_basis_points
        ]),
        this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [
          contractURI
        ])
      ];
      return {
        receipt: await this.contractWrapper.multiCall(encoded),
        data: () => this.getDefaultRoyaltyInfo()
      };
    } else {
      throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.");
    }
  }
  async setTokenRoyaltyInfo(tokenId, royaltyData) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setRoyaltyInfoForToken", [
        tokenId,
        royaltyData.fee_recipient,
        royaltyData.seller_fee_basis_points
      ]),
      data: () => this.getDefaultRoyaltyInfo()
    };
  }
};
__name(ContractRoyalty, "ContractRoyalty");

// src/core/classes/contract-sales.ts
init_esm_shims();
var ContractPrimarySale = class {
  featureName = FEATURE_PRIMARY_SALE.name;
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  async getRecipient() {
    return await this.contractWrapper.readContract.primarySaleRecipient();
  }
  async setRecipient(recipient) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setPrimarySaleRecipient", [
        recipient
      ])
    };
  }
};
__name(ContractPrimarySale, "ContractPrimarySale");

// src/core/classes/delayed-reveal.ts
init_esm_shims();

// src/common/nft.ts
init_esm_shims();

// abis/IERC721Metadata.json
var IERC721Metadata_default = [
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IERC1155Metadata.json
var IERC1155Metadata_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// abis/IERC165.json
var IERC165_default = [
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/common/nft.ts
var FALLBACK_METADATA = {
  name: "Failed to load NFT metadata"
};
async function fetchTokenMetadata(tokenId, tokenUri, storage) {
  const parsedUri = tokenUri.replace("{id}", ethers.utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));
  let jsonMetadata;
  try {
    jsonMetadata = await storage.get(parsedUri);
  } catch (err) {
    const unparsedTokenIdUri = tokenUri.replace("{id}", BigNumber.from(tokenId).toString());
    try {
      jsonMetadata = await storage.get(unparsedTokenIdUri);
    } catch (e) {
      console.warn(`failed to get token metadata: ${JSON.stringify({
        tokenId: tokenId.toString(),
        tokenUri
      })} -- falling back to default metadata`);
      jsonMetadata = FALLBACK_METADATA;
    }
  }
  return CommonNFTOutput.parse(__spreadValues({
    id: BigNumber.from(tokenId),
    uri: tokenUri
  }, jsonMetadata));
}
__name(fetchTokenMetadata, "fetchTokenMetadata");
async function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {
  let uri;
  const erc165 = new Contract(contractAddress, IERC165_default, provider);
  const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
  const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
  if (isERC721) {
    const erc721 = new Contract(contractAddress, IERC721Metadata_default, provider);
    uri = await erc721.tokenURI(tokenId);
  } else if (isERC1155) {
    const erc1155 = new Contract(contractAddress, IERC1155Metadata_default, provider);
    uri = await erc1155.uri(tokenId);
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
  if (!uri) {
    throw new NotFoundError();
  }
  return fetchTokenMetadata(tokenId, uri, storage);
}
__name(fetchTokenMetadataForContract, "fetchTokenMetadataForContract");
async function uploadOrExtractURI(metadata, storage) {
  if (typeof metadata === "string") {
    return metadata;
  } else {
    return await storage.uploadMetadata(CommonNFTInput.parse(metadata));
  }
}
__name(uploadOrExtractURI, "uploadOrExtractURI");
async function uploadOrExtractURIs(metadatas, storage, startNumber, contractAddress, signerAddress, options) {
  if (isUriList(metadatas)) {
    return metadatas;
  } else if (isMetadataList(metadatas)) {
    const { uris } = await storage.uploadMetadataBatch(metadatas.map((m) => CommonNFTInput.parse(m)), startNumber, contractAddress, signerAddress, options);
    return uris;
  } else {
    throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)");
  }
}
__name(uploadOrExtractURIs, "uploadOrExtractURIs");
function isUriList(metadatas) {
  return metadatas.find((m) => typeof m !== "string") === void 0;
}
__name(isUriList, "isUriList");
function isMetadataList(metadatas) {
  return metadatas.find((m) => typeof m !== "object") === void 0;
}
__name(isMetadataList, "isMetadataList");

// abis/IDelayedRevealDeprecated.json
var IDelayedRevealDeprecated_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      }
    ],
    name: "encryptedBaseURI",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/core/classes/delayed-reveal.ts
var DelayedReveal = class {
  constructor(contractWrapper, storage, fetureName, nextTokenIdToMintFn) {
    this.featureName = fetureName;
    this.nextTokenIdToMintFn = nextTokenIdToMintFn;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async createDelayedRevealBatch(placeholder, metadatas, password, options) {
    var _a3, _b2;
    if (!password) {
      throw new Error("Password is required");
    }
    const { baseUri: placeholderUri } = await this.storage.uploadMetadataBatch([
      CommonNFTInput.parse(placeholder)
    ], 0, this.contractWrapper.readContract.address, await ((_a3 = this.contractWrapper.getSigner()) == null ? void 0 : _a3.getAddress()));
    const startFileNumber = await this.nextTokenIdToMintFn();
    const batch = await this.storage.uploadMetadataBatch(metadatas.map((m) => CommonNFTInput.parse(m)), startFileNumber.toNumber(), this.contractWrapper.readContract.address, await ((_b2 = this.contractWrapper.getSigner()) == null ? void 0 : _b2.getAddress()), options);
    const baseUri = batch.baseUri.endsWith("/") ? batch.baseUri : `${batch.baseUri}/`;
    const baseUriId = await this.contractWrapper.readContract.getBaseURICount();
    const hashedPassword = await this.hashDelayRevealPasword(baseUriId, password);
    const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(ethers.utils.toUtf8Bytes(baseUri), hashedPassword);
    let data;
    const legacyContract = await this.isLegacyContract();
    if (legacyContract) {
      data = encryptedBaseUri;
    } else {
      const chainId = await this.contractWrapper.getChainID();
      const provenanceHash = ethers.utils.solidityKeccak256([
        "bytes",
        "bytes",
        "uint256"
      ], [
        ethers.utils.toUtf8Bytes(baseUri),
        hashedPassword,
        chainId
      ]);
      data = ethers.utils.defaultAbiCoder.encode([
        "bytes",
        "bytes32"
      ], [
        encryptedBaseUri,
        provenanceHash
      ]);
    }
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [
      batch.uris.length,
      placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`,
      data
    ]);
    const events = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = events[0].args.startTokenId;
    const endingIndex = events[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt
      });
    }
    return results;
  }
  async reveal(batchId, password) {
    if (!password) {
      throw new Error("Password is required");
    }
    const key = await this.hashDelayRevealPasword(batchId, password);
    try {
      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
      if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
        throw new Error("invalid password");
      }
    } catch (e) {
      throw new Error("invalid password");
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("reveal", [
        batchId,
        key
      ])
    };
  }
  async getBatchesToReveal() {
    const count = await this.contractWrapper.readContract.getBaseURICount();
    if (count.isZero()) {
      return [];
    }
    const countRangeArray = Array.from(Array(count.toNumber()).keys());
    const uriIndices = await Promise.all(countRangeArray.map((i) => {
      if (hasFunction("getBatchIdAtIndex", this.contractWrapper)) {
        return this.contractWrapper.readContract.getBatchIdAtIndex(i);
      }
      if (hasFunction("baseURIIndices", this.contractWrapper)) {
        return this.contractWrapper.readContract.baseURIIndices(i);
      }
      throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.");
    }));
    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
    const tokenMetadatas = await Promise.all(Array.from([
      0,
      ...uriIndicesWithZeroStart
    ]).map((i) => this.getNftMetadata(i.toString())));
    const legacyContract = await this.isLegacyContract();
    const encryptedUriData = await Promise.all(Array.from([
      ...uriIndices
    ]).map((i) => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.readContract.encryptedData(i)));
    const encryptedBaseUris = encryptedUriData.map((data) => {
      if (ethers.utils.hexDataLength(data) > 0) {
        if (legacyContract) {
          return data;
        }
        const result = ethers.utils.defaultAbiCoder.decode([
          "bytes",
          "bytes32"
        ], data);
        return result[0];
      } else {
        return data;
      }
    });
    return tokenMetadatas.map((meta, index) => ({
      batchId: BigNumber.from(index),
      batchUri: meta.uri,
      placeholderMetadata: meta
    })).filter((_, index) => ethers.utils.hexDataLength(encryptedBaseUris[index]) > 0);
  }
  async hashDelayRevealPasword(batchTokenIndex, password) {
    const chainId = await this.contractWrapper.getChainID();
    const contractAddress = this.contractWrapper.readContract.address;
    return ethers.utils.solidityKeccak256([
      "string",
      "uint256",
      "uint256",
      "address"
    ], [
      password,
      chainId,
      batchTokenIndex,
      contractAddress
    ]);
  }
  async getNftMetadata(tokenId) {
    return fetchTokenMetadataForContract(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), tokenId, this.storage);
  }
  async isLegacyContract() {
    if (hasFunction("contractVersion", this.contractWrapper)) {
      try {
        const version = await this.contractWrapper.readContract.contractVersion();
        return version <= 2;
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  async getLegacyEncryptedData(index) {
    const legacy = new ethers.Contract(this.contractWrapper.readContract.address, IDelayedRevealDeprecated_default, this.contractWrapper.getProvider());
    const result = await legacy.functions["encryptedBaseURI"](index);
    if (result.length > 0) {
      return result[0];
    } else {
      return "0x";
    }
  }
};
__name(DelayedReveal, "DelayedReveal");

// src/core/classes/drop-claim-conditions.ts
init_esm_shims();

// src/common/currency.ts
init_esm_shims();

// src/core/classes/contract-wrapper.ts
init_esm_shims();

// src/common/forwarder.ts
init_esm_shims();
var ForwardRequest = [
  {
    name: "from",
    type: "address"
  },
  {
    name: "to",
    type: "address"
  },
  {
    name: "value",
    type: "uint256"
  },
  {
    name: "gas",
    type: "uint256"
  },
  {
    name: "nonce",
    type: "uint256"
  },
  {
    name: "data",
    type: "bytes"
  }
];
var BiconomyForwarderAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _nonces = {};
var _noncesSyncTimestamp = {};
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  const shouldSync = Date.now() - timestamp >= 2e3;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = BigNumber.from(_nonces[address]).add(1);
  return nonce;
}
__name(getAndIncrementNonce, "getAndIncrementNonce");

// typechain/index.ts
init_esm_shims();

// typechain/factories/Forwarder__factory.ts
init_esm_shims();
var _abi = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct MinimalForwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct MinimalForwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _bytecode = "0x61014060405234801561001157600080fd5b50604080518082018252601081526f26b4b734b6b0b62337b93bb0b93232b960811b602080830191825283518085019094526005845264302e302e3160d81b908401528151902060e08190527fae209a0b48f21c054280f2455d32cf309387644879d9acbd8ffc1991638118856101008190524660a0529192917f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6100fb8184846040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b6080523060c052610120525061011092505050565b60805160a05160c05160e0516101005161012051610b6961015f60003960006104f701526000610546015260006105210152600061047a015260006104a4015260006104ce0152610b696000f3fe6080604052600436106100345760003560e01c80632d0335ab1461003957806347153f8214610082578063bf5d3bdb146100a3575b600080fd5b34801561004557600080fd5b5061006f610054366004610901565b6001600160a01b031660009081526020819052604090205490565b6040519081526020015b60405180910390f35b610095610090366004610931565b6100d3565b604051610079929190610a00565b3480156100af57600080fd5b506100c36100be366004610931565b610277565b6040519015158152602001610079565b600060606100e2858585610277565b6101595760405162461bcd60e51b815260206004820152603260248201527f4d696e696d616c466f727761726465723a207369676e617475726520646f657360448201527f206e6f74206d617463682072657175657374000000000000000000000000000060648201526084015b60405180910390fd5b61016860808601356001610a3c565b6000806101786020890189610901565b6001600160a01b03166001600160a01b03168152602001908152602001600020819055506000808660200160208101906101b29190610901565b6001600160a01b0316606088013560408901356101d260a08b018b610a62565b6101df60208d018d610901565b6040516020016101f193929190610aa9565b60408051601f198184030181529082905261020b91610acf565b600060405180830381858888f193505050503d8060008114610249576040519150601f19603f3d011682016040523d82523d6000602084013e61024e565b606091505b509092509050610263603f6060890135610aeb565b5a1161026b57fe5b90969095509350505050565b60008061038a84848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061038492507fdd8f4b70b0f4393e889bd39128a30628a78b61816a9eb8199759e7a349657e4891506102e7905060208a018a610901565b6102f760408b0160208c01610901565b60408b013560608c013560808d013561031360a08f018f610a62565b604051610321929190610b0d565b6040805191829003822060208301989098526001600160a01b0396871690820152949093166060850152608084019190915260a083015260c082015260e081019190915261010001604051602081830303815290604052805190602001206103f5565b90610449565b905060808501356000806103a16020890189610901565b6001600160a01b03166001600160a01b03168152602001908152602001600020541480156103ec57506103d76020860186610901565b6001600160a01b0316816001600160a01b0316145b95945050505050565b600061044361040261046d565b8360405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b92915050565b60008060006104588585610594565b9150915061046581610604565b509392505050565b6000306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161480156104c657507f000000000000000000000000000000000000000000000000000000000000000046145b156104f057507f000000000000000000000000000000000000000000000000000000000000000090565b50604080517f00000000000000000000000000000000000000000000000000000000000000006020808301919091527f0000000000000000000000000000000000000000000000000000000000000000828401527f000000000000000000000000000000000000000000000000000000000000000060608301524660808301523060a0808401919091528351808403909101815260c0909201909252805191012090565b6000808251604114156105cb5760208301516040840151606085015160001a6105bf878285856107c2565b945094505050506105fd565b8251604014156105f557602083015160408401516105ea8683836108af565b9350935050506105fd565b506000905060025b9250929050565b600081600481111561061857610618610b1d565b14156106215750565b600181600481111561063557610635610b1d565b14156106835760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610150565b600281600481111561069757610697610b1d565b14156106e55760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610150565b60038160048111156106f9576106f9610b1d565b14156107525760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610150565b600481600481111561076657610766610b1d565b14156107bf5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610150565b50565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156107f957506000905060036108a6565b8460ff16601b1415801561081157508460ff16601c14155b1561082257506000905060046108a6565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610876573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661089f576000600192509250506108a6565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8316816108e560ff86901c601b610a3c565b90506108f3878288856107c2565b935093505050935093915050565b60006020828403121561091357600080fd5b81356001600160a01b038116811461092a57600080fd5b9392505050565b60008060006040848603121561094657600080fd5b833567ffffffffffffffff8082111561095e57600080fd5b9085019060c0828803121561097257600080fd5b9093506020850135908082111561098857600080fd5b818601915086601f83011261099c57600080fd5b8135818111156109ab57600080fd5b8760208285010111156109bd57600080fd5b6020830194508093505050509250925092565b60005b838110156109eb5781810151838201526020016109d3565b838111156109fa576000848401525b50505050565b82151581526040602082015260008251806040840152610a278160608501602087016109d0565b601f01601f1916919091016060019392505050565b60008219821115610a5d57634e487b7160e01b600052601160045260246000fd5b500190565b6000808335601e19843603018112610a7957600080fd5b83018035915067ffffffffffffffff821115610a9457600080fd5b6020019150368190038213156105fd57600080fd5b8284823760609190911b6bffffffffffffffffffffffff19169101908152601401919050565b60008251610ae18184602087016109d0565b9190910192915050565b600082610b0857634e487b7160e01b600052601260045260246000fd5b500490565b8183823760009101908152919050565b634e487b7160e01b600052602160045260246000fdfea26469706673582212209306207ce9577feaceff6e4eb11f4c5a7b15ecf2c97100d032e05b97bfab1bf864736f6c634300080c0033";
var isSuperArgs = /* @__PURE__ */ __name((xs) => xs.length > 1, "isSuperArgs");
var Forwarder__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }
  deploy(overrides) {
    return super.deploy(overrides || {});
  }
  getDeployTransaction(overrides) {
    return super.getDeployTransaction(overrides || {});
  }
  attach(address) {
    return super.attach(address);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new utils.Interface(_abi);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi, signerOrProvider);
  }
};
__name(Forwarder__factory, "Forwarder__factory");
__publicField(Forwarder__factory, "bytecode", _bytecode);
__publicField(Forwarder__factory, "abi", _abi);

// typechain/factories/IERC20__factory.ts
init_esm_shims();
var _abi2 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "who",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var IERC20__factory = class {
  static createInterface() {
    return new utils.Interface(_abi2);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi2, signerOrProvider);
  }
};
__name(IERC20__factory, "IERC20__factory");
__publicField(IERC20__factory, "abi", _abi2);

// typechain/factories/IThirdwebContract__factory.ts
init_esm_shims();
var _abi3 = [
  {
    inputs: [],
    name: "contractType",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "contractVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var IThirdwebContract__factory = class {
  static createInterface() {
    return new utils.Interface(_abi3);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi3, signerOrProvider);
  }
};
__name(IThirdwebContract__factory, "IThirdwebContract__factory");
__publicField(IThirdwebContract__factory, "abi", _abi3);

// typechain/factories/TWFactory__factory.ts
init_esm_shims();
var _abi4 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "address",
        name: "_registry",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "contractType",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "version",
        type: "uint256"
      }
    ],
    name: "ImplementationAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      }
    ],
    name: "ImplementationApproved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "proxy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      }
    ],
    name: "ProxyDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FACTORY_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "addImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "approval",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "currentVersion",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "deployProxy",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyByImplementation",
    outputs: [
      {
        internalType: "address",
        name: "deployedProxy",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyDeterministic",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deployer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_version",
        type: "uint256"
      }
    ],
    name: "getImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      }
    ],
    name: "getLatestImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "registry",
    outputs: [
      {
        internalType: "contract TWRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _bytecode2 = "0x60c06040523480156200001157600080fd5b5060405162001f6238038062001f62833981016040819052620000349162000276565b6001600160a01b0382166080526200005760006200005162000099565b620000b5565b620000867fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee276200005162000099565b6001600160a01b031660a05250620002ae565b6000620000b0620000c560201b62000d211760201c565b905090565b620000c18282620000fe565b5050565b6080516000906001600160a01b0316331415620000e9575060131936013560601c90565b620000b06200014160201b62000d6b1760201c565b6200011582826200014560201b62000d6f1760201c565b60008281526001602090815260409091206200013c91839062000e0e620001e7821b17901c565b505050565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16620000c1576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620001a362000099565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001fe836001600160a01b03841662000207565b90505b92915050565b6000818152600183016020526040812054620002505750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915562000201565b50600062000201565b80516001600160a01b03811681146200027157600080fd5b919050565b600080604083850312156200028a57600080fd5b620002958362000259565b9150620002a56020840162000259565b90509250929050565b60805160a051611c79620002e960003960008181610336015281816106510152610c6f0152600081816103010152610d250152611c796000f3fe608060405234801561001057600080fd5b50600436106101985760003560e01c80639010d07c116100e3578063c6e2a4001161008c578063dd47595a11610066578063dd47595a1461044f578063e92016a414610483578063ec54d72f146104b757600080fd5b8063c6e2a40014610416578063ca15c87314610429578063d547741f1461043c57600080fd5b8063a217fddf116100bd578063a217fddf146103c5578063ac9650d8146103cd578063b9caf9d9146103ed57600080fd5b80639010d07c1461035857806391d148541461036b5780639430b496146103a257600080fd5b806336568abe1161014557806356fb09581161011f57806356fb0958146102de578063572b6c05146102f15780637b1039991461033157600080fd5b806336568abe146102705780633b426d3f1461028357806344ab6680146102a357600080fd5b80631e5e1e99116101765780631e5e1e9914610225578063248a9ca3146102385780632f2ff15d1461025b57600080fd5b806301ffc9a71461019d57806304a0fb17146101c557806311b804ab146101fa575b600080fd5b6101b06101ab366004611675565b6104ca565b60405190151581526020015b60405180910390f35b6101ec7fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee2781565b6040519081526020016101bc565b61020d61020836600461175e565b6104f5565b6040516001600160a01b0390911681526020016101bc565b61020d6102333660046117b5565b610705565b6101ec6102463660046117e8565b60009081526020819052604090206001015490565b61026e610269366004611801565b610745565b005b61026e61027e366004611801565b610777565b6101ec6102913660046117e8565b60036020526000908152604090205481565b61020d6102b13660046117e8565b6000908152600460209081526040808320600383528184205484529091529020546001600160a01b031690565b61026e6102ec36600461182d565b610813565b6101b06102ff366004611869565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b61020d7f000000000000000000000000000000000000000000000000000000000000000081565b61020d610366366004611884565b6108db565b6101b0610379366004611801565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6101b06103b0366004611869565b60026020526000908152604090205460ff1681565b6101ec600081565b6103e06103db3660046118a6565b6108f3565b6040516101bc9190611977565b61020d6103fb366004611869565b6005602052600090815260409020546001600160a01b031681565b61026e610424366004611869565b6109e8565b6101ec6104373660046117e8565b610c2b565b61026e61044a366004611801565b610c42565b61020d61045d366004611884565b60009182526004602090815260408084209284529190529020546001600160a01b031690565b61020d610491366004611884565b60046020908152600092835260408084209091529082529020546001600160a01b031681565b61020d6104c53660046119d9565b610c6a565b60006001600160e01b03198216635a05180f60e01b14806104ef57506104ef82610e23565b92915050565b6001600160a01b03831660009081526002602052604081205460ff166105625760405162461bcd60e51b815260206004820152601b60248201527f696d706c656d656e746174696f6e206e6f7420617070726f766564000000000060448201526064015b60405180910390fd5b600061056c610e58565b8360405160200161059b92919060609290921b6bffffffffffffffffffffffff19168252601482015260340190565b6040516020818303038152906040528051906020012090506105bd8582610e62565b91506105c7610e58565b6001600160a01b038381166000908152600560205260409020805473ffffffffffffffffffffffffffffffffffffffff19169290911691909117905561060b610e58565b6040516001600160a01b038481168252918216918716907f9e0862c4ebff2150fbbfd3f8547483f55bdec0c34fd977d3fccaa55d6c4ce7849060200160405180910390a37f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166352c28fab610686610e58565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201529085166024820152604401600060405180830381600087803b1580156106cf57600080fd5b505af11580156106e3573d6000803e3d6000fd5b505050506000845111156106fd576106fb8285610f19565b505b509392505050565b6000838152600460209081526040808320600383528184205484529091528120546001600160a01b031661073a8185856104f5565b9150505b9392505050565b60008281526020819052604090206001015461076881610763610e58565b610f5b565b6107728383610fd9565b505050565b61077f610e58565b6001600160a01b0316816001600160a01b0316146108055760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c6600000000000000000000000000000000006064820152608401610559565b61080f8282610ffb565b5050565b61083f7fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27610379610e58565b6108785760405162461bcd60e51b815260206004820152600a6024820152693737ba1030b236b4b71760b11b6044820152606401610559565b6001600160a01b038216600081815260026020908152604091829020805460ff19168515159081179091558251938452908301527f46c2f0868ef35772e9324a42eb6fa484490cca8494538a909cf05c897d7d4108910160405180910390a15050565b600082815260016020526040812061073e908361101d565b60608167ffffffffffffffff81111561090e5761090e6116bb565b60405190808252806020026020018201604052801561094157816020015b606081526020019060019003908161092c5790505b50905060005b828110156109e1576109b13085858481811061096557610965611a20565b90506020028101906109779190611a36565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061102992505050565b8282815181106109c3576109c3611a20565b602002602001018190525080806109d990611a9a565b915050610947565b5092915050565b610a147fdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27610379610e58565b610a4d5760405162461bcd60e51b815260206004820152600a6024820152693737ba1030b236b4b71760b11b6044820152606401610559565b60008190506000816001600160a01b031663cb2ef6f76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab69190611ab5565b90506000826001600160a01b031663a0a8e4606040518163ffffffff1660e01b8152600401602060405180830381865afa158015610af8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1c9190611ace565b60008381526003602052604090205490915060ff8082169083161015610b845760405162461bcd60e51b815260206004820152601460248201527f77726f6e67206d6f64756c652076657273696f6e0000000000000000000000006044820152606401610559565b600083815260036020908152604080832060ff861690819055600483528184208185528352818420805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038b169081179091558085526002845293829020805460ff1916600117905581519384529183019190915284917fc39db2d47bafbb20367a9c840abffa57a2bc243c1f1e67c939ea0e89e59ed01a910160405180910390a25050505050565b60008181526001602052604081206104ef9061104e565b600082815260208190526040902060010154610c6081610763610e58565b6107728383610ffb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166305d85eda610ca4610e58565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602401602060405180830381865afa158015610ce8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d0c9190611ab5565b9050610d19848483610705565b949350505050565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316331415610d61575060131936013560601c90565b503390565b905090565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1661080f576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055610dca610e58565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b600061073e836001600160a01b038416611058565b60006001600160e01b03198216637965db0b60e01b14806104ef57506301ffc9a760e01b6001600160e01b03198316146104ef565b6000610d66610d21565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f59150506001600160a01b0381166104ef5760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c65640000000000000000006044820152606401610559565b606061073e83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c656400008152506110a7565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1661080f57610f97816001600160a01b031660146110b6565b610fa28360206110b6565b604051602001610fb3929190611af1565b60408051601f198184030181529082905262461bcd60e51b825261055991600401611b72565b610fe38282610d6f565b60008281526001602052604090206107729082610e0e565b611005828261125f565b600082815260016020526040902061077290826112fc565b600061073e8383611311565b606061073e8383604051806060016040528060278152602001611c1d6027913961133b565b60006104ef825490565b600081815260018301602052604081205461109f575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556104ef565b5060006104ef565b6060610d198484600085611418565b606060006110c5836002611b85565b6110d0906002611ba4565b67ffffffffffffffff8111156110e8576110e86116bb565b6040519080825280601f01601f191660200182016040528015611112576020820181803683370190505b509050600360fc1b8160008151811061112d5761112d611a20565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061115c5761115c611a20565b60200101906001600160f81b031916908160001a9053506000611180846002611b85565b61118b906001611ba4565b90505b6001811115611210577f303132333435363738396162636465660000000000000000000000000000000085600f16601081106111cc576111cc611a20565b1a60f81b8282815181106111e2576111e2611a20565b60200101906001600160f81b031916908160001a90535060049490941c9361120981611bbc565b905061118e565b50831561073e5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610559565b6000828152602081815260408083206001600160a01b038516845290915290205460ff161561080f576000828152602081815260408083206001600160a01b03851684529091529020805460ff191690556112b8610e58565b6001600160a01b0316816001600160a01b0316837ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b60405160405180910390a45050565b600061073e836001600160a01b038416611549565b600082600001828154811061132857611328611a20565b9060005260206000200154905092915050565b60606001600160a01b0384163b6113a35760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b6064820152608401610559565b600080856001600160a01b0316856040516113be9190611bd3565b600060405180830381855af49150503d80600081146113f9576040519150601f19603f3d011682016040523d82523d6000602084013e6113fe565b606091505b509150915061140e82828661163c565b9695505050505050565b6060824710156114795760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610559565b6001600160a01b0385163b6114d05760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610559565b600080866001600160a01b031685876040516114ec9190611bd3565b60006040518083038185875af1925050503d8060008114611529576040519150601f19603f3d011682016040523d82523d6000602084013e61152e565b606091505b509150915061153e82828661163c565b979650505050505050565b6000818152600183016020526040812054801561163257600061156d600183611bef565b855490915060009061158190600190611bef565b90508181146115e65760008660000182815481106115a1576115a1611a20565b90600052602060002001549050808760000184815481106115c4576115c4611a20565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806115f7576115f7611c06565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506104ef565b60009150506104ef565b6060831561164b57508161073e565b82511561165b5782518084602001fd5b8160405162461bcd60e51b81526004016105599190611b72565b60006020828403121561168757600080fd5b81356001600160e01b03198116811461073e57600080fd5b80356001600160a01b03811681146116b657600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126116e257600080fd5b813567ffffffffffffffff808211156116fd576116fd6116bb565b604051601f8301601f19908116603f01168101908282118183101715611725576117256116bb565b8160405283815286602085880101111561173e57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060006060848603121561177357600080fd5b61177c8461169f565b9250602084013567ffffffffffffffff81111561179857600080fd5b6117a4868287016116d1565b925050604084013590509250925092565b6000806000606084860312156117ca57600080fd5b83359250602084013567ffffffffffffffff81111561179857600080fd5b6000602082840312156117fa57600080fd5b5035919050565b6000806040838503121561181457600080fd5b823591506118246020840161169f565b90509250929050565b6000806040838503121561184057600080fd5b6118498361169f565b91506020830135801515811461185e57600080fd5b809150509250929050565b60006020828403121561187b57600080fd5b61073e8261169f565b6000806040838503121561189757600080fd5b50508035926020909101359150565b600080602083850312156118b957600080fd5b823567ffffffffffffffff808211156118d157600080fd5b818501915085601f8301126118e557600080fd5b8135818111156118f457600080fd5b8660208260051b850101111561190957600080fd5b60209290920196919550909350505050565b60005b8381101561193657818101518382015260200161191e565b83811115611945576000848401525b50505050565b6000815180845261196381602086016020860161191b565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156119cc57603f198886030184526119ba85835161194b565b9450928501929085019060010161199e565b5092979650505050505050565b600080604083850312156119ec57600080fd5b82359150602083013567ffffffffffffffff811115611a0a57600080fd5b611a16858286016116d1565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112611a4d57600080fd5b83018035915067ffffffffffffffff821115611a6857600080fd5b602001915036819003821315611a7d57600080fd5b9250929050565b634e487b7160e01b600052601160045260246000fd5b6000600019821415611aae57611aae611a84565b5060010190565b600060208284031215611ac757600080fd5b5051919050565b600060208284031215611ae057600080fd5b815160ff8116811461073e57600080fd5b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611b2981601785016020880161191b565b7f206973206d697373696e6720726f6c65200000000000000000000000000000006017918401918201528351611b6681602884016020880161191b565b01602801949350505050565b60208152600061073e602083018461194b565b6000816000190483118215151615611b9f57611b9f611a84565b500290565b60008219821115611bb757611bb7611a84565b500190565b600081611bcb57611bcb611a84565b506000190190565b60008251611be581846020870161191b565b9190910192915050565b600082821015611c0157611c01611a84565b500390565b634e487b7160e01b600052603160045260246000fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220a715dc4629baeee69aad7fcca92ef128d615383104dac998cd5fabf7d89917fb64736f6c634300080c0033";
var isSuperArgs2 = /* @__PURE__ */ __name((xs) => xs.length > 1, "isSuperArgs");
var TWFactory__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs2(args)) {
      super(...args);
    } else {
      super(_abi4, _bytecode2, args[0]);
    }
  }
  deploy(_trustedForwarder, _registry, overrides) {
    return super.deploy(_trustedForwarder, _registry, overrides || {});
  }
  getDeployTransaction(_trustedForwarder, _registry, overrides) {
    return super.getDeployTransaction(_trustedForwarder, _registry, overrides || {});
  }
  attach(address) {
    return super.attach(address);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new utils.Interface(_abi4);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi4, signerOrProvider);
  }
};
__name(TWFactory__factory, "TWFactory__factory");
__publicField(TWFactory__factory, "bytecode", _bytecode2);
__publicField(TWFactory__factory, "abi", _abi4);

// typechain/factories/TWRegistry__factory.ts
init_esm_shims();
var _abi5 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Added",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Deleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "count",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "getAll",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _bytecode3 = "0x60a06040523480156200001157600080fd5b50604051620016c6380380620016c683398101604081905262000034916200021e565b6001600160a01b038116608052620000576000620000516200005e565b6200007a565b5062000250565b6000620000756200008a60201b6200082e1760201c565b905090565b620000868282620000c3565b5050565b6080516000906001600160a01b0316331415620000ae575060131936013560601c90565b620000756200010660201b620008781760201c565b620000da82826200010a60201b6200087c1760201c565b6000828152600160209081526040909120620001019183906200091b620001ac821b17901c565b505050565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000086576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620001686200005e565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000620001c3836001600160a01b038416620001cc565b90505b92915050565b60008181526001830160205260408120546200021557508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155620001c6565b506000620001c6565b6000602082840312156200023157600080fd5b81516001600160a01b03811681146200024957600080fd5b9392505050565b60805161145362000273600039600081816101bc015261083201526114536000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c80639010d07c11610097578063ca15c87311610066578063ca15c87314610289578063d547741f1461029c578063eb077342146102af578063f5b541a6146102cf57600080fd5b80639010d07c146101ff57806391d148541461022a578063a217fddf14610261578063ac9650d81461026957600080fd5b806336568abe116100d357806336568abe1461018657806352c28fab14610199578063572b6c05146101ac5780637f7c1491146101ec57600080fd5b806301ffc9a71461010557806305d85eda1461012d578063248a9ca31461014e5780632f2ff15d14610171575b600080fd5b610118610113366004610fae565b6102f6565b60405190151581526020015b60405180910390f35b61014061013b366004610ff4565b610321565b604051908152602001610124565b61014061015c36600461100f565b60009081526020819052604090206001015490565b61018461017f366004611028565b610342565b005b610184610194366004611028565b610374565b6101846101a7366004611054565b610415565b6101186101ba366004610ff4565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b6101846101fa366004611054565b610566565b61021261020d36600461107e565b6106b7565b6040516001600160a01b039091168152602001610124565b610118610238366004611028565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b610140600081565b61027c6102773660046110a0565b6106d6565b6040516101249190611171565b61014061029736600461100f565b6107cb565b6101846102aa366004611028565b6107e2565b6102c26102bd366004610ff4565b61080a565b60405161012491906111d3565b6101407f97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b92981565b60006001600160e01b03198216635a05180f60e01b148061031b575061031b82610930565b92915050565b6001600160a01b038116600090815260026020526040812061031b90610965565b6000828152602081905260409020600101546103658161036061096f565b610979565b61036f83836109f7565b505050565b61037c61096f565b6001600160a01b0316816001600160a01b0316146104075760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084015b60405180910390fd5b6104118282610a19565b5050565b6104417f97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b92961023861096f565b80610464575061044f61096f565b6001600160a01b0316826001600160a01b0316145b6104b05760405162461bcd60e51b815260206004820152601960248201527f6e6f74206f70657261746f72206f72206465706c6f7965722e0000000000000060448201526064016103fe565b6001600160a01b03821660009081526002602052604081206104d2908361091b565b9050806105215760405162461bcd60e51b815260206004820152600d60248201527f6661696c656420746f206164640000000000000000000000000000000000000060448201526064016103fe565b816001600160a01b0316836001600160a01b03167f938c63ac3d228b23f6bee7618fefc6790522e338ac202c958a2ea9eb9706c5d160405160405180910390a3505050565b6105927f97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b92961023861096f565b806105b557506105a061096f565b6001600160a01b0316826001600160a01b0316145b6106015760405162461bcd60e51b815260206004820152601960248201527f6e6f74206f70657261746f72206f72206465706c6f7965722e0000000000000060448201526064016103fe565b6001600160a01b03821660009081526002602052604081206106239083610a37565b9050806106725760405162461bcd60e51b815260206004820152601060248201527f6661696c656420746f2072656d6f76650000000000000000000000000000000060448201526064016103fe565b816001600160a01b0316836001600160a01b03167ffc5ffe2160301e6b21a86f66febb30fe4e9e6932ac1afc0348fb2fd5daa18b1360405160405180910390a3505050565b60008281526001602052604081206106cf9083610a4c565b9392505050565b60608167ffffffffffffffff8111156106f1576106f1611220565b60405190808252806020026020018201604052801561072457816020015b606081526020019060019003908161070f5790505b50905060005b828110156107c4576107943085858481811061074857610748611236565b905060200281019061075a919061124c565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610a5892505050565b8282815181106107a6576107a6611236565b602002602001018190525080806107bc906112b0565b91505061072a565b5092915050565b600081815260016020526040812061031b90610965565b6000828152602081905260409020600101546108008161036061096f565b61036f8383610a19565b6001600160a01b038116600090815260026020526040902060609061031b90610a7d565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633141561086e575060131936013560601c90565b503390565b905090565b3390565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610411576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556108d761096f565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b60006106cf836001600160a01b038416610a8a565b60006001600160e01b03198216637965db0b60e01b148061031b57506301ffc9a760e01b6001600160e01b031983161461031b565b600061031b825490565b600061087361082e565b6000828152602081815260408083206001600160a01b038516845290915290205460ff16610411576109b5816001600160a01b03166014610ad9565b6109c0836020610ad9565b6040516020016109d19291906112cb565b60408051601f198184030181529082905262461bcd60e51b82526103fe9160040161134c565b610a01828261087c565b600082815260016020526040902061036f908261091b565b610a238282610c82565b600082815260016020526040902061036f90825b60006106cf836001600160a01b038416610d1f565b60006106cf8383610e12565b60606106cf83836040518060600160405280602781526020016113f760279139610e3c565b606060006106cf83610f19565b6000818152600183016020526040812054610ad15750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915561031b565b50600061031b565b60606000610ae883600261135f565b610af390600261137e565b67ffffffffffffffff811115610b0b57610b0b611220565b6040519080825280601f01601f191660200182016040528015610b35576020820181803683370190505b509050600360fc1b81600081518110610b5057610b50611236565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110610b7f57610b7f611236565b60200101906001600160f81b031916908160001a9053506000610ba384600261135f565b610bae90600161137e565b90505b6001811115610c33577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110610bef57610bef611236565b1a60f81b828281518110610c0557610c05611236565b60200101906001600160f81b031916908160001a90535060049490941c93610c2c81611396565b9050610bb1565b5083156106cf5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016103fe565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1615610411576000828152602081815260408083206001600160a01b03851684529091529020805460ff19169055610cdb61096f565b6001600160a01b0316816001600160a01b0316837ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b60405160405180910390a45050565b60008181526001830160205260408120548015610e08576000610d436001836113ad565b8554909150600090610d57906001906113ad565b9050818114610dbc576000866000018281548110610d7757610d77611236565b9060005260206000200154905080876000018481548110610d9a57610d9a611236565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080610dcd57610dcd6113c4565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505061031b565b600091505061031b565b6000826000018281548110610e2957610e29611236565b9060005260206000200154905092915050565b60606001600160a01b0384163b610ea45760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016103fe565b600080856001600160a01b031685604051610ebf91906113da565b600060405180830381855af49150503d8060008114610efa576040519150601f19603f3d011682016040523d82523d6000602084013e610eff565b606091505b5091509150610f0f828286610f75565b9695505050505050565b606081600001805480602002602001604051908101604052809291908181526020018280548015610f6957602002820191906000526020600020905b815481526020019060010190808311610f55575b50505050509050919050565b60608315610f845750816106cf565b825115610f945782518084602001fd5b8160405162461bcd60e51b81526004016103fe919061134c565b600060208284031215610fc057600080fd5b81356001600160e01b0319811681146106cf57600080fd5b80356001600160a01b0381168114610fef57600080fd5b919050565b60006020828403121561100657600080fd5b6106cf82610fd8565b60006020828403121561102157600080fd5b5035919050565b6000806040838503121561103b57600080fd5b8235915061104b60208401610fd8565b90509250929050565b6000806040838503121561106757600080fd5b61107083610fd8565b915061104b60208401610fd8565b6000806040838503121561109157600080fd5b50508035926020909101359150565b600080602083850312156110b357600080fd5b823567ffffffffffffffff808211156110cb57600080fd5b818501915085601f8301126110df57600080fd5b8135818111156110ee57600080fd5b8660208260051b850101111561110357600080fd5b60209290920196919550909350505050565b60005b83811015611130578181015183820152602001611118565b8381111561113f576000848401525b50505050565b6000815180845261115d816020860160208601611115565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156111c657603f198886030184526111b4858351611145565b94509285019290850190600101611198565b5092979650505050505050565b6020808252825182820181905260009190848201906040850190845b818110156112145783516001600160a01b0316835292840192918401916001016111ef565b50909695505050505050565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261126357600080fd5b83018035915067ffffffffffffffff82111561127e57600080fd5b60200191503681900382131561129357600080fd5b9250929050565b634e487b7160e01b600052601160045260246000fd5b60006000198214156112c4576112c461129a565b5060010190565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351611303816017850160208801611115565b7f206973206d697373696e6720726f6c65200000000000000000000000000000006017918401918201528351611340816028840160208801611115565b01602801949350505050565b6020815260006106cf6020830184611145565b60008160001904831182151516156113795761137961129a565b500290565b600082198211156113915761139161129a565b500190565b6000816113a5576113a561129a565b506000190190565b6000828210156113bf576113bf61129a565b500390565b634e487b7160e01b600052603160045260246000fd5b600082516113ec818460208701611115565b919091019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220bcbd7fa7886da2ee105a46e09a3f481d193becac0b7b4afd5779fa6954e292dd64736f6c634300080c0033";
var isSuperArgs3 = /* @__PURE__ */ __name((xs) => xs.length > 1, "isSuperArgs");
var TWRegistry__factory = class extends ContractFactory {
  constructor(...args) {
    if (isSuperArgs3(args)) {
      super(...args);
    } else {
      super(_abi5, _bytecode3, args[0]);
    }
  }
  deploy(_trustedForwarder, overrides) {
    return super.deploy(_trustedForwarder, overrides || {});
  }
  getDeployTransaction(_trustedForwarder, overrides) {
    return super.getDeployTransaction(_trustedForwarder, overrides || {});
  }
  attach(address) {
    return super.attach(address);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new utils.Interface(_abi5);
  }
  static connect(address, signerOrProvider) {
    return new Contract(address, _abi5, signerOrProvider);
  }
};
__name(TWRegistry__factory, "TWRegistry__factory");
__publicField(TWRegistry__factory, "bytecode", _bytecode3);
__publicField(TWRegistry__factory, "abi", _abi5);

// src/common/permit.ts
init_esm_shims();

// src/common/sign.ts
init_esm_shims();
async function signTypedDataInternal(signer, domain, types, message) {
  var _a3, _b2;
  const provider = signer == null ? void 0 : signer.provider;
  if (!provider) {
    throw new Error("missing provider");
  }
  const payload = ethers.utils._TypedDataEncoder.getPayload(domain, types, message);
  let signature = "";
  if ((_a3 = provider == null ? void 0 : provider.provider) == null ? void 0 : _a3.isWalletConnect) {
    signature = await provider.send("eth_signTypedData", [
      (await signer.getAddress()).toLowerCase(),
      JSON.stringify(payload)
    ]);
  } else {
    try {
      signature = await signer._signTypedData(domain, types, message);
    } catch (err) {
      if ((_b2 = err == null ? void 0 : err.message) == null ? void 0 : _b2.includes("Method eth_signTypedData_v4 not supported")) {
        signature = await provider.send("eth_signTypedData", [
          (await signer.getAddress()).toLowerCase(),
          JSON.stringify(payload)
        ]);
      } else {
        throw err;
      }
    }
  }
  return {
    payload,
    signature: ethers.utils.joinSignature(ethers.utils.splitSignature(signature))
  };
}
__name(signTypedDataInternal, "signTypedDataInternal");

// src/common/permit.ts
var NAME_ABI = [
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var DOMAIN_SEPARATOR_ABI = [
  {
    constant: true,
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getDomainSeperator",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var NONCES_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
async function getSignerNonce(signer, contractAddress) {
  const contract = new Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
__name(getSignerNonce, "getSignerNonce");
async function getDomainSeperator(signer, contractAddress) {
  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    return await contract.getDomainSeperator();
  }
}
__name(getDomainSeperator, "getDomainSeperator");
async function getTokenName(signer, contractAddress) {
  return new Contract(contractAddress, NAME_ABI, signer).name();
}
__name(getTokenName, "getTokenName");
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: ethers.utils.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (ethers.utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}
__name(getChainDomainSeperator, "getChainDomainSeperator");
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {
  const domain = await getChainDomainSeperator(signer, {
    name: await getTokenName(signer, currencyAddress),
    version: "1",
    chainId: await signer.getChainId(),
    verifyingContract: currencyAddress
  });
  nonce = nonce ?? (await getSignerNonce(signer, currencyAddress)).toString();
  deadline = deadline ?? ethers.constants.MaxUint256;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types = {
    Permit: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      },
      {
        name: "value",
        type: "uint256"
      },
      {
        name: "nonce",
        type: "uint256"
      },
      {
        name: "deadline",
        type: "uint256"
      }
    ]
  };
  const { signature } = await signTypedDataInternal(signer, domain, types, message);
  return {
    message,
    signature
  };
}
__name(signEIP2612Permit, "signEIP2612Permit");

// src/common/gas-price.ts
init_esm_shims();
function getGasStationUrl(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation-mainnet.matic.network/v2";
    case ChainId.Mumbai:
      return "https://gasstation-mumbai.matic.today/v2";
  }
}
__name(getGasStationUrl, "getGasStationUrl");
var MIN_POLYGON_GAS_PRICE = ethers.utils.parseUnits("31", "gwei");
var MIN_MUMBAI_GAS_PRICE = ethers.utils.parseUnits("1", "gwei");
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return MIN_POLYGON_GAS_PRICE;
    case ChainId.Mumbai:
      return MIN_MUMBAI_GAS_PRICE;
  }
}
__name(getDefaultGasFee, "getDefaultGasFee");
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await fetch(gasStationUrl)).json();
    const priorityFee = data["standard"]["maxPriorityFee"];
    if (priorityFee > 0) {
      const fixedFee = parseFloat(priorityFee).toFixed(9);
      return ethers.utils.parseUnits(fixedFee, "gwei");
    }
  } catch (e) {
    console.error("failed to fetch gas", e);
  }
  return getDefaultGasFee(chainId);
}
__name(getPolygonGasPriorityFee, "getPolygonGasPriorityFee");

// src/core/classes/contract-wrapper.ts
var ContractWrapper = class extends RPCConnectionHandler {
  isValidContract = false;
  customOverrides = () => ({});
  constructor(network, contractAddress, contractAbi, options) {
    super(network, options);
    this.abi = contractAbi;
    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  async getChainID() {
    const provider = this.getProvider();
    const { chainId } = await provider.getNetwork();
    return chainId;
  }
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }
  callStatic() {
    return this.writeContract.callStatic;
  }
  async getCallOverrides() {
    if (isBrowser()) {
      return {};
    }
    const feeData = await this.getProvider().getFeeData();
    const supports1559 = feeData.maxFeePerGas && feeData.maxPriorityFeePerGas;
    if (supports1559) {
      const chainId = await this.getChainID();
      const block = await this.getProvider().getBlock("latest");
      const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : ethers.utils.parseUnits("1", "gwei");
      let defaultPriorityFee;
      if (chainId === ChainId.Mumbai || chainId === ChainId.Polygon) {
        defaultPriorityFee = await getPolygonGasPriorityFee(chainId);
      } else {
        defaultPriorityFee = BigNumber.from(feeData.maxPriorityFeePerGas);
      }
      const maxPriorityFeePerGas = this.getPreferredPriorityFee(defaultPriorityFee);
      const baseMaxFeePerGas = baseBlockFee.mul(2);
      const maxFeePerGas = baseMaxFeePerGas.add(maxPriorityFeePerGas);
      return {
        maxFeePerGas,
        maxPriorityFeePerGas
      };
    } else {
      return {
        gasPrice: await this.getPreferredGasPrice()
      };
    }
  }
  getPreferredPriorityFee(defaultPriorityFeePerGas) {
    const speed = this.options.gasSettings.speed;
    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;
    let extraTip;
    switch (speed) {
      case "standard":
        extraTip = BigNumber.from(0);
        break;
      case "fast":
        extraTip = defaultPriorityFeePerGas.div(100).mul(5);
        break;
      case "fastest":
        extraTip = defaultPriorityFeePerGas.div(100).mul(10);
        break;
    }
    let txGasPrice = defaultPriorityFeePerGas.add(extraTip);
    const max = ethers.utils.parseUnits(maxGasPrice.toString(), "gwei");
    const min = ethers.utils.parseUnits("2.5", "gwei");
    if (txGasPrice.gt(max)) {
      txGasPrice = max;
    }
    if (txGasPrice.lt(min)) {
      txGasPrice = min;
    }
    return txGasPrice;
  }
  async getPreferredGasPrice() {
    const gasPrice = await this.getProvider().getGasPrice();
    const speed = this.options.gasSettings.speed;
    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;
    let txGasPrice = gasPrice;
    let extraTip;
    switch (speed) {
      case "standard":
        extraTip = BigNumber.from(1);
        break;
      case "fast":
        extraTip = gasPrice.div(100).mul(5);
        break;
      case "fastest":
        extraTip = gasPrice.div(100).mul(10);
        break;
    }
    txGasPrice = txGasPrice.add(extraTip);
    const max = ethers.utils.parseUnits(maxGasPrice.toString(), "gwei");
    if (txGasPrice.gt(max)) {
      txGasPrice = max;
    }
    return txGasPrice;
  }
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [
      encoded
    ]);
  }
  async estimateGas(fn, args) {
    return this.writeContract.estimateGas[fn](...args);
  }
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }
  async sendTransaction(fn, args, callOverrides) {
    var _a3;
    if (!this.isValidContract) {
      const code = await this.getProvider().getCode(this.readContract.address);
      this.isValidContract = code !== "0x";
      if (!this.isValidContract) {
        throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
      }
    }
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    callOverrides = __spreadValues(__spreadValues({}, callOverrides), this.customOverrides());
    this.customOverrides = () => ({});
    if (((_a3 = this.options) == null ? void 0 : _a3.gasless) && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless)) {
      const provider = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);
      const receipt = tx.wait();
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }
  async sendTransactionByFunction(fn, args, callOverrides) {
    const func = this.writeContract.functions[fn];
    if (!func) {
      throw new Error(`invalid function: "${fn.toString()}"`);
    }
    try {
      return await func(...args, callOverrides);
    } catch (e) {
      const network = await this.getProvider().getNetwork();
      const signerAddress = await this.getSignerAddress();
      const contractAddress = await this.readContract.address;
      throw await convertToTWError(e, network, signerAddress, contractAddress, this.readContract.interface);
    }
  }
  async sendGaslessTransaction(fn, args = [], callOverrides) {
    const signer = this.getSigner();
    invariant13(signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = (callOverrides == null ? void 0 : callOverrides.value) || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn, args);
    const gasEstimate = await this.writeContract.estimateGas[fn](...args);
    let gas = gasEstimate.mul(2);
    if (gasEstimate.lt(25e3)) {
      gas = BigNumber.from(5e5);
    }
    const tx = {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const { signature: sig } = await signTypedDataInternal(signer, domain, types, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter((x) => x.topics.indexOf(topic) >= 0);
    return parsedLogs.map((l) => this.writeContract.interface.parseLog(l));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    }
    return this.defenderSendFunction(transaction);
  }
  async biconomySendFunction(transaction) {
    var _a3, _b2;
    invariant13(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant13(signer && provider, "signer and provider must be set");
    const forwarder = new ethers.Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [
      transaction.from,
      batchId
    ]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: ethers.constants.AddressZero,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1e3 + (((_a3 = this.options) == null ? void 0 : _a3.gasless) && "biconomy" in this.options.gasless && ((_b2 = this.options.gasless.biconomy) == null ? void 0 : _b2.deadlineSeconds) || 3600)),
      data: transaction.data
    };
    const hashToSign = ethers.utils.arrayify(ethers.utils.solidityKeccak256([
      "address",
      "address",
      "address",
      "uint256",
      "uint256",
      "uint256",
      "uint256",
      "uint256",
      "bytes32"
    ], [
      request.from,
      request.to,
      request.token,
      request.txGas,
      request.tokenGasPrice,
      request.batchId,
      request.batchNonce,
      request.deadline,
      ethers.utils.keccak256(request.data)
    ]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature
    });
    const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [
          request,
          signature
        ],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    invariant13(this.options.gasless && "openzeppelin" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant13(signer, "provider is not set");
    invariant13(provider, "provider is not set");
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress;
    const forwarder = Forwarder__factory.connect(forwarderAddress, provider);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [
      transaction.from
    ]);
    const domain = {
      name: "GSNv2 Forwarder",
      version: "0.0.1",
      chainId: transaction.chainId,
      verifyingContract: forwarderAddress
    };
    const types = {
      ForwardRequest
    };
    let message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data
    };
    let signature;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      const { message: permit, signature: sig } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);
      const { r, s, v } = ethers.utils.splitSignature(sig);
      message = {
        to: this.readContract.address,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString(),
        r,
        s,
        v
      };
      signature = sig;
    } else {
      const { signature: sig } = await signTypedDataInternal(signer, domain, types, message);
      signature = sig;
    }
    let messageType = "forward";
    if (message == null ? void 0 : message.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature
    });
    const response = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
};
__name(ContractWrapper, "ContractWrapper");

// abis/IERC20Metadata.json
var IERC20Metadata_default = [
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/common/currency.ts
function isNativeToken(tokenAddress) {
  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === constants.AddressZero;
}
__name(isNativeToken, "isNativeToken");
async function normalizePriceValue(provider, inputPrice, currencyAddress) {
  const metadata = await fetchCurrencyMetadata(provider, currencyAddress);
  return utils.parseUnits(PriceSchema.parse(inputPrice), metadata.decimals);
}
__name(normalizePriceValue, "normalizePriceValue");
async function fetchCurrencyMetadata(provider, asset) {
  if (isNativeToken(asset)) {
    const network = await provider.getNetwork();
    const nativeToken = getNativeTokenByChainId(network.chainId);
    return {
      name: nativeToken.name,
      symbol: nativeToken.symbol,
      decimals: nativeToken.decimals
    };
  } else {
    const erc20 = new Contract(asset, IERC20Metadata_default, provider);
    const [name, symbol, decimals] = await Promise.all([
      erc20.name(),
      erc20.symbol(),
      erc20.decimals()
    ]);
    return {
      name,
      symbol,
      decimals
    };
  }
}
__name(fetchCurrencyMetadata, "fetchCurrencyMetadata");
async function fetchCurrencyValue(providerOrSigner, asset, price) {
  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);
  return __spreadProps(__spreadValues({}, metadata), {
    value: BigNumber.from(price),
    displayValue: utils.formatUnits(price, metadata.decimals)
  });
}
__name(fetchCurrencyValue, "fetchCurrencyValue");
async function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {
  if (isNativeToken(currencyAddress)) {
    overrides["value"] = value;
  } else {
    const signer = contractToApprove.getSigner();
    const provider = contractToApprove.getProvider();
    const erc20 = new ContractWrapper(signer || provider, currencyAddress, IERC20_default, {});
    const owner = await contractToApprove.getSignerAddress();
    const spender = contractToApprove.readContract.address;
    const allowance = await erc20.readContract.allowance(owner, spender);
    if (allowance.lt(value)) {
      await erc20.sendTransaction("approve", [
        spender,
        value
      ]);
    }
    return overrides;
  }
}
__name(setErc20Allowance, "setErc20Allowance");
async function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {
  const signer = contractToApprove.getSigner();
  const provider = contractToApprove.getProvider();
  const erc20 = new ContractWrapper(signer || provider, currencyAddress, IERC20_default, {});
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.readContract.address;
  const allowance = await erc20.readContract.allowance(owner, spender);
  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(ethers.utils.parseUnits("1", tokenDecimals));
  if (allowance.lt(totalPrice)) {
    await erc20.sendTransaction("approve", [
      spender,
      allowance.add(totalPrice)
    ]);
  }
}
__name(approveErc20Allowance, "approveErc20Allowance");
async function hasERC20Allowance(contractToApprove, currencyAddress, value) {
  const provider = contractToApprove.getProvider();
  const erc20 = new ContractWrapper(provider, currencyAddress, IERC20_default, {});
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.readContract.address;
  const allowance = await erc20.readContract.allowance(owner, spender);
  return allowance.gte(value);
}
__name(hasERC20Allowance, "hasERC20Allowance");

// src/enums/marketplace/ListingType.ts
init_esm_shims();
var ListingType;
(function(ListingType2) {
  ListingType2[ListingType2["Direct"] = 0] = "Direct";
  ListingType2[ListingType2["Auction"] = 1] = "Auction";
})(ListingType || (ListingType = {}));

// src/enums/vote/ProposalState.ts
init_esm_shims();
var ProposalState;
(function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
})(ProposalState || (ProposalState = {}));

// src/enums/vote/Vote.ts
init_esm_shims();
var VoteType;
(function(VoteType2) {
  VoteType2[VoteType2["Against"] = 0] = "Against";
  VoteType2[VoteType2["For"] = 1] = "For";
  VoteType2[VoteType2["Abstain"] = 2] = "Abstain";
})(VoteType || (VoteType = {}));

// src/enums/ClaimEligibility.ts
init_esm_shims();
var ClaimEligibility;
(function(ClaimEligibility2) {
  ClaimEligibility2["NotEnoughSupply"] = "There is not enough supply to claim.";
  ClaimEligibility2["AddressNotAllowed"] = "This address is not on the allowlist.";
  ClaimEligibility2["WaitBeforeNextClaimTransaction"] = "Not enough time since last claim transaction. Please wait.";
  ClaimEligibility2["AlreadyClaimed"] = "You have already claimed the token.";
  ClaimEligibility2["NotEnoughTokens"] = "There are not enough tokens in the wallet to pay for the claim.";
  ClaimEligibility2["NoActiveClaimPhase"] = "There is no active claim phase at the moment. Please check back in later.";
  ClaimEligibility2["NoClaimConditionSet"] = "There is no claim condition set.";
  ClaimEligibility2["NoWallet"] = "No wallet connected.";
  ClaimEligibility2["Unknown"] = "No claim conditions found.";
})(ClaimEligibility || (ClaimEligibility = {}));

// src/common/claim-conditions.ts
init_esm_shims();
async function prepareClaim(quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance) {
  const addressToClaim = await contractWrapper.getSignerAddress();
  let maxClaimable = BigNumber.from(0);
  let proofs = [
    utils.hexZeroPad([
      0
    ], 32)
  ];
  try {
    if (!activeClaimCondition.merkleRootHash.toString().startsWith(constants.AddressZero)) {
      const claims = await fetchSnapshot(activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), storage);
      const item = claims && claims.find((c) => c.address.toLowerCase() === addressToClaim.toLowerCase());
      if (item === void 0) {
        throw new Error("No claim found for this address");
      }
      proofs = item.proof;
      maxClaimable = ethers.utils.parseUnits(item.maxClaimable, tokenDecimals);
    }
  } catch (e) {
    if ((e == null ? void 0 : e.message) === "No claim found for this address") {
      throw e;
    }
    console.warn("failed to check claim condition merkle root hash, continuing anyways", e);
  }
  const overrides = await contractWrapper.getCallOverrides() || {};
  const price = activeClaimCondition.price;
  const currencyAddress = activeClaimCondition.currencyAddress;
  if (price.gt(0)) {
    if (isNativeToken(currencyAddress)) {
      overrides["value"] = BigNumber.from(price).mul(quantity).div(ethers.utils.parseUnits("1", tokenDecimals));
    } else if (checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currencyAddress, price, quantity, tokenDecimals);
    }
  }
  return {
    overrides,
    proofs,
    maxQuantityPerTransaction: maxClaimable,
    price,
    currencyAddress
  };
}
__name(prepareClaim, "prepareClaim");
async function fetchSnapshot(merkleRoot, merkleMetadata, storage) {
  const snapshotUri = merkleMetadata[merkleRoot];
  let snapshot = void 0;
  if (snapshotUri) {
    const raw = await storage.get(snapshotUri);
    const snapshotData = SnapshotSchema.parse(raw);
    if (merkleRoot === snapshotData.merkleRoot) {
      snapshot = snapshotData.claims;
    }
  }
  return snapshot;
}
__name(fetchSnapshot, "fetchSnapshot");
async function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {
  if (index >= existingConditions.length) {
    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);
  }
  const priceDecimals = existingConditions[index].currencyMetadata.decimals;
  const priceInWei = existingConditions[index].price;
  const priceInTokens = ethers.utils.formatUnits(priceInWei, priceDecimals);
  const newConditionParsed = ClaimConditionInputSchema.parse(__spreadValues(__spreadProps(__spreadValues({}, existingConditions[index]), {
    price: priceInTokens
  }), claimConditionInput));
  const mergedConditionOutput = ClaimConditionOutputSchema.parse(__spreadProps(__spreadValues({}, newConditionParsed), {
    price: priceInWei
  }));
  return existingConditions.map((existingOutput, i) => {
    let newConditionAtIndex;
    if (i === index) {
      newConditionAtIndex = mergedConditionOutput;
    } else {
      newConditionAtIndex = existingOutput;
    }
    const formattedPrice = ethers.utils.formatUnits(newConditionAtIndex.price, priceDecimals);
    return __spreadProps(__spreadValues({}, newConditionAtIndex), {
      price: formattedPrice
    });
  });
}
__name(updateExistingClaimConditions, "updateExistingClaimConditions");
async function getClaimerProofs(addressToClaim, merkleRoot, tokenDecimals, merkleMetadata, storage) {
  const claims = await fetchSnapshot(merkleRoot, merkleMetadata, storage);
  if (claims === void 0) {
    return {
      proof: [],
      maxClaimable: BigNumber.from(0)
    };
  }
  const item = claims.find((c) => c.address.toLowerCase() === (addressToClaim == null ? void 0 : addressToClaim.toLowerCase()));
  if (item === void 0) {
    return {
      proof: [],
      maxClaimable: BigNumber.from(0)
    };
  }
  return {
    proof: item.proof,
    maxClaimable: ethers.utils.parseUnits(item.maxClaimable, tokenDecimals)
  };
}
__name(getClaimerProofs, "getClaimerProofs");
async function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage) {
  const snapshotInfos = [];
  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async (conditionInput) => {
    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {
      const snapshotInfo = await createSnapshot(SnapshotInputSchema.parse(conditionInput.snapshot), tokenDecimals, storage);
      snapshotInfos.push(snapshotInfo);
      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;
    } else {
      conditionInput.merkleRootHash = utils.hexZeroPad([
        0
      ], 32);
    }
    return conditionInput;
  }));
  const parsedInputs = ClaimConditionInputArray.parse(inputsWithSnapshots);
  const sortedConditions = (await Promise.all(parsedInputs.map((c) => convertToContractModel(c, tokenDecimals, provider)))).sort((a, b) => {
    const left = BigNumber.from(a.startTimestamp);
    const right = BigNumber.from(b.startTimestamp);
    if (left.eq(right)) {
      return 0;
    } else if (left.gt(right)) {
      return 1;
    } else {
      return -1;
    }
  });
  return {
    snapshotInfos,
    sortedConditions
  };
}
__name(processClaimConditionInputs, "processClaimConditionInputs");
async function convertToContractModel(c, tokenDecimals, provider) {
  const currency = c.currencyAddress === constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;
  let maxClaimableSupply;
  let quantityLimitPerTransaction;
  if (c.maxQuantity === "unlimited") {
    maxClaimableSupply = ethers.constants.MaxUint256.toString();
  } else {
    maxClaimableSupply = ethers.utils.parseUnits(c.maxQuantity, tokenDecimals);
  }
  if (c.quantityLimitPerTransaction === "unlimited") {
    quantityLimitPerTransaction = ethers.constants.MaxUint256.toString();
  } else {
    quantityLimitPerTransaction = ethers.utils.parseUnits(c.quantityLimitPerTransaction, tokenDecimals);
  }
  return {
    startTimestamp: c.startTime,
    maxClaimableSupply,
    supplyClaimed: 0,
    quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: c.waitInSeconds,
    pricePerToken: await normalizePriceValue(provider, c.price, currency),
    currency,
    merkleRoot: c.merkleRootHash
  };
}
__name(convertToContractModel, "convertToContractModel");
async function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage) {
  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);
  const claims = await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage);
  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);
  const quantityLimitPerTransaction = convertToReadableQuantity(pm.quantityLimitPerTransaction, tokenDecimals);
  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);
  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);
  return ClaimConditionOutputSchema.parse({
    startTime: pm.startTimestamp,
    maxQuantity: maxClaimableSupply,
    currentMintSupply,
    availableSupply,
    quantityLimitPerTransaction,
    waitInSeconds: pm.waitTimeInSecondsBetweenClaims.toString(),
    price: BigNumber.from(pm.pricePerToken),
    currency: pm.currency,
    currencyAddress: pm.currency,
    currencyMetadata: cv,
    merkleRootHash: pm.merkleRoot,
    snapshot: claims
  });
}
__name(transformResultToClaimCondition, "transformResultToClaimCondition");
function convertToReadableQuantity(bn, tokenDecimals) {
  if (bn.toString() === ethers.constants.MaxUint256.toString()) {
    return "unlimited";
  } else {
    return ethers.utils.formatUnits(bn, tokenDecimals);
  }
}
__name(convertToReadableQuantity, "convertToReadableQuantity");

// src/schema/contracts/drop-erc721.ts
init_esm_shims();
var DropErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc721ContractDeploy = DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};

// src/schema/contracts/drop-erc1155.ts
init_esm_shims();
var DropErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc1155ContractDeploy = DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};

// src/schema/contracts/marketplace.ts
init_esm_shims();
var MarketplaceContractInput = CommonContractSchema;
var MarketplaceContractOutput = CommonContractOutputSchema;
var MarketplaceContractDeploy = MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
var MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};

// src/schema/contracts/packs.ts
init_esm_shims();
var PackContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var PackContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var PackContractDeploy = PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
var PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};

// src/schema/contracts/splits.ts
init_esm_shims();
var SplitRecipientInputSchema = z.object({
  address: AddressSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
});
var SplitRecipientOuputSchema = SplitRecipientInputSchema.extend({
  address: AddressSchema,
  sharesBps: BasisPointsSchema
});
var SplitsContractInput = CommonContractSchema.extend({
  recipients: z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index = 0; index < val.length; index++) {
      const entry = val[index];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [
            index,
            `address`
          ]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 1e4) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [
            index,
            `sharesBps`
          ]
        });
      }
    }
    if (totalShares !== 1e4) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
});
var SplitsContractOutput = CommonContractOutputSchema.extend({
  recipients: z.array(SplitRecipientOuputSchema)
});
var SplitsContractDeploy = SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);
var SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};

// src/schema/contracts/token-erc20.ts
init_esm_shims();
var TokenErc20ContractInput = CommonContractSchema.merge(CommonSymbolSchema);
var TokenErc20ContractOutput = CommonContractOutputSchema.merge(CommonSymbolSchema);
var TokenErc20ContractDeploy = TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};

// src/schema/contracts/token-erc721.ts
init_esm_shims();
var TokenErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc721ContractDeploy = TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};

// src/schema/contracts/token-erc1155.ts
init_esm_shims();
var TokenErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc1155ContractDeploy = TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};

// src/schema/contracts/vote.ts
init_esm_shims();
var VoteSettingsInputSchema = z.object({
  voting_delay_in_blocks: z.number().min(0).default(0),
  voting_period_in_blocks: z.number().min(1).default(1),
  voting_token_address: AddressSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
});
var VoteSettingsOuputSchema = VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema
});
var VoteContractInput = CommonContractSchema.merge(VoteSettingsInputSchema);
var VoteContractOutput = CommonContractOutputSchema.merge(VoteSettingsOuputSchema);
var VoteContractDeploy = VoteContractInput.merge(CommonTrustedForwarderSchema);
var VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
z.object({
  proposalId: BigNumberSchema,
  proposer: z.string(),
  targets: z.array(z.string()),
  values: z.array(BigNumberSchema),
  signatures: z.array(z.string()),
  calldatas: z.array(z.string()),
  startBlock: BigNumberSchema,
  endBlock: BigNumberSchema,
  description: z.string()
});

// src/schema/tokens/pack.ts
init_esm_shims();

// src/schema/tokens/common/wrap.ts
init_esm_shims();
var CommonWrappableSchema = z.object({
  contractAddress: AddressSchema
});
var ERC20WrappableSchema = CommonWrappableSchema.extend({
  quantity: PriceSchema
});
var ERC721WrappableSchema = CommonWrappableSchema.extend({
  tokenId: BigNumberishSchema
});
var ERC1155WrappableSchema = CommonWrappableSchema.extend({
  tokenId: BigNumberishSchema,
  quantity: BigNumberishSchema
});

// src/schema/tokens/pack.ts
var ERC20RewardSchema = ERC20WrappableSchema.omit({
  quantity: true
}).extend({
  quantityPerReward: PriceSchema
});
var ERC721RewardSchema = ERC721WrappableSchema;
var ERC1155RewardSchema = ERC1155WrappableSchema.omit({
  quantity: true
}).extend({
  quantityPerReward: BigNumberishSchema
});
var ERC20RewardContentsSchema = ERC20RewardSchema.extend({
  totalRewards: BigNumberishSchema.default("1")
});
var ERC721RewardContentsSchema = ERC721RewardSchema;
var ERC1155RewardContentsSchema = ERC1155RewardSchema.extend({
  totalRewards: BigNumberishSchema.default("1")
});
z.object({
  erc20Rewards: z.array(ERC20RewardSchema).default([]),
  erc721Rewards: z.array(ERC721RewardSchema).default([]),
  erc1155Rewards: z.array(ERC1155RewardSchema).default([])
});
var PackRewardsOutputSchema = z.object({
  erc20Rewards: z.array(ERC20RewardContentsSchema).default([]),
  erc721Rewards: z.array(ERC721RewardContentsSchema).default([]),
  erc1155Rewards: z.array(ERC1155RewardContentsSchema).default([])
});
var PackMetadataInputSchema = PackRewardsOutputSchema.extend({
  packMetadata: NFTInputOrUriSchema,
  rewardsPerPack: BigNumberishSchema.default("1"),
  openStartTime: RawDateSchema.default(new Date())
});
var DropClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getActive() {
    const cc = await this.get();
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(cc, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage);
  }
  async get() {
    if (this.isSinglePhaseDropContract(this.contractWrapper)) {
      return await this.contractWrapper.readContract.claimCondition();
    } else if (this.isMultiPhaseDropContract(this.contractWrapper)) {
      const id = await this.contractWrapper.readContract.getActiveClaimConditionId();
      return await this.contractWrapper.readContract.getClaimConditionById(id);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  async getAll() {
    if (this.isMultiPhaseDropContract(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.readContract.claimCondition();
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(await this.contractWrapper.readContract.getClaimConditionById(i));
      }
      const metadata = await this.metadata.get();
      const decimals = await this.getTokenDecimals();
      return Promise.all(conditions.map((c) => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage)));
    } else {
      return [
        await this.getActive()
      ];
    }
  }
  async canClaim(quantity, addressToCheck) {
    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;
  }
  async getClaimIneligibilityReasons(quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    const decimals = await this.getTokenDecimals();
    const quantityWithDecimals = ethers.utils.parseUnits(PriceSchema.parse(quantity), decimals);
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [
        ClaimEligibility.NoWallet
      ];
    }
    try {
      claimCondition = await this.getActive();
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      console.log("failed to get active claim condition", err);
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      const supplyWithDecimals = ethers.utils.parseUnits(claimCondition.availableSupply, decimals);
      if (supplyWithDecimals.lt(quantityWithDecimals)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
      }
    }
    const merkleRootArray = ethers.utils.stripZeros(claimCondition.merkleRootHash);
    if (merkleRootArray.length > 0) {
      const merkleLower = claimCondition.merkleRootHash.toString();
      const metadata = await this.metadata.get();
      const proofs = await getClaimerProofs(addressToCheck, merkleLower, await this.getTokenDecimals(), metadata.merkle, this.storage);
      try {
        let validMerkleProof;
        if (this.isMultiPhaseDropContract(this.contractWrapper)) {
          activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
          [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, addressToCheck, quantity, proofs.proof, proofs.maxClaimable);
        } else if (this.isSinglePhaseDropContract(this.contractWrapper)) {
          [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(addressToCheck, quantity, {
            proof: proofs.proof,
            maxQuantityInAllowlist: proofs.maxClaimable
          });
        }
        if (!validMerkleProof) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      } catch (e) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
    }
    let [lastClaimedTimestamp, timestampForNextClaim] = [
      BigNumber.from(0),
      BigNumber.from(0)
    ];
    if (this.isMultiPhaseDropContract(this.contractWrapper)) {
      activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(activeConditionIndex, addressToCheck);
    } else if (this.isSinglePhaseDropContract(this.contractWrapper)) {
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(addressToCheck);
    }
    const now = BigNumber.from(Date.now()).div(1e3);
    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
      if (timestampForNextClaim.eq(constants.MaxUint256)) {
        reasons.push(ClaimEligibility.AlreadyClaimed);
      } else {
        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));
      const provider = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider.getBalance(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, IERC20_default, {});
        const balance = await erc20.readContract.balanceOf(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  async set(claimConditionInputs, resetClaimEligibilityForAll = false) {
    let claimConditionsProcessed = claimConditionInputs;
    if (this.isSinglePhaseDropContract(this.contractWrapper)) {
      resetClaimEligibilityForAll = true;
      if (claimConditionInputs.length === 0) {
        claimConditionsProcessed = [
          {
            startTime: new Date(0),
            currencyAddress: NATIVE_TOKEN_ADDRESS,
            price: 0,
            maxQuantity: 0,
            quantityLimitPerTransaction: 0,
            waitInSeconds: 0,
            merkleRootHash: utils.hexZeroPad([
              0
            ], 32),
            snapshot: []
          }
        ];
      } else if (claimConditionInputs.length > 1) {
        throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
      }
    }
    const { snapshotInfos, sortedConditions } = await processClaimConditionInputs(claimConditionsProcessed, await this.getTokenDecimals(), this.contractWrapper.getProvider(), this.storage);
    const merkleInfo = {};
    snapshotInfos.forEach((s) => {
      merkleInfo[s.merkleRoot] = s.snapshotUri;
    });
    const metadata = await this.metadata.get();
    const encoded = [];
    if (!deepEqual(metadata.merkle, merkleInfo)) {
      const mergedMetadata = this.metadata.parseInputMetadata(__spreadProps(__spreadValues({}, metadata), {
        merkle: merkleInfo
      }));
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [
          contractURI
        ]));
      } else {
        throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
      }
    }
    const cw = this.contractWrapper;
    if (this.isSinglePhaseDropContract(cw)) {
      encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [
        sortedConditions[0],
        resetClaimEligibilityForAll
      ]));
    } else if (this.isMultiPhaseDropContract(cw)) {
      encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [
        sortedConditions,
        resetClaimEligibilityForAll
      ]));
    } else {
      throw new Error("Contract does not support claim conditions");
    }
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async update(index, claimConditionInput) {
    const existingConditions = await this.getAll();
    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
    return await this.set(newConditionInputs);
  }
  async getTokenDecimals() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return this.contractWrapper.readContract.decimals();
    } else {
      return Promise.resolve(0);
    }
  }
  async prepareClaim(quantity, checkERC20Allowance, decimals = 0) {
    return prepareClaim(quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance);
  }
  isSinglePhaseDropContract(contractWrapper) {
    return !hasFunction("getClaimConditionById", contractWrapper);
  }
  isMultiPhaseDropContract(contractWrapper) {
    return hasFunction("getClaimConditionById", contractWrapper);
  }
};
__name(DropClaimConditions, "DropClaimConditions");

// src/core/classes/drop-erc1155-claim-conditions.ts
init_esm_shims();
var DropErc1155ClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getActive(tokenId) {
    const mc = await this.get(tokenId);
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage);
  }
  async get(tokenId) {
    if (this.isSinglePhaseDropContract(this.contractWrapper)) {
      return await this.contractWrapper.readContract.claimCondition(tokenId);
    } else if (this.isMultiPhaseDropContract(this.contractWrapper)) {
      const id = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      return await this.contractWrapper.readContract.getClaimConditionById(tokenId, id);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  async getAll(tokenId) {
    if (this.isMultiPhaseDropContract(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.readContract.claimCondition(tokenId);
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(await this.contractWrapper.readContract.getClaimConditionById(tokenId, i));
      }
      const metadata = await this.metadata.get();
      return Promise.all(conditions.map((c) => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage)));
    } else {
      return [
        await this.getActive(tokenId)
      ];
    }
  }
  async canClaim(tokenId, quantity, addressToCheck) {
    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;
  }
  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [
        ClaimEligibility.NoWallet
      ];
    }
    try {
      claimCondition = await this.getActive(tokenId);
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
      }
    }
    const merkleRootArray = ethers.utils.stripZeros(claimCondition.merkleRootHash);
    if (merkleRootArray.length > 0) {
      const merkleLower = claimCondition.merkleRootHash.toString();
      const metadata = await this.metadata.get();
      const proofs = await getClaimerProofs(addressToCheck, merkleLower, 0, metadata.merkle, this.storage);
      try {
        let validMerkleProof;
        if (this.isMultiPhaseDropContract(this.contractWrapper)) {
          activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
          [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, addressToCheck, tokenId, quantity, proofs.proof, proofs.maxClaimable);
        } else if (this.isSinglePhaseDropContract(this.contractWrapper)) {
          [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(tokenId, addressToCheck, quantity, {
            proof: proofs.proof,
            maxQuantityInAllowlist: proofs.maxClaimable
          });
        }
        if (!validMerkleProof) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      } catch (e) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
    }
    let [lastClaimedTimestamp, timestampForNextClaim] = [
      BigNumber.from(0),
      BigNumber.from(0)
    ];
    if (this.isMultiPhaseDropContract(this.contractWrapper)) {
      activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, activeConditionIndex, addressToCheck);
    } else if (this.isSinglePhaseDropContract(this.contractWrapper)) {
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, addressToCheck);
    }
    const now = BigNumber.from(Date.now()).div(1e3);
    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
      if (timestampForNextClaim.eq(constants.MaxUint256)) {
        reasons.push(ClaimEligibility.AlreadyClaimed);
      } else {
        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(quantity);
      const provider = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider.getBalance(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, IERC20__factory.abi, {});
        const balance = await erc20.readContract.balanceOf(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  async set(tokenId, claimConditionInputs, resetClaimEligibilityForAll = false) {
    return this.setBatch([
      {
        tokenId,
        claimConditions: claimConditionInputs
      }
    ], resetClaimEligibilityForAll);
  }
  async setBatch(claimConditionsForToken, resetClaimEligibilityForAll = false) {
    const merkleInfo = {};
    const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async ({ tokenId, claimConditions }) => {
      let claimConditionsProcessed = claimConditions;
      if (this.isSinglePhaseDropContract(this.contractWrapper)) {
        resetClaimEligibilityForAll = true;
        if (claimConditions.length === 0) {
          claimConditionsProcessed = [
            {
              startTime: new Date(0),
              currencyAddress: NATIVE_TOKEN_ADDRESS,
              price: 0,
              maxQuantity: 0,
              quantityLimitPerTransaction: 0,
              waitInSeconds: 0,
              merkleRootHash: utils.hexZeroPad([
                0
              ], 32),
              snapshot: []
            }
          ];
        } else if (claimConditions.length > 1) {
          throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
        }
      }
      const { snapshotInfos, sortedConditions } = await processClaimConditionInputs(claimConditionsProcessed, 0, this.contractWrapper.getProvider(), this.storage);
      snapshotInfos.forEach((s) => {
        merkleInfo[s.merkleRoot] = s.snapshotUri;
      });
      return {
        tokenId,
        sortedConditions
      };
    }));
    const metadata = await this.metadata.get();
    const encoded = [];
    for (const key of Object.keys(metadata.merkle)) {
      merkleInfo[key] = metadata.merkle[key];
    }
    if (!deepEqual(metadata.merkle, merkleInfo)) {
      const mergedMetadata = this.metadata.parseInputMetadata(__spreadProps(__spreadValues({}, metadata), {
        merkle: merkleInfo
      }));
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [
          contractURI
        ]));
      } else {
        throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
      }
    }
    processedClaimConditions.forEach(({ tokenId, sortedConditions }) => {
      if (this.isSinglePhaseDropContract(this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [
          tokenId,
          sortedConditions[0],
          resetClaimEligibilityForAll
        ]));
      } else if (this.isMultiPhaseDropContract(this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [
          tokenId,
          sortedConditions,
          resetClaimEligibilityForAll
        ]));
      } else {
        throw new Error("Contract does not support claim conditions");
      }
    });
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async update(tokenId, index, claimConditionInput) {
    const existingConditions = await this.getAll(tokenId);
    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
    return await this.set(tokenId, newConditionInputs);
  }
  async prepareClaim(tokenId, quantity, checkERC20Allowance) {
    return prepareClaim(quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance);
  }
  isSinglePhaseDropContract(contractWrapper) {
    return !hasFunction("getClaimConditionById", contractWrapper);
  }
  isMultiPhaseDropContract(contractWrapper) {
    return hasFunction("getClaimConditionById", contractWrapper);
  }
};
__name(DropErc1155ClaimConditions, "DropErc1155ClaimConditions");

// src/core/classes/drop-erc1155-history.ts
init_esm_shims();
var DropErc1155History = class {
  constructor(events) {
    this.events = events;
  }
  async getAllClaimerAddresses(tokenId) {
    const a = (await this.events.getEvents("TokensClaimed")).filter((e) => e.data && BigNumber.isBigNumber(e.data.tokenId) ? e.data.tokenId.eq(tokenId) : false);
    return Array.from(new Set(a.filter((b) => {
      var _a3;
      return typeof ((_a3 = b.data) == null ? void 0 : _a3.claimer) === "string";
    }).map((b) => b.data.claimer)));
  }
};
__name(DropErc1155History, "DropErc1155History");

// src/core/classes/erc-20.ts
init_esm_shims();

// src/core/classes/erc-20-mintable.ts
init_esm_shims();

// src/core/classes/erc-20-batch-mintable.ts
init_esm_shims();
var Erc20BatchMintable = class {
  featureName = FEATURE_TOKEN_BATCH_MINTABLE.name;
  constructor(erc20, contractWrapper) {
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
  async to(args) {
    const encoded = [];
    for (const arg of args) {
      encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [
        arg.toAddress,
        await this.erc20.normalizeAmount(arg.amount)
      ]));
    }
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
};
__name(Erc20BatchMintable, "Erc20BatchMintable");

// src/core/classes/erc-20-mintable.ts
var Erc20Mintable = class {
  featureName = FEATURE_TOKEN_MINTABLE.name;
  constructor(erc20, contractWrapper) {
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.batch = this.detectErc20BatchMintable();
  }
  async to(to, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("mintTo", [
        to,
        await this.erc20.normalizeAmount(amount)
      ])
    };
  }
  detectErc20BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20BatchMintable")) {
      return new Erc20BatchMintable(this.erc20, this.contractWrapper);
    }
    return void 0;
  }
};
__name(Erc20Mintable, "Erc20Mintable");

// src/core/classes/erc-20-signature-mintable.ts
init_esm_shims();
var Erc20SignatureMintable = class {
  featureName = FEATURE_TOKEN_SIGNATURE_MINTABLE.name;
  constructor(contractWrapper, roles) {
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  async mint(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("mintWithSignature", [
        message,
        signature
      ], overrides)
    };
  }
  async mintBatch(signedPayloads) {
    const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
      const message = await this.mapPayloadToContractStruct(s.payload);
      const signature = s.signature;
      const price = s.payload.price;
      if (BigNumber.from(price).gt(0)) {
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      }
      return {
        message,
        signature
      };
    }));
    const encoded = contractPayloads.map((p) => {
      return this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [
        p.message,
        p.signature
      ]);
    });
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.readContract.verify(message, signature);
    return verification[0];
  }
  async generate(mintRequest) {
    return (await this.generateBatch([
      mintRequest
    ]))[0];
  }
  async generateBatch(payloadsToSign) {
    var _a3;
    await ((_a3 = this.roles) == null ? void 0 : _a3.verify([
      "minter"
    ], await this.contractWrapper.getSignerAddress()));
    const parsedRequests = payloadsToSign.map((m) => Signature20PayloadInput.parse(m));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant13(signer, "No signer available");
    const name = await this.contractWrapper.readContract.name();
    return await Promise.all(parsedRequests.map(async (m) => {
      const finalPayload = Signature20PayloadOutput.parse(m);
      const signature = await this.contractWrapper.signTypedData(signer, {
        name,
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.readContract.address
      }, {
        MintRequest: MintRequest20
      }, await this.mapPayloadToContractStruct(finalPayload));
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    const amountWithDecimals = ethers.utils.parseUnits(mintRequest.quantity, await this.contractWrapper.readContract.decimals());
    return {
      to: mintRequest.to,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      quantity: amountWithDecimals,
      price: normalizedPrice,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid
    };
  }
};
__name(Erc20SignatureMintable, "Erc20SignatureMintable");

// src/core/classes/erc-20-burnable.ts
init_esm_shims();
var Erc20Burnable = class {
  featureName = FEATURE_TOKEN_BURNABLE.name;
  constructor(erc20, contractWrapper) {
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
  async tokens(amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burn", [
        await this.erc20.normalizeAmount(amount)
      ])
    };
  }
  async from(holder, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burnFrom", [
        holder,
        await this.erc20.normalizeAmount(amount)
      ])
    };
  }
};
__name(Erc20Burnable, "Erc20Burnable");

// src/core/classes/erc-20-droppable.ts
init_esm_shims();
var Erc20Droppable = class {
  featureName = FEATURE_TOKEN_DROPPABLE.name;
  constructor(erc20, contractWrapper, storage) {
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.claimConditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
  async claimTo(destinationAddress, amount, checkERC20Allowance = true, claimData) {
    const quantity = await this.erc20.normalizeAmount(amount);
    let claimVerification = claimData;
    if (this.claimConditions && !claimData) {
      claimVerification = await this.claimConditions.prepareClaim(quantity, checkERC20Allowance, await this.contractWrapper.readContract.decimals());
    }
    if (!claimVerification) {
      throw new Error("Claim verification Data is required - either pass it in as 'claimData' or set claim conditions via 'conditions.set()'");
    }
    const receipt = await this.contractWrapper.sendTransaction("claim", [
      destinationAddress,
      quantity,
      claimVerification.currencyAddress,
      claimVerification.price,
      claimVerification.proofs,
      claimVerification.maxQuantityPerTransaction
    ], claimVerification.overrides);
    return {
      receipt
    };
  }
};
__name(Erc20Droppable, "Erc20Droppable");

// src/core/classes/erc-20.ts
var Erc20 = class {
  featureName = FEATURE_TOKEN.name;
  constructor(contractWrapper, storage, options = {}) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid contract options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    this.mint = this.detectErc20Mintable();
    this.burn = this.detectErc20Burnable();
    this.drop = this.detectErc20Droppable();
    this.signature = this.detectErc20SignatureMintable();
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get() {
    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async balanceOf(address) {
    return this.getValue(await this.contractWrapper.readContract.balanceOf(address));
  }
  async totalSupply() {
    return await this.getValue(await this.contractWrapper.readContract.totalSupply());
  }
  async allowance(spender) {
    return await this.allowanceOf(await this.contractWrapper.getSignerAddress(), spender);
  }
  async allowanceOf(owner, spender) {
    return await this.getValue(await this.contractWrapper.readContract.allowance(owner, spender));
  }
  async transfer(to, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("transfer", [
        to,
        await this.normalizeAmount(amount)
      ])
    };
  }
  async transferFrom(from, to, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("transferFrom", [
        from,
        to,
        await this.normalizeAmount(amount)
      ])
    };
  }
  async setAllowance(spender, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("approve", [
        spender,
        await this.normalizeAmount(amount)
      ])
    };
  }
  async transferBatch(args) {
    const encoded = await Promise.all(args.map(async (arg) => {
      const amountWithDecimals = await this.normalizeAmount(arg.amount);
      return this.contractWrapper.readContract.interface.encodeFunctionData("transfer", [
        arg.toAddress,
        amountWithDecimals
      ]);
    }));
    await this.contractWrapper.multiCall(encoded);
  }
  async normalizeAmount(amount) {
    const decimals = await this.contractWrapper.readContract.decimals();
    return ethers.utils.parseUnits(PriceSchema.parse(amount), decimals);
  }
  async getValue(value) {
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));
  }
  detectErc20Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20Mintable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC20Burnable")) {
      return new Erc20Burnable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC20Droppable")) {
      return new Erc20Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc20SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20SignatureMintable")) {
      return new Erc20SignatureMintable(this.contractWrapper);
    }
    return void 0;
  }
};
__name(Erc20, "Erc20");

// src/core/classes/erc-20-history.ts
init_esm_shims();
var TokenERC20History = class {
  constructor(contractWrapper, events) {
    this.contractWrapper = contractWrapper;
    this.events = events;
  }
  async getAllHolderBalances() {
    const a = await this.events.getEvents("Transfer");
    const txns = a.map((b) => b.data);
    const balances = {};
    txns.forEach((item) => {
      const from = item == null ? void 0 : item.from;
      const to = item == null ? void 0 : item.to;
      const amount = item == null ? void 0 : item.value;
      if (!(from === constants.AddressZero)) {
        if (!(from in balances)) {
          balances[from] = BigNumber.from(0);
        }
        balances[from] = balances[from].sub(amount);
      }
      if (!(to === constants.AddressZero)) {
        if (!(to in balances)) {
          balances[to] = BigNumber.from(0);
        }
        balances[to] = balances[to].add(amount);
      }
    });
    return Promise.all(Object.keys(balances).map(async (addr) => ({
      holder: addr,
      balance: await fetchCurrencyValue(this.contractWrapper.getProvider(), this.contractWrapper.readContract.address, balances[addr])
    })));
  }
};
__name(TokenERC20History, "TokenERC20History");

// src/core/classes/erc-721.ts
init_esm_shims();

// src/core/classes/erc-721-supply.ts
init_esm_shims();

// src/types/QueryParams.ts
init_esm_shims();
var DEFAULT_QUERY_ALL_COUNT = 100;

// src/core/classes/erc-721-enumerable.ts
init_esm_shims();
var Erc721Enumerable = class {
  featureName = FEATURE_NFT_ENUMERABLE.name;
  constructor(erc721, contractWrapper) {
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async all(walletAddress) {
    const tokenIds = await this.tokenIds(walletAddress);
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  async tokenIds(walletAddress) {
    const address = walletAddress || await this.contractWrapper.getSignerAddress();
    const balance = await this.contractWrapper.readContract.balanceOf(address);
    const indices = Array.from(Array(balance.toNumber()).keys());
    return await Promise.all(indices.map((i) => this.contractWrapper.readContract.tokenOfOwnerByIndex(address, i)));
  }
};
__name(Erc721Enumerable, "Erc721Enumerable");

// src/core/classes/erc-721-supply.ts
var Erc721Supply = class {
  featureName = FEATURE_NFT_SUPPLY.name;
  constructor(erc721, contractWrapper) {
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.owned = this.detectErc721Owned();
  }
  async all(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxSupply = await this.erc721.nextTokenIdToMint();
    const maxId = Math.min(maxSupply.toNumber(), start + count);
    return await Promise.all([
      ...Array(maxId - start).keys()
    ].map((i) => this.erc721.get((start + i).toString())));
  }
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return await this.contractWrapper.readContract.totalSupply();
  }
  detectErc721Owned() {
    if (detectContractFeature(this.contractWrapper, "ERC721Enumerable")) {
      return new Erc721Enumerable(this.erc721, this.contractWrapper);
    }
    return void 0;
  }
};
__name(Erc721Supply, "Erc721Supply");

// src/core/classes/erc-721-mintable.ts
init_esm_shims();

// src/core/classes/erc-721-batch-mintable.ts
init_esm_shims();
var Erc721BatchMintable = class {
  featureName = FEATURE_NFT_BATCH_MINTABLE.name;
  constructor(erc721, contractWrapper, storage) {
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async to(to, metadatas) {
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const encoded = uris.map((uri) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [
      to,
      uri
    ]));
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
    if (events.length === 0 || events.length < metadatas.length) {
      throw new Error("TokenMinted event not found, minting failed");
    }
    return events.map((e) => {
      const id = e.args.tokenIdMinted;
      return {
        id,
        receipt,
        data: () => this.erc721.get(id)
      };
    });
  }
};
__name(Erc721BatchMintable, "Erc721BatchMintable");

// src/core/classes/erc-721-mintable.ts
var Erc721Mintable = class {
  featureName = FEATURE_NFT_MINTABLE.name;
  constructor(erc721, contractWrapper, storage) {
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc721BatchMintable();
  }
  async to(to, metadata) {
    const uri = await uploadOrExtractURI(metadata, this.storage);
    const receipt = await this.contractWrapper.sendTransaction("mintTo", [
      to,
      uri
    ]);
    const event = this.contractWrapper.parseLogs("Transfer", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("TransferEvent event not found");
    }
    const id = event[0].args.tokenId;
    return {
      id,
      receipt,
      data: () => this.erc721.get(id)
    };
  }
  detectErc721BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721BatchMintable")) {
      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
__name(Erc721Mintable, "Erc721Mintable");

// src/core/classes/erc-721-droppable.ts
init_esm_shims();

// src/core/classes/erc-721-claimable.ts
init_esm_shims();

// src/core/classes/TransactionTask.ts
init_esm_shims();

// src/core/classes/gas-cost-estimator.ts
init_esm_shims();
var GasCostEstimator = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  async gasCostOf(fn, args) {
    const price = await this.contractWrapper.getPreferredGasPrice();
    const gasUnits = await this.contractWrapper.estimateGas(fn, args);
    return ethers.utils.formatEther(gasUnits.mul(price));
  }
  async gasLimitOf(fn, args) {
    return this.contractWrapper.estimateGas(fn, args);
  }
  async currentGasPriceInGwei() {
    const price = await this.contractWrapper.getProvider().getGasPrice();
    return ethers.utils.formatUnits(price, "gwei");
  }
};
__name(GasCostEstimator, "GasCostEstimator");

// src/core/classes/TransactionTask.ts
var TransactionTask = class {
  static make(taskArgs) {
    return new TransactionTask(taskArgs);
  }
  constructor(taskArgs) {
    this.contractWrapper = taskArgs.contractWrapper;
    this.functionName = taskArgs.functionName;
    this.args = taskArgs.args || [];
    this.overrides = taskArgs.overrides;
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  overrideGasLimit(gasLimit) {
    this.overrides = __spreadProps(__spreadValues({}, this.overrides), {
      gasLimit
    });
    return this;
  }
  overrideGasPrice(gasPrice) {
    this.overrides = __spreadProps(__spreadValues({}, this.overrides), {
      gasPrice
    });
    return this;
  }
  overrideNonce(nonce) {
    this.overrides = __spreadProps(__spreadValues({}, this.overrides), {
      nonce
    });
    return this;
  }
  overrideValue(value) {
    this.overrides = __spreadProps(__spreadValues({}, this.overrides), {
      value
    });
    return this;
  }
  async estimateGasLimit() {
    return await this.estimator.gasLimitOf(this.functionName, this.args);
  }
  async estimateGasCostInEther() {
    return await this.estimator.gasCostOf(this.functionName, this.args);
  }
  async encodeFunctionData() {
    return this.encoder.encode(this.functionName, this.args);
  }
  async submit() {
    return await this.contractWrapper.sendTransactionByFunction(this.functionName, this.args, this.overrides || {});
  }
  async execute() {
    const receipt = await this.contractWrapper.sendTransaction(this.functionName, this.args, this.overrides || {});
    return {
      receipt
    };
  }
};
__name(TransactionTask, "TransactionTask");

// src/core/classes/erc-721-claimable.ts
var Erc721Claimable = class {
  featureName = FEATURE_NFT_CLAIMABLE.name;
  constructor(erc721, contractWrapper, storage) {
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
  async getClaimTransaction(destinationAddress, quantity, checkERC20Allowance = true, claimData) {
    let claimVerification = claimData;
    if (this.conditions && !claimData) {
      claimVerification = await this.conditions.prepareClaim(quantity, checkERC20Allowance);
    }
    if (!claimVerification) {
      throw new Error("Claim verification Data is required - either pass it in as 'claimData' or set claim conditions via 'conditions.set()'");
    }
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: [
        destinationAddress,
        quantity,
        claimVerification.currencyAddress,
        claimVerification.price,
        {
          proof: claimVerification.proofs,
          maxQuantityInAllowlist: claimVerification.maxQuantityPerTransaction
        },
        ethers.utils.toUtf8Bytes("")
      ],
      overrides: claimVerification.overrides
    });
  }
  async to(destinationAddress, quantity, checkERC20Allowance = true, claimData) {
    const task = await this.getClaimTransaction(destinationAddress, quantity, checkERC20Allowance, claimData);
    const { receipt } = await task.execute();
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(quantity);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.get(id)
      });
    }
    return results;
  }
};
__name(Erc721Claimable, "Erc721Claimable");

// src/core/classes/erc-721-droppable.ts
var Erc721Droppable = class {
  featureName = FEATURE_NFT_DROPPABLE.name;
  constructor(erc721, contractWrapper, storage) {
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc721Revealable();
    this.claim = this.detectErc721Claimable();
  }
  async lazyMint(metadatas, options) {
    var _a3;
    const startFileNumber = await this.erc721.nextTokenIdToMint();
    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), this.contractWrapper.readContract.address, await ((_a3 = this.contractWrapper.getSigner()) == null ? void 0 : _a3.getAddress()), options);
    const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
    for (let i = 0; i < batch.length; i++) {
      const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
      if (baseUri !== uri) {
        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
      }
    }
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [
      batch.length,
      baseUri.endsWith("/") ? baseUri : `${baseUri}/`,
      ethers.utils.toUtf8Bytes("")
    ]);
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = event[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.getTokenMetadata(id)
      });
    }
    return results;
  }
  detectErc721Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());
    }
    return void 0;
  }
  detectErc721Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Claimable")) {
      return new Erc721Claimable(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
__name(Erc721Droppable, "Erc721Droppable");

// src/core/classes/erc-721-with-quantity-signature-mintable.ts
init_esm_shims();
var Erc721WithQuantitySignatureMintable = class {
  featureName = FEATURE_NFT_SIGNATURE_MINTABLE.name;
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async mint(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    let message;
    let price;
    if (isLegacyNFTContract) {
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      price = message.price;
    } else {
      message = await this.mapPayloadToContractStruct(mintRequest);
      price = message.pricePerToken.mul(message.quantity);
    }
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("mintWithSignature", [
      message,
      signature
    ], overrides);
    const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (t.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    const id = t[0].args.tokenIdMinted;
    return {
      id,
      receipt
    };
  }
  async mintBatch(signedPayloads) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
      let message;
      if (isLegacyNFTContract) {
        message = await this.mapLegacyPayloadToContractStruct(s.payload);
      } else {
        message = await this.mapPayloadToContractStruct(s.payload);
      }
      const signature = s.signature;
      const price = s.payload.price;
      if (BigNumber.from(price).gt(0)) {
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      }
      return {
        message,
        signature
      };
    }));
    const encoded = contractPayloads.map((p) => {
      if (isLegacyNFTContract) {
        const contract = this.contractWrapper.readContract;
        return contract.interface.encodeFunctionData("mintWithSignature", [
          p.message,
          p.signature
        ]);
      } else {
        const contract = this.contractWrapper.readContract;
        return contract.interface.encodeFunctionData("mintWithSignature", [
          p.message,
          p.signature
        ]);
      }
    });
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (events.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    return events.map((log) => ({
      id: log.args.tokenIdMinted,
      receipt
    }));
  }
  async verify(signedPayload) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    let message;
    let verification;
    if (isLegacyNFTContract) {
      const contract = this.contractWrapper.readContract;
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      verification = await contract.verify(message, signature);
    } else {
      const contract = this.contractWrapper.readContract;
      message = await this.mapPayloadToContractStruct(mintRequest);
      verification = await contract.verify(message, signature);
    }
    return verification[0];
  }
  async generate(mintRequest) {
    return (await this.generateBatch([
      mintRequest
    ]))[0];
  }
  async generateBatch(payloadsToSign) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const parsedRequests = payloadsToSign.map((m) => Signature721WithQuantityInput.parse(m));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant13(signer, "No signer available");
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = Signature721WithQuantityOutput.parse(__spreadProps(__spreadValues({}, m), {
        uri
      }));
      let signature;
      if (isLegacyNFTContract) {
        signature = await this.contractWrapper.signTypedData(signer, {
          name: "TokenERC721",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.readContract.address
        }, {
          MintRequest: MintRequest721
        }, await this.mapLegacyPayloadToContractStruct(finalPayload));
      } else {
        signature = await this.contractWrapper.signTypedData(signer, {
          name: "SignatureMintERC721",
          version: "1",
          chainId,
          verifyingContract: await this.contractWrapper.readContract.address
        }, {
          MintRequest: MintRequest721withQuantity
        }, await this.mapPayloadToContractStruct(finalPayload));
      }
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid
    };
  }
  async mapLegacyPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      price: normalizedPricePerToken,
      uri: mintRequest.uri,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
  async isLegacyNFTContract() {
    if (hasFunction("contractType", this.contractWrapper)) {
      try {
        const contractType = ethers.utils.toUtf8String(await this.contractWrapper.readContract.contractType());
        return contractType.includes("TokenERC721");
      } catch (e) {
        return false;
      }
    } else {
      return false;
    }
  }
};
__name(Erc721WithQuantitySignatureMintable, "Erc721WithQuantitySignatureMintable");

// src/core/classes/erc-721-burnable.ts
init_esm_shims();
var Erc721Burnable = class {
  featureName = FEATURE_NFT_BURNABLE.name;
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  async token(tokenId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burn", [
        tokenId
      ])
    };
  }
};
__name(Erc721Burnable, "Erc721Burnable");

// src/core/classes/erc-721.ts
var Erc721 = class {
  featureName = FEATURE_NFT.name;
  constructor(contractWrapper, storage, options = {}) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid contract options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    this.query = this.detectErc721Enumerable();
    this.mint = this.detectErc721Mintable();
    this.burn = this.detectErc721Burnable();
    this.drop = this.detectErc721Droppable();
    this.signature = this.detectErc721SignatureMintable();
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    const [owner, metadata] = await Promise.all([
      this.ownerOf(tokenId).catch(() => constants.AddressZero),
      this.getTokenMetadata(tokenId)
    ]);
    return {
      owner,
      metadata
    };
  }
  async ownerOf(tokenId) {
    return await this.contractWrapper.readContract.ownerOf(tokenId);
  }
  async balanceOf(address) {
    return await this.contractWrapper.readContract.balanceOf(address);
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async isApproved(address, operator) {
    return await this.contractWrapper.readContract.isApprovedForAll(address, operator);
  }
  async transfer(to, tokenId) {
    const from = await this.contractWrapper.getSignerAddress();
    return {
      receipt: await this.contractWrapper.sendTransaction("safeTransferFrom(address,address,uint256)", [
        from,
        to,
        tokenId
      ])
    };
  }
  async setApprovalForAll(operator, approved) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [
        operator,
        approved
      ])
    };
  }
  async setApprovalForToken(operator, tokenId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("approve", [
        operator,
        tokenId
      ])
    };
  }
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.readContract.tokenURI(tokenId);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    } else if (hasFunction("totalSupply", this.contractWrapper)) {
      return await this.contractWrapper.readContract.totalSupply();
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
  }
  detectErc721Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Supply") || hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return new Erc721Supply(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Mintable")) {
      return new Erc721Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Burnable")) {
      return new Erc721Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Droppable")) {
      return new Erc721Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721SignatureMint")) {
      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
__name(Erc721, "Erc721");

// src/core/classes/erc-1155.ts
init_esm_shims();

// src/schema/contracts/common/airdrop.ts
init_esm_shims();
var AirdropAddressInput = z.object({
  address: AddressSchema,
  quantity: PriceSchema.default(1)
});
var AirdropInputSchema = z.union([
  z.array(z.string()).transform((strings) => strings.map((address) => AirdropAddressInput.parse({
    address
  }))),
  z.array(AirdropAddressInput)
]);

// src/core/classes/erc-1155-enumerable.ts
init_esm_shims();
var Erc1155Enumerable = class {
  featureName = FEATURE_EDITION_ENUMERABLE.name;
  constructor(erc1155, contractWrapper) {
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
  }
  async all(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);
    return await Promise.all([
      ...Array(maxId - start).keys()
    ].map((i) => this.erc1155.get((start + i).toString())));
  }
  async totalCount() {
    return await this.contractWrapper.readContract.nextTokenIdToMint();
  }
  async totalCirculatingSupply(tokenId) {
    return await this.contractWrapper.readContract.totalSupply(tokenId);
  }
  async owned(walletAddress) {
    const address = walletAddress || await this.contractWrapper.getSignerAddress();
    const maxId = await this.contractWrapper.readContract.nextTokenIdToMint();
    const balances = await this.contractWrapper.readContract.balanceOfBatch(Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys()));
    const ownedBalances = balances.map((b, i) => {
      return {
        tokenId: i,
        balance: b
      };
    }).filter((b) => b.balance.gt(0));
    return await Promise.all(ownedBalances.map(async (b) => {
      const editionMetadata = await this.erc1155.get(b.tokenId.toString());
      return __spreadProps(__spreadValues({}, editionMetadata), {
        owner: address,
        quantityOwned: b.balance
      });
    }));
  }
};
__name(Erc1155Enumerable, "Erc1155Enumerable");

// src/core/classes/erc-1155-mintable.ts
init_esm_shims();

// src/core/classes/erc-1155-batch-mintable.ts
init_esm_shims();
var Erc1155BatchMintable = class {
  featureName = FEATURE_EDITION_BATCH_MINTABLE.name;
  constructor(erc1155, contractWrapper, storage) {
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async to(to, metadataWithSupply) {
    const metadatas = metadataWithSupply.map((a) => a.metadata);
    const supplies = metadataWithSupply.map((a) => a.supply);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const encoded = uris.map((uri, index) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [
      to,
      ethers.constants.MaxUint256,
      uri,
      supplies[index]
    ]));
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
    if (events.length === 0 || events.length < metadatas.length) {
      throw new Error("TokenMinted event not found, minting failed");
    }
    return events.map((e) => {
      const id = e.args.tokenIdMinted;
      return {
        id,
        receipt,
        data: () => this.erc1155.get(id)
      };
    });
  }
};
__name(Erc1155BatchMintable, "Erc1155BatchMintable");
var Erc1155Mintable = class {
  featureName = FEATURE_EDITION_MINTABLE.name;
  constructor(erc1155, contractWrapper, storage) {
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc1155BatchMintable();
  }
  async to(to, metadataWithSupply) {
    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);
    const receipt = await this.contractWrapper.sendTransaction("mintTo", [
      to,
      ethers.constants.MaxUint256,
      uri,
      metadataWithSupply.supply
    ]);
    const event = this.contractWrapper.parseLogs("TransferSingle", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("TransferSingleEvent event not found");
    }
    const id = event[0].args.id;
    return {
      id,
      receipt,
      data: () => this.erc1155.get(id.toString())
    };
  }
  async additionalSupplyTo(to, tokenId, additionalSupply) {
    const metadata = await this.erc1155.getTokenMetadata(tokenId);
    const receipt = await this.contractWrapper.sendTransaction("mintTo", [
      to,
      tokenId,
      metadata.uri,
      additionalSupply
    ]);
    return {
      id: BigNumber.from(tokenId),
      receipt,
      data: () => this.erc1155.get(tokenId)
    };
  }
  detectErc1155BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155BatchMintable")) {
      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
__name(Erc1155Mintable, "Erc1155Mintable");

// src/core/classes/erc-1155-signature-mintable.ts
init_esm_shims();
var Erc1155SignatureMintable = class {
  featureName = FEATURE_EDITION_SIGNATURE_MINTABLE.name;
  constructor(contractWrapper, storage, roles) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.roles = roles;
  }
  async mint(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("mintWithSignature", [
      message,
      signature
    ], overrides);
    const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (t.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    const id = t[0].args.tokenIdMinted;
    return {
      id,
      receipt
    };
  }
  async mintBatch(signedPayloads) {
    const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
      const message = await this.mapPayloadToContractStruct(s.payload);
      const signature = s.signature;
      const price = s.payload.price;
      if (BigNumber.from(price).gt(0)) {
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      }
      return {
        message,
        signature
      };
    }));
    const encoded = contractPayloads.map((p) => {
      return this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [
        p.message,
        p.signature
      ]);
    });
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (events.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    return events.map((log) => ({
      id: log.args.tokenIdMinted,
      receipt
    }));
  }
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.readContract.verify(message, signature);
    return verification[0];
  }
  async generate(payloadToSign) {
    const payload = __spreadProps(__spreadValues({}, payloadToSign), {
      tokenId: ethers.constants.MaxUint256
    });
    return this.generateFromTokenId(payload);
  }
  async generateFromTokenId(payloadToSign) {
    const payloads = await this.generateBatchFromTokenIds([
      payloadToSign
    ]);
    return payloads[0];
  }
  async generateBatch(payloadsToSign) {
    const payloads = payloadsToSign.map((payload) => __spreadProps(__spreadValues({}, payload), {
      tokenId: ethers.constants.MaxUint256
    }));
    return this.generateBatchFromTokenIds(payloads);
  }
  async generateBatchFromTokenIds(payloadsToSign) {
    var _a3;
    await ((_a3 = this.roles) == null ? void 0 : _a3.verify([
      "minter"
    ], await this.contractWrapper.getSignerAddress()));
    const parsedRequests = payloadsToSign.map((m) => Signature1155PayloadInputWithTokenId.parse(m));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant13(signer, "No signer available");
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = Signature1155PayloadOutput.parse(__spreadProps(__spreadValues({}, m), {
        uri
      }));
      const signature = await this.contractWrapper.signTypedData(signer, {
        name: "TokenERC1155",
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.readContract.address
      }, {
        MintRequest: MintRequest1155
      }, await this.mapPayloadToContractStruct(finalPayload));
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      tokenId: mintRequest.tokenId,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
};
__name(Erc1155SignatureMintable, "Erc1155SignatureMintable");

// src/core/classes/erc-1155-droppable.ts
init_esm_shims();

// src/core/classes/erc-1155-claimable.ts
init_esm_shims();
var Erc1155Claimable = class {
  featureName = FEATURE_NFT_CLAIMABLE.name;
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, checkERC20Allowance = true, claimData) {
    let claimVerification = claimData;
    if (this.conditions && !claimData) {
      claimVerification = await this.conditions.prepareClaim(tokenId, quantity, checkERC20Allowance);
    }
    if (!claimVerification) {
      throw new Error("Claim verification Data is required - either pass it in as 'claimData' or set claim conditions via 'conditions.set()'");
    }
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: [
        destinationAddress,
        tokenId,
        quantity,
        claimVerification.currencyAddress,
        claimVerification.price,
        claimVerification.proofs,
        claimVerification.maxQuantityPerTransaction
      ],
      overrides: claimVerification.overrides
    });
  }
  async to(destinationAddress, tokenId, quantity, checkERC20Allowance = true, claimData) {
    let claimVerification = claimData;
    if (this.conditions && !claimData) {
      claimVerification = await this.conditions.prepareClaim(tokenId, quantity, checkERC20Allowance);
    }
    if (!claimVerification) {
      throw new Error("Claim verification Data is required - either pass it in as 'claimData' or set claim conditions via 'conditions.set()'");
    }
    const tx = await this.getClaimTransaction(destinationAddress, tokenId, quantity, checkERC20Allowance, claimData);
    return await tx.execute();
  }
};
__name(Erc1155Claimable, "Erc1155Claimable");

// src/core/classes/erc-1155-droppable.ts
var Erc1155Droppable = class {
  featureName = FEATURE_EDITION_DROPPABLE.name;
  constructor(erc1155, contractWrapper, storage) {
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.claim = this.detectErc1155Claimable();
    this.revealer = this.detectErc721Revealable();
  }
  async lazyMint(metadatas, options) {
    var _a3;
    const startFileNumber = await this.erc1155.nextTokenIdToMint();
    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), this.contractWrapper.readContract.address, await ((_a3 = this.contractWrapper.getSigner()) == null ? void 0 : _a3.getAddress()), options);
    const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
    for (let i = 0; i < batch.length; i++) {
      const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
      if (baseUri !== uri) {
        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
      }
    }
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [
      batch.length,
      `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`
    ]);
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = event[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc1155.getTokenMetadata(id)
      });
    }
    return results;
  }
  detectErc1155Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Claimable")) {
      return new Erc1155Claimable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());
    }
    return void 0;
  }
};
__name(Erc1155Droppable, "Erc1155Droppable");

// src/core/classes/erc-1155-burnable.ts
init_esm_shims();
var Erc1155Burnable = class {
  featureName = FEATURE_EDITION_BURNABLE.name;
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  async tokens(tokenId, amount) {
    const account = await this.contractWrapper.getSignerAddress();
    return this.from(account, tokenId, amount);
  }
  async from(account, tokenId, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burn", [
        account,
        tokenId,
        amount
      ])
    };
  }
  async batch(tokenIds, amounts) {
    const account = await this.contractWrapper.getSignerAddress();
    return this.batchFrom(account, tokenIds, amounts);
  }
  async batchFrom(account, tokenIds, amounts) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burnBatch", [
        account,
        tokenIds,
        amounts
      ])
    };
  }
};
__name(Erc1155Burnable, "Erc1155Burnable");

// src/core/classes/erc-1155.ts
var Erc1155 = class {
  featureName = FEATURE_EDITION.name;
  constructor(contractWrapper, storage, options = {}) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid contract options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    this.query = this.detectErc1155Enumerable();
    this.mint = this.detectErc1155Mintable();
    this.burn = this.detectErc1155Burnable();
    this.drop = this.detectErc1155Droppable();
    this.signature = this.detectErc1155SignatureMintable();
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    const [supply, metadata] = await Promise.all([
      this.contractWrapper.readContract.totalSupply(tokenId).catch(() => BigNumber.from(0)),
      this.getTokenMetadata(tokenId)
    ]);
    return EditionMetadataOutputSchema.parse({
      supply,
      metadata
    });
  }
  async totalSupply(tokenId) {
    return await this.contractWrapper.readContract.totalSupply(tokenId);
  }
  async balanceOf(address, tokenId) {
    return await this.contractWrapper.readContract.balanceOf(address, tokenId);
  }
  async balance(tokenId) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);
  }
  async isApproved(address, operator) {
    return await this.contractWrapper.readContract.isApprovedForAll(address, operator);
  }
  async transfer(to, tokenId, amount, data = [
    0
  ]) {
    const from = await this.contractWrapper.getSignerAddress();
    return {
      receipt: await this.contractWrapper.sendTransaction("safeTransferFrom", [
        from,
        to,
        tokenId,
        amount,
        data
      ])
    };
  }
  async setApprovalForAll(operator, approved) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [
        operator,
        approved
      ])
    };
  }
  async airdrop(tokenId, addresses, data = [
    0
  ]) {
    const from = await this.contractWrapper.getSignerAddress();
    const balanceOf = await this.balanceOf(from, tokenId);
    const input = AirdropInputSchema.parse(addresses);
    const totalToAirdrop = input.reduce((prev, curr) => {
      return prev + Number((curr == null ? void 0 : curr.quantity) || 1);
    }, 0);
    if (balanceOf.toNumber() < totalToAirdrop) {
      throw new Error(`The caller owns ${balanceOf.toNumber()} NFTs, but wants to airdrop ${totalToAirdrop} NFTs.`);
    }
    const encoded = input.map(({ address: to, quantity }) => {
      return this.contractWrapper.readContract.interface.encodeFunctionData("safeTransferFrom", [
        from,
        to,
        tokenId,
        quantity,
        data
      ]);
    });
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    } else {
      throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint");
    }
  }
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.readContract.uri(tokenId);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  detectErc1155Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Enumerable")) {
      return new Erc1155Enumerable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Mintable")) {
      return new Erc1155Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Burnable")) {
      return new Erc1155Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Droppable")) {
      return new Erc1155Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155SignatureMintable")) {
      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
__name(Erc1155, "Erc1155");

// src/core/classes/marketplace-direct.ts
init_esm_shims();

// src/common/marketplace.ts
init_esm_shims();
async function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {
  try {
    const erc165 = new Contract(assetContract, IERC165_default, provider);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(assetContract, IERC721_default, provider);
      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);
      if (approved) {
        return true;
      }
      return (await asset.getApproved(tokenId)).toLowerCase() === transferrerContractAddress.toLowerCase();
    } else if (isERC1155) {
      const asset = new Contract(assetContract, IERC1155_default, provider);
      return await asset.isApprovedForAll(owner, transferrerContractAddress);
    } else {
      console.error("Contract does not implement ERC 1155 or ERC 721.");
      return false;
    }
  } catch (err) {
    console.error("Failed to check if token is approved", err);
    return false;
  }
}
__name(isTokenApprovedForTransfer, "isTokenApprovedForTransfer");
async function handleTokenApproval(signerOrProvider, marketplaceAddress, assetContract, tokenId, from) {
  const erc165 = new Contract(assetContract, IERC165_default, signerOrProvider);
  const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
  const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
  if (isERC721) {
    const asset = new ContractWrapper(signerOrProvider, assetContract, IERC721_default, {});
    const approved = await asset.readContract.isApprovedForAll(from, marketplaceAddress);
    if (!approved) {
      const isTokenApproved = (await asset.readContract.getApproved(tokenId)).toLowerCase() === marketplaceAddress.toLowerCase();
      if (!isTokenApproved) {
        await asset.sendTransaction("setApprovalForAll", [
          marketplaceAddress,
          true
        ]);
      }
    }
  } else if (isERC1155) {
    const asset = new ContractWrapper(signerOrProvider, assetContract, IERC1155_default, {});
    const approved = await asset.readContract.isApprovedForAll(from, marketplaceAddress);
    if (!approved) {
      await asset.sendTransaction("setApprovalForAll", [
        marketplaceAddress,
        true
      ]);
    }
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
}
__name(handleTokenApproval, "handleTokenApproval");
function validateNewListingParam(param) {
  invariant13(param.assetContractAddress !== void 0 && param.assetContractAddress !== null, "Asset contract address is required");
  invariant13(param.buyoutPricePerToken !== void 0 && param.buyoutPricePerToken !== null, "Buyout price is required");
  invariant13(param.listingDurationInSeconds !== void 0 && param.listingDurationInSeconds !== null, "Listing duration is required");
  invariant13(param.startTimestamp !== void 0 && param.startTimestamp !== null, "Start time is required");
  invariant13(param.tokenId !== void 0 && param.tokenId !== null, "Token ID is required");
  invariant13(param.quantity !== void 0 && param.quantity !== null, "Quantity is required");
  switch (param.type) {
    case "NewAuctionListing": {
      invariant13(param.reservePricePerToken !== void 0 && param.reservePricePerToken !== null, "Reserve price is required");
    }
  }
}
__name(validateNewListingParam, "validateNewListingParam");
async function mapOffer(provider, listingId, offer) {
  return {
    quantity: offer.quantityDesired,
    pricePerToken: offer.pricePerToken,
    currencyContractAddress: offer.currency,
    buyerAddress: offer.offeror,
    quantityDesired: offer.quantityWanted,
    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),
    listingId
  };
}
__name(mapOffer, "mapOffer");
function isWinningBid(winningPrice, newBidPrice, bidBuffer) {
  bidBuffer = BigNumber.from(bidBuffer);
  winningPrice = BigNumber.from(winningPrice);
  newBidPrice = BigNumber.from(newBidPrice);
  if (winningPrice.eq(BigNumber.from(0))) {
    return false;
  }
  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);
  return buffer.gte(bidBuffer);
}
__name(isWinningBid, "isWinningBid");
var MarketplaceDirect = class {
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.listings(listingId);
    if (listing.assetContract === constants.AddressZero) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    if (listing.listingType !== ListingType.Direct) {
      throw new WrongListingTypeError(this.getAddress(), listingId.toString(), "Auction", "Direct");
    }
    return await this.mapListing(listing);
  }
  async getActiveOffer(listingId, address) {
    await this.validateListing(BigNumber.from(listingId));
    invariant13(utils.isAddress(address), "Address must be a valid address");
    const offers = await this.contractWrapper.readContract.offers(listingId, address);
    if (offers.offeror === constants.AddressZero) {
      return void 0;
    }
    return await mapOffer(this.contractWrapper.getProvider(), BigNumber.from(listingId), offers);
  }
  async createListing(listing) {
    validateNewListingParam(listing);
    await handleTokenApproval(this.contractWrapper.getSignerOrProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), listing.buyoutPricePerToken, listing.currencyContractAddress);
    let listingStartTime = Math.floor(listing.startTimestamp.getTime() / 1e3);
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    if (listingStartTime < blockTime) {
      listingStartTime = blockTime;
    }
    const receipt = await this.contractWrapper.sendTransaction("createListing", [
      {
        assetContract: listing.assetContractAddress,
        tokenId: listing.tokenId,
        buyoutPricePerToken: normalizedPricePerToken,
        currencyToAccept: listing.currencyContractAddress,
        listingType: ListingType.Direct,
        quantityToList: listing.quantity,
        reservePricePerToken: normalizedPricePerToken,
        secondsUntilEndTime: listing.listingDurationInSeconds,
        startTime: BigNumber.from(listingStartTime)
      }
    ], {
      gasLimit: 5e5
    });
    const event = this.contractWrapper.parseLogs("ListingAdded", receipt == null ? void 0 : receipt.logs);
    return {
      id: event[0].args.listingId,
      receipt
    };
  }
  async makeOffer(listingId, quantityDesired, currencyContractAddress, pricePerToken, expirationDate) {
    if (isNativeToken(currencyContractAddress)) {
      throw new Error("You must use the wrapped native token address when making an offer with a native token");
    }
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), pricePerToken, currencyContractAddress);
    try {
      await this.getListing(listingId);
    } catch (err) {
      console.error("Failed to get listing, err =", err);
      throw new Error(`Error getting the listing with id ${listingId}`);
    }
    const quantity = BigNumber.from(quantityDesired);
    const value = BigNumber.from(normalizedPrice).mul(quantity);
    const overrides = await this.contractWrapper.getCallOverrides() || {};
    await setErc20Allowance(this.contractWrapper, value, currencyContractAddress, overrides);
    let expirationTimestamp = ethers.constants.MaxUint256;
    if (expirationDate) {
      expirationTimestamp = BigNumber.from(Math.floor(expirationDate.getTime() / 1e3));
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("offer", [
        listingId,
        quantityDesired,
        currencyContractAddress,
        normalizedPrice,
        expirationTimestamp
      ], overrides)
    };
  }
  async acceptOffer(listingId, addressOfOfferor) {
    await this.validateListing(BigNumber.from(listingId));
    const offer = await this.contractWrapper.readContract.offers(listingId, addressOfOfferor);
    return {
      receipt: await this.contractWrapper.sendTransaction("acceptOffer", [
        listingId,
        addressOfOfferor,
        offer.currency,
        offer.pricePerToken
      ])
    };
  }
  async buyoutListing(listingId, quantityDesired, receiver) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const { valid, error } = await this.isStillValidListing(listing, quantityDesired);
    if (!valid) {
      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
    }
    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
    const quantity = BigNumber.from(quantityDesired);
    const value = BigNumber.from(listing.buyoutPrice).mul(quantity);
    const overrides = await this.contractWrapper.getCallOverrides() || {};
    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("buy", [
        listingId,
        buyFor,
        quantity,
        listing.currencyContractAddress,
        value
      ], overrides)
    };
  }
  async updateListing(listing) {
    return {
      receipt: await this.contractWrapper.sendTransaction("updateListing", [
        listing.id,
        listing.quantity,
        listing.buyoutPrice,
        listing.buyoutPrice,
        listing.currencyContractAddress,
        listing.startTimeInSeconds,
        listing.secondsUntilEnd
      ])
    };
  }
  async cancelListing(listingId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("cancelDirectListing", [
        listingId
      ])
    };
  }
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  async mapListing(listing) {
    return {
      assetContractAddress: listing.assetContract,
      buyoutPrice: BigNumber.from(listing.buyoutPricePerToken),
      currencyContractAddress: listing.currency,
      buyoutCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.buyoutPricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId,
      quantity: listing.quantity,
      startTimeInSeconds: listing.startTime,
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      secondsUntilEnd: listing.endTime,
      sellerAddress: listing.tokenOwner,
      type: ListingType.Direct
    };
  }
  async isStillValidListing(listing, quantity) {
    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.sellerAddress);
    if (!approved) {
      return {
        valid: false,
        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
      };
    }
    const provider = this.contractWrapper.getProvider();
    const erc165 = new Contract(listing.assetContractAddress, IERC165_default, provider);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(listing.assetContractAddress, IERC721_default, provider);
      const valid = (await asset.ownerOf(listing.tokenId)).toLowerCase() === listing.sellerAddress.toLowerCase();
      return {
        valid,
        error: valid ? void 0 : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
      };
    } else if (isERC1155) {
      const asset = new Contract(listing.assetContractAddress, IERC1155_default, provider);
      const balance = await asset.balanceOf(listing.sellerAddress, listing.tokenId);
      const valid = balance.gte(quantity || listing.quantity);
      return {
        valid,
        error: valid ? void 0 : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
      };
    } else {
      return {
        valid: false,
        error: "Contract does not implement ERC 1155 or ERC 721."
      };
    }
  }
};
__name(MarketplaceDirect, "MarketplaceDirect");

// src/core/classes/marketplace-auction.ts
init_esm_shims();
var MarketplaceAuction = class {
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.listings(listingId);
    if (listing.listingId.toString() !== listingId.toString()) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    if (listing.listingType !== ListingType.Auction) {
      throw new WrongListingTypeError(this.getAddress(), listingId.toString(), "Direct", "Auction");
    }
    return await this.mapListing(listing);
  }
  async getWinningBid(listingId) {
    await this.validateListing(BigNumber.from(listingId));
    const offers = await this.contractWrapper.readContract.winningBid(listingId);
    if (offers.offeror === constants.AddressZero) {
      return void 0;
    }
    return await mapOffer(this.contractWrapper.getProvider(), BigNumber.from(listingId), offers);
  }
  async getWinner(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const offers = await this.contractWrapper.readContract.winningBid(listingId);
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    const endTime = BigNumber.from(listing.endTimeInEpochSeconds);
    if (now.gt(endTime) && offers.offeror !== constants.AddressZero) {
      return offers.offeror;
    }
    const closedAuctions = await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed());
    const auction = closedAuctions.find((a) => a.args.listingId.eq(BigNumber.from(listingId)));
    if (!auction) {
      throw new Error(`Could not find auction with listingId ${listingId} in closed auctions`);
    }
    return auction.args.winningBidder;
  }
  async createListing(listing) {
    validateNewListingParam(listing);
    await handleTokenApproval(this.contractWrapper.getSignerOrProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), listing.buyoutPricePerToken, listing.currencyContractAddress);
    const normalizedReservePrice = await normalizePriceValue(this.contractWrapper.getProvider(), listing.reservePricePerToken, listing.currencyContractAddress);
    let listingStartTime = Math.floor(listing.startTimestamp.getTime() / 1e3);
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    if (listingStartTime < blockTime) {
      listingStartTime = blockTime;
    }
    const receipt = await this.contractWrapper.sendTransaction("createListing", [
      {
        assetContract: listing.assetContractAddress,
        tokenId: listing.tokenId,
        buyoutPricePerToken: normalizedPricePerToken,
        currencyToAccept: listing.currencyContractAddress,
        listingType: ListingType.Auction,
        quantityToList: listing.quantity,
        reservePricePerToken: normalizedReservePrice,
        secondsUntilEndTime: listing.listingDurationInSeconds,
        startTime: BigNumber.from(listingStartTime)
      }
    ], {
      gasLimit: 5e5
    });
    const event = this.contractWrapper.parseLogs("ListingAdded", receipt == null ? void 0 : receipt.logs);
    return {
      id: event[0].args.listingId,
      receipt
    };
  }
  async buyoutListing(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), listing.currencyContractAddress);
    return this.makeBid(listingId, ethers.utils.formatUnits(listing.buyoutPrice, currencyMetadata.decimals));
  }
  async makeBid(listingId, pricePerToken) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), pricePerToken, listing.currencyContractAddress);
    if (normalizedPrice.eq(BigNumber.from(0))) {
      throw new Error("Cannot make a bid with 0 value");
    }
    const bidBuffer = await this.contractWrapper.readContract.bidBufferBps();
    const winningBid = await this.getWinningBid(listingId);
    if (winningBid) {
      const isWinnner = isWinningBid(winningBid.pricePerToken, normalizedPrice, bidBuffer);
      invariant13(isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
    } else {
      const tokenPrice = normalizedPrice;
      const reservePrice = BigNumber.from(listing.reservePrice);
      invariant13(tokenPrice.gte(reservePrice), "Bid price is too low based on reserve price");
    }
    const quantity = BigNumber.from(listing.quantity);
    const value = normalizedPrice.mul(quantity);
    const overrides = await this.contractWrapper.getCallOverrides() || {};
    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("offer", [
        listingId,
        listing.quantity,
        listing.currencyContractAddress,
        normalizedPrice,
        ethers.constants.MaxUint256
      ], overrides)
    };
  }
  async cancelListing(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    const startTime = BigNumber.from(listing.startTimeInEpochSeconds);
    const offers = await this.contractWrapper.readContract.winningBid(listingId);
    if (now.gt(startTime) && offers.offeror !== constants.AddressZero) {
      throw new AuctionAlreadyStartedError(listingId.toString());
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("closeAuction", [
        BigNumber.from(listingId),
        await this.contractWrapper.getSignerAddress()
      ])
    };
  }
  async closeListing(listingId, closeFor) {
    if (!closeFor) {
      closeFor = await this.contractWrapper.getSignerAddress();
    }
    const listing = await this.validateListing(BigNumber.from(listingId));
    try {
      return {
        receipt: await this.contractWrapper.sendTransaction("closeAuction", [
          BigNumber.from(listingId),
          closeFor
        ])
      };
    } catch (err) {
      if (err.message.includes("cannot close auction before it has ended")) {
        throw new AuctionHasNotEndedError(listingId.toString(), listing.endTimeInEpochSeconds.toString());
      } else {
        throw err;
      }
    }
  }
  async updateListing(listing) {
    return {
      receipt: await this.contractWrapper.sendTransaction("updateListing", [
        listing.id,
        listing.quantity,
        listing.reservePrice,
        listing.buyoutPrice,
        listing.currencyContractAddress,
        listing.startTimeInEpochSeconds,
        listing.endTimeInEpochSeconds
      ])
    };
  }
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  async mapListing(listing) {
    return {
      assetContractAddress: listing.assetContract,
      buyoutPrice: BigNumber.from(listing.buyoutPricePerToken),
      currencyContractAddress: listing.currency,
      buyoutCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.buyoutPricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId,
      quantity: listing.quantity,
      startTimeInEpochSeconds: listing.startTime,
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      reservePriceCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.reservePricePerToken),
      reservePrice: BigNumber.from(listing.reservePricePerToken),
      endTimeInEpochSeconds: listing.endTime,
      sellerAddress: listing.tokenOwner,
      type: ListingType.Auction
    };
  }
};
__name(MarketplaceAuction, "MarketplaceAuction");

// src/core/classes/contract-deployer.ts
init_esm_shims();

// src/core/classes/registry.ts
init_esm_shims();
var ContractRegistry = class extends ContractWrapper {
  constructor(registryAddress, network, options) {
    super(network, registryAddress, TWRegistry__factory.abi, options);
  }
  async getContractAddresses(walletAddress) {
    return (await this.readContract.getAll(walletAddress)).filter((adr) => utils.isAddress(adr) && adr.toLowerCase() !== constants.AddressZero);
  }
  async addContract(contractAddress) {
    return await this.addContracts([
      contractAddress
    ]);
  }
  async addContracts(contractAddresses) {
    const deployerAddress = await this.getSignerAddress();
    const encoded = [];
    contractAddresses.forEach((address) => {
      encoded.push(this.readContract.interface.encodeFunctionData("add", [
        deployerAddress,
        address
      ]));
    });
    return {
      receipt: await this.multiCall(encoded)
    };
  }
  async removeContract(contractAddress) {
    return await this.removeContracts([
      contractAddress
    ]);
  }
  async removeContracts(contractAddresses) {
    const deployerAddress = await this.getSignerAddress();
    const encoded = [];
    contractAddresses.forEach((address) => {
      encoded.push(this.readContract.interface.encodeFunctionData("remove", [
        deployerAddress,
        address
      ]));
    });
    return {
      receipt: await this.multiCall(encoded)
    };
  }
};
__name(ContractRegistry, "ContractRegistry");

// src/core/classes/factory.ts
init_esm_shims();

// src/contracts/maps.ts
init_esm_shims();

// src/contracts/nft-collection.ts
init_esm_shims();

// src/core/classes/contract-interceptor.ts
init_esm_shims();
var ContractInterceptor = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  overrideNextTransaction(hook) {
    this.contractWrapper.withTransactionOverride(hook);
  }
};
__name(ContractInterceptor, "ContractInterceptor");

// src/core/classes/contract-events.ts
init_esm_shims();
var ContractEvents = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  addTransactionListener(listener) {
    this.contractWrapper.addListener(EventType.Transaction, listener);
  }
  removeTransactionListener(listener) {
    this.contractWrapper.off(EventType.Transaction, listener);
  }
  addEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const address = this.contractWrapper.readContract.address;
    const filter = {
      address,
      topics: [
        event.name
      ]
    };
    const wrappedListener = /* @__PURE__ */ __name((log) => {
      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
    }, "wrappedListener");
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  listenToAllEvents(listener) {
    const address = this.contractWrapper.readContract.address;
    const filter = {
      address
    };
    const wrappedListener = /* @__PURE__ */ __name((log) => {
      try {
        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
      } catch (e) {
        console.error("Could not parse event:", log, e);
      }
    }, "wrappedListener");
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  removeEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    this.contractWrapper.readContract.off(event.name, listener);
  }
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const address = this.contractWrapper.readContract.address;
    const filter = {
      address
    };
    this.contractWrapper.getProvider().removeAllListeners(filter);
  }
  async getAllEvents(filters = {
    fromBlock: 0,
    toBlock: "latest",
    order: "desc"
  }) {
    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return filters.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  async getEvents(eventName, filters = {
    fromBlock: 0,
    toBlock: "latest",
    order: "desc"
  }) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const filter = this.contractWrapper.readContract.filters[event.name];
    const events = await this.contractWrapper.readContract.queryFilter(filter(), filters.fromBlock, filters.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return filters.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  parseEvents(events) {
    return events.map((e) => {
      const transaction = Object.fromEntries(Object.entries(e).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
      if (e.args) {
        const entries = Object.entries(e.args);
        const args = entries.slice(entries.length / 2, entries.length);
        const data = {};
        for (const [key, value] of args) {
          data[key] = value;
        }
        return {
          eventName: e.event || "",
          data,
          transaction
        };
      }
      return {
        eventName: e.event || "",
        data: {},
        transaction
      };
    });
  }
  toContractEvent(event, args, rawLog) {
    const transaction = Object.fromEntries(Object.entries(rawLog).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
    const results = {};
    event.inputs.forEach((param, index) => {
      if (Array.isArray(args[index])) {
        const obj = {};
        const components = param.components;
        if (components) {
          const arr = args[index];
          for (let i = 0; i < components.length; i++) {
            const name = components[i].name;
            obj[name] = arr[i];
          }
          results[param.name] = obj;
        }
      } else {
        results[param.name] = args[index];
      }
    });
    return {
      eventName: event.name,
      data: results,
      transaction
    };
  }
};
__name(ContractEvents, "ContractEvents");

// src/core/classes/contract-platform-fee.ts
init_esm_shims();
var ContractPlatformFee = class {
  featureName = FEATURE_PLATFORM_FEE.name;
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  async get() {
    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.readContract.getPlatformFeeInfo();
    return CommonPlatformFeeSchema.parse({
      platform_fee_recipient: platformFeeRecipient,
      platform_fee_basis_points: platformFeeBps
    });
  }
  async set(platformFeeInfo) {
    const parsed = CommonPlatformFeeSchema.parse(platformFeeInfo);
    return {
      receipt: await this.contractWrapper.sendTransaction("setPlatformFeeInfo", [
        parsed.platform_fee_recipient,
        parsed.platform_fee_basis_points
      ])
    };
  }
};
__name(ContractPlatformFee, "ContractPlatformFee");
var _NFTCollection = class extends Erc721 {
  signature = super.signature;
  _mint = this.mint;
  _burn = this.burn;
  _batchMint = this._mint.batch;
  _query = this.query;
  _owned = this._query.owned;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _NFTCollection.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _NFTCollection.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _NFTCollection.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.sales = new ContractPrimarySale(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.signature = new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
    this.events = new ContractEvents(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getOwned(walletAddress) {
    return this._owned.all(walletAddress);
  }
  async getOwnedTokenIds(walletAddress) {
    return this._owned.tokenIds(walletAddress);
  }
  async totalSupply() {
    return this._query.totalCirculatingSupply();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async mintToSelf(metadata) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    return this._mint.to(signerAddress, metadata);
  }
  async mintTo(walletAddress, metadata) {
    return this._mint.to(walletAddress, metadata);
  }
  async mintBatch(metadata) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    return this._batchMint.to(signerAddress, metadata);
  }
  async mintBatchTo(walletAddress, metadata) {
    return this._batchMint.to(walletAddress, metadata);
  }
  async burnToken(tokenId) {
    return this._burn.token(tokenId);
  }
};
var NFTCollection = _NFTCollection;
__name(NFTCollection, "NFTCollection");
__publicField(NFTCollection, "contractType", "nft-collection");
__publicField(NFTCollection, "contractRoles", [
  "admin",
  "minter",
  "transfer"
]);
__publicField(NFTCollection, "contractAbi", require_TokenERC721());
__publicField(NFTCollection, "schema", TokenErc721ContractSchema);

// src/contracts/edition-drop.ts
init_esm_shims();
var _a;
var _EditionDrop = class extends Erc1155 {
  _query = this.query;
  _burn = this.burn;
  _drop = this.drop;
  _claim = (_a = this.drop) == null ? void 0 : _a.claim;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _EditionDrop.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _EditionDrop.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _EditionDrop.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.sales = new ContractPrimarySale(this.contractWrapper);
    this.claimConditions = new DropErc1155ClaimConditions(this.contractWrapper, this.metadata, this.storage);
    this.events = new ContractEvents(this.contractWrapper);
    this.history = new DropErc1155History(this.events);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getOwned(walletAddress) {
    return this._query.owned(walletAddress);
  }
  async getTotalCount() {
    return this._query.totalCount();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async createBatch(metadatas, options) {
    return this._drop.lazyMint(metadatas, options);
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, checkERC20Allowance = true) {
    return this._claim.getClaimTransaction(destinationAddress, tokenId, quantity, checkERC20Allowance);
  }
  async claimTo(destinationAddress, tokenId, quantity, checkERC20Allowance = true) {
    return this._claim.to(destinationAddress, tokenId, quantity, checkERC20Allowance);
  }
  async claim(tokenId, quantity, checkERC20Allowance = true) {
    const address = await this.contractWrapper.getSignerAddress();
    return this.claimTo(address, tokenId, quantity, checkERC20Allowance);
  }
  async burnTokens(tokenId, amount) {
    return this._burn.tokens(tokenId, amount);
  }
};
var EditionDrop = _EditionDrop;
__name(EditionDrop, "EditionDrop");
__publicField(EditionDrop, "contractType", "edition-drop");
__publicField(EditionDrop, "contractRoles", [
  "admin",
  "minter",
  "transfer"
]);
__publicField(EditionDrop, "contractAbi", require_DropERC1155());
__publicField(EditionDrop, "schema", DropErc1155ContractSchema);

// src/contracts/edition.ts
init_esm_shims();
var _Edition = class extends Erc1155 {
  signature = super.signature;
  _query = this.query;
  _mint = this.mint;
  _burn = this.burn;
  _batchMint = this._mint.batch;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Edition.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _Edition.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Edition.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.sales = new ContractPrimarySale(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.signature = new Erc1155SignatureMintable(this.contractWrapper, this.storage, this.roles);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getOwned(walletAddress) {
    return this._query.owned(walletAddress);
  }
  async getTotalCount() {
    return this._query.totalCount();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async mintToSelf(metadataWithSupply) {
    return this._mint.to(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
  }
  async mintTo(to, metadataWithSupply) {
    return this._mint.to(to, metadataWithSupply);
  }
  async mintAdditionalSupply(tokenId, additionalSupply) {
    return this._mint.additionalSupplyTo(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);
  }
  async mintAdditionalSupplyTo(to, tokenId, additionalSupply) {
    return this._mint.additionalSupplyTo(to, tokenId, additionalSupply);
  }
  async mintBatch(metadatas) {
    return this._batchMint.to(await this.contractWrapper.getSignerAddress(), metadatas);
  }
  async mintBatchTo(to, metadataWithSupply) {
    return this._batchMint.to(to, metadataWithSupply);
  }
  async burnTokens(tokenId, amount) {
    return this._burn.tokens(tokenId, amount);
  }
};
var Edition = _Edition;
__name(Edition, "Edition");
__publicField(Edition, "contractType", "edition");
__publicField(Edition, "contractRoles", [
  "admin",
  "minter",
  "transfer"
]);
__publicField(Edition, "contractAbi", require_TokenERC1155());
__publicField(Edition, "schema", TokenErc1155ContractSchema);

// src/contracts/token.ts
init_esm_shims();
var _Token = class extends Erc20 {
  signature = super.signature;
  _mint = this.mint;
  _batchMint = this._mint.batch;
  _burn = this.burn;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Token.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _Token.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Token.contractRoles);
    this.events = new ContractEvents(this.contractWrapper);
    this.history = new TokenERC20History(this.contractWrapper, this.events);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.signature = new Erc20SignatureMintable(this.contractWrapper, this.roles);
  }
  async getVoteBalance() {
    return await this.getVoteBalanceOf(await this.contractWrapper.getSignerAddress());
  }
  async getVoteBalanceOf(account) {
    return await this.getValue(await this.contractWrapper.readContract.getVotes(account));
  }
  async getDelegation() {
    return await this.getDelegationOf(await this.contractWrapper.getSignerAddress());
  }
  async getDelegationOf(account) {
    return await this.contractWrapper.readContract.delegates(account);
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async mintToSelf(amount) {
    return this._mint.to(await this.contractWrapper.getSignerAddress(), amount);
  }
  async mintTo(to, amount) {
    return this._mint.to(to, amount);
  }
  async mintBatchTo(args) {
    return this._batchMint.to(args);
  }
  async delegateTo(delegateeAddress) {
    return {
      receipt: await this.contractWrapper.sendTransaction("delegate", [
        delegateeAddress
      ])
    };
  }
  async burnTokens(amount) {
    return this._burn.tokens(amount);
  }
  async burnFrom(holder, amount) {
    return this._burn.from(holder, amount);
  }
};
var Token = _Token;
__name(Token, "Token");
__publicField(Token, "contractType", "token");
__publicField(Token, "contractRoles", [
  "admin",
  "minter",
  "transfer"
]);
__publicField(Token, "contractAbi", require_TokenERC20());
__publicField(Token, "schema", TokenErc20ContractSchema);

// src/contracts/vote.ts
init_esm_shims();
var _Vote = class {
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Vote.contractAbi, options)) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.metadata = new ContractMetadata(this.contractWrapper, _Vote.schema, this.storage);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(proposalId) {
    const all = await this.getAll();
    const proposals = all.filter((p) => p.proposalId.eq(BigNumber.from(proposalId)));
    if (proposals.length === 0) {
      throw new Error("proposal not found");
    }
    return proposals[0];
  }
  async getAll() {
    return Promise.all((await this.contractWrapper.readContract.getAllProposals()).map(async (data) => ({
      proposalId: data.proposalId,
      proposer: data.proposer,
      description: data.description,
      startBlock: data.startBlock,
      endBlock: data.endBlock,
      state: await this.contractWrapper.readContract.state(data.proposalId),
      votes: await this.getProposalVotes(data.proposalId),
      executions: data[3].map((c, i) => ({
        toAddress: data.targets[i],
        nativeTokenValue: c,
        transactionData: data.calldatas[i]
      }))
    })));
  }
  async getProposalVotes(proposalId) {
    const votes = await this.contractWrapper.readContract.proposalVotes(proposalId);
    return [
      {
        type: VoteType.Against,
        label: "Against",
        count: votes.againstVotes
      },
      {
        type: VoteType.For,
        label: "For",
        count: votes.forVotes
      },
      {
        type: VoteType.Abstain,
        label: "Abstain",
        count: votes.abstainVotes
      }
    ];
  }
  async hasVoted(proposalId, account) {
    if (!account) {
      account = await this.contractWrapper.getSignerAddress();
    }
    return this.contractWrapper.readContract.hasVoted(proposalId, account);
  }
  async canExecute(proposalId) {
    await this.ensureExists(proposalId);
    const proposal = await this.get(proposalId);
    const tos = proposal.executions.map((p) => p.toAddress);
    const values = proposal.executions.map((p) => p.nativeTokenValue);
    const datas = proposal.executions.map((p) => p.transactionData);
    const descriptionHash = ethers.utils.id(proposal.description);
    try {
      await this.contractWrapper.callStatic().execute(tos, values, datas, descriptionHash);
      return true;
    } catch (e) {
      return false;
    }
  }
  async balance() {
    const balance = await this.contractWrapper.readContract.provider.getBalance(this.contractWrapper.readContract.address);
    return {
      name: "",
      symbol: "",
      decimals: 18,
      value: balance,
      displayValue: ethers.utils.formatUnits(balance, 18)
    };
  }
  async balanceOfToken(tokenAddress) {
    const erc20 = new Contract(tokenAddress, IERC20_default, this.contractWrapper.getProvider());
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), tokenAddress, await erc20.balanceOf(this.contractWrapper.readContract.address));
  }
  async ensureExists(proposalId) {
    try {
      await this.contractWrapper.readContract.state(proposalId);
    } catch (e) {
      throw Error(`Proposal ${proposalId} not found`);
    }
  }
  async settings() {
    const [votingDelay, votingPeriod, votingTokenAddress, votingQuorumFraction, proposalTokenThreshold] = await Promise.all([
      this.contractWrapper.readContract.votingDelay(),
      this.contractWrapper.readContract.votingPeriod(),
      this.contractWrapper.readContract.token(),
      this.contractWrapper.readContract.quorumNumerator(),
      this.contractWrapper.readContract.proposalThreshold()
    ]);
    const votingTokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), votingTokenAddress);
    return {
      votingDelay: votingDelay.toString(),
      votingPeriod: votingPeriod.toString(),
      votingTokenAddress,
      votingTokenMetadata,
      votingQuorumFraction: votingQuorumFraction.toString(),
      proposalTokenThreshold: proposalTokenThreshold.toString()
    };
  }
  async propose(description, executions) {
    if (!executions) {
      executions = [
        {
          toAddress: this.contractWrapper.readContract.address,
          nativeTokenValue: 0,
          transactionData: "0x"
        }
      ];
    }
    const tos = executions.map((p) => p.toAddress);
    const values = executions.map((p) => p.nativeTokenValue);
    const datas = executions.map((p) => p.transactionData);
    const receipt = await this.contractWrapper.sendTransaction("propose", [
      tos,
      values,
      datas,
      description
    ]);
    const event = this.contractWrapper.parseLogs("ProposalCreated", receipt == null ? void 0 : receipt.logs);
    return {
      id: event[0].args.proposalId,
      receipt
    };
  }
  async vote(proposalId, voteType, reason = "") {
    await this.ensureExists(proposalId);
    return {
      receipt: await this.contractWrapper.sendTransaction("castVoteWithReason", [
        proposalId,
        voteType,
        reason
      ])
    };
  }
  async execute(proposalId) {
    await this.ensureExists(proposalId);
    const proposal = await this.get(proposalId);
    const tos = proposal.executions.map((p) => p.toAddress);
    const values = proposal.executions.map((p) => p.nativeTokenValue);
    const datas = proposal.executions.map((p) => p.transactionData);
    const descriptionHash = ethers.utils.id(proposal.description);
    return {
      receipt: await this.contractWrapper.sendTransaction("execute", [
        tos,
        values,
        datas,
        descriptionHash
      ])
    };
  }
};
var Vote = _Vote;
__name(Vote, "Vote");
__publicField(Vote, "contractType", "vote");
__publicField(Vote, "contractAbi", require_VoteERC20());
__publicField(Vote, "schema", VoteContractSchema);

// src/contracts/split.ts
init_esm_shims();
var _Split = class {
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Split.contractAbi, options)) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.metadata = new ContractMetadata(this.contractWrapper, _Split.schema, this.storage);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getAllRecipients() {
    const recipients = [];
    let index = BigNumber.from(0);
    const totalRecipients = await this.contractWrapper.readContract.payeeCount();
    while (index.lt(totalRecipients)) {
      try {
        const recipientAddress = await this.contractWrapper.readContract.payee(index);
        recipients.push(await this.getRecipientSplitPercentage(recipientAddress));
        index = index.add(1);
      } catch (err) {
        if ("method" in err && err["method"].toLowerCase().includes("payee(uint256)")) {
          break;
        } else {
          throw err;
        }
      }
    }
    return recipients;
  }
  async balanceOfAllRecipients() {
    const recipients = await this.getAllRecipients();
    const balances = {};
    for (const recipient of recipients) {
      balances[recipient.address] = await this.balanceOf(recipient.address);
    }
    return balances;
  }
  async balanceOfTokenAllRecipients(tokenAddress) {
    const recipients = await this.getAllRecipients();
    const balances = {};
    for (const recipient of recipients) {
      balances[recipient.address] = await this.balanceOfToken(recipient.address, tokenAddress);
    }
    return balances;
  }
  async balanceOf(address) {
    const walletBalance = await this.contractWrapper.readContract.provider.getBalance(this.getAddress());
    const totalReleased = await this.contractWrapper.readContract["totalReleased()"]();
    const totalReceived = walletBalance.add(totalReleased);
    return this._pendingPayment(address, totalReceived, await this.contractWrapper.readContract["released(address)"](address));
  }
  async balanceOfToken(walletAddress, tokenAddress) {
    const erc20 = new Contract(tokenAddress, IERC20_default, this.contractWrapper.getProvider());
    const walletBalance = await erc20.balanceOf(this.getAddress());
    const totalReleased = await this.contractWrapper.readContract["totalReleased(address)"](tokenAddress);
    const totalReceived = walletBalance.add(totalReleased);
    const value = await this._pendingPayment(walletAddress, totalReceived, await this.contractWrapper.readContract["released(address,address)"](tokenAddress, walletAddress));
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), tokenAddress, value);
  }
  async getRecipientSplitPercentage(address) {
    const [totalShares, walletsShares] = await Promise.all([
      this.contractWrapper.readContract.totalShares(),
      this.contractWrapper.readContract.shares(address)
    ]);
    return {
      address,
      splitPercentage: walletsShares.mul(BigNumber.from(1e7)).div(totalShares).toNumber() / 1e5
    };
  }
  async withdraw(walletAddress) {
    return {
      receipt: await this.contractWrapper.sendTransaction("release(address)", [
        walletAddress
      ])
    };
  }
  async withdrawToken(walletAddress, tokenAddress) {
    return {
      receipt: await this.contractWrapper.sendTransaction("release(address,address)", [
        tokenAddress,
        walletAddress
      ])
    };
  }
  async distribute() {
    return {
      receipt: await this.contractWrapper.sendTransaction("distribute()", [])
    };
  }
  async distributeToken(tokenAddress) {
    return {
      receipt: await this.contractWrapper.sendTransaction("distribute(address)", [
        tokenAddress
      ])
    };
  }
  async _pendingPayment(address, totalReceived, alreadyReleased) {
    const addressReceived = totalReceived.mul(await this.contractWrapper.readContract.shares(address));
    const totalRoyaltyAvailable = addressReceived.div(await this.contractWrapper.readContract.totalShares());
    return totalRoyaltyAvailable.sub(alreadyReleased);
  }
};
var Split = _Split;
__name(Split, "Split");
__publicField(Split, "contractType", "split");
__publicField(Split, "contractAbi", require_Split());
__publicField(Split, "schema", SplitsContractSchema);

// src/contracts/marketplace.ts
init_esm_shims();
var _Marketplace = class {
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Marketplace.contractAbi, options)) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.metadata = new ContractMetadata(this.contractWrapper, _Marketplace.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Marketplace.contractRoles);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.direct = new MarketplaceDirect(this.contractWrapper, this.storage);
    this.auction = new MarketplaceAuction(this.contractWrapper, this.storage);
    this.events = new ContractEvents(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.listings(listingId);
    if (listing.assetContract === constants.AddressZero) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    switch (listing.listingType) {
      case ListingType.Auction: {
        return await this.auction.mapListing(listing);
      }
      case ListingType.Direct: {
        return await this.direct.mapListing(listing);
      }
      default: {
        throw new Error(`Unknown listing type: ${listing.listingType}`);
      }
    }
  }
  async getActiveListings(filter) {
    const rawListings = await this.getAllListingsNoFilter(true);
    const filtered = this.applyFilter(rawListings, filter);
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    return filtered.filter((l) => {
      return l.type === ListingType.Auction && BigNumber.from(l.endTimeInEpochSeconds).gt(now) && BigNumber.from(l.startTimeInEpochSeconds).lte(now) || l.type === ListingType.Direct && l.quantity > 0;
    });
  }
  async getAllListings(filter) {
    const rawListings = await this.getAllListingsNoFilter(false);
    return this.applyFilter(rawListings, filter);
  }
  getAll = this.getAllListings;
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalListings();
  }
  async isRestrictedToListerRoleOnly() {
    const anyoneCanList = await this.contractWrapper.readContract.hasRole(getRoleHash("lister"), constants.AddressZero);
    return !anyoneCanList;
  }
  async getBidBufferBps() {
    return this.contractWrapper.readContract.bidBufferBps();
  }
  async getTimeBufferInSeconds() {
    return this.contractWrapper.readContract.timeBuffer();
  }
  async buyoutListing(listingId, quantityDesired, receiver) {
    const listing = await this.contractWrapper.readContract.listings(listingId);
    if (listing.listingId.toString() !== listingId.toString()) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    switch (listing.listingType) {
      case ListingType.Direct: {
        invariant13(quantityDesired !== void 0, "quantityDesired is required when buying out a direct listing");
        return await this.direct.buyoutListing(listingId, quantityDesired, receiver);
      }
      case ListingType.Auction: {
        return await this.auction.buyoutListing(listingId);
      }
      default:
        throw Error(`Unknown listing type: ${listing.listingType}`);
    }
  }
  async setBidBufferBps(bufferBps) {
    await this.roles.verify([
      "admin"
    ], await this.contractWrapper.getSignerAddress());
    const timeBuffer = await this.getTimeBufferInSeconds();
    await this.contractWrapper.sendTransaction("setAuctionBuffers", [
      timeBuffer,
      BigNumber.from(bufferBps)
    ]);
  }
  async setTimeBufferInSeconds(bufferInSeconds) {
    await this.roles.verify([
      "admin"
    ], await this.contractWrapper.getSignerAddress());
    const bidBuffer = await this.getBidBufferBps();
    await this.contractWrapper.sendTransaction("setAuctionBuffers", [
      BigNumber.from(bufferInSeconds),
      bidBuffer
    ]);
  }
  async allowListingFromSpecificAssetOnly(contractAddress) {
    const encoded = [];
    const members = await this.roles.get("asset");
    if (members.includes(constants.AddressZero)) {
      encoded.push(this.encoder.encode("revokeRole", [
        getRoleHash("asset"),
        constants.AddressZero
      ]));
    }
    encoded.push(this.encoder.encode("grantRole", [
      getRoleHash("asset"),
      contractAddress
    ]));
    await this.contractWrapper.multiCall(encoded);
  }
  async allowListingFromAnyAsset() {
    const encoded = [];
    const members = await this.roles.get("asset");
    for (const addr in members) {
      encoded.push(this.encoder.encode("revokeRole", [
        getRoleHash("asset"),
        addr
      ]));
    }
    encoded.push(this.encoder.encode("grantRole", [
      getRoleHash("asset"),
      constants.AddressZero
    ]));
    await this.contractWrapper.multiCall(encoded);
  }
  async getAllListingsNoFilter(filterInvalidListings) {
    const listings = await Promise.all(Array.from(Array((await this.contractWrapper.readContract.totalListings()).toNumber()).keys()).map(async (i) => {
      let listing;
      try {
        listing = await this.getListing(i);
      } catch (err) {
        return void 0;
      }
      if (listing.type === ListingType.Auction) {
        return listing;
      }
      if (filterInvalidListings) {
        const { valid } = await this.direct.isStillValidListing(listing);
        if (!valid) {
          return void 0;
        }
      }
      return listing;
    }));
    return listings.filter((l) => l !== void 0);
  }
  applyFilter(listings, filter) {
    let rawListings = [
      ...listings
    ];
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const count = BigNumber.from((filter == null ? void 0 : filter.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    if (filter) {
      if (filter.seller) {
        rawListings = rawListings.filter((seller) => {
          var _a3;
          return seller.sellerAddress.toString().toLowerCase() === ((_a3 = filter == null ? void 0 : filter.seller) == null ? void 0 : _a3.toString().toLowerCase());
        });
      }
      if (filter.tokenContract) {
        rawListings = rawListings.filter((tokenContract) => {
          var _a3;
          return tokenContract.assetContractAddress.toString().toLowerCase() === ((_a3 = filter == null ? void 0 : filter.tokenContract) == null ? void 0 : _a3.toString().toLowerCase());
        });
      }
      if (filter.tokenId !== void 0) {
        rawListings = rawListings.filter((tokenContract) => {
          var _a3;
          return tokenContract.tokenId.toString() === ((_a3 = filter == null ? void 0 : filter.tokenId) == null ? void 0 : _a3.toString());
        });
      }
      rawListings = rawListings.filter((_, index) => index >= start);
      rawListings = rawListings.slice(0, count);
    }
    return rawListings;
  }
};
var Marketplace = _Marketplace;
__name(Marketplace, "Marketplace");
__publicField(Marketplace, "contractType", "marketplace");
__publicField(Marketplace, "contractRoles", [
  "admin",
  "lister",
  "asset"
]);
__publicField(Marketplace, "contractAbi", require_Marketplace());
__publicField(Marketplace, "schema", MarketplaceContractSchema);

// src/contracts/pack.ts
init_esm_shims();
var _Pack = class extends Erc1155 {
  _query = this.query;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Pack.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _Pack.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Pack.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getOwned(walletAddress) {
    return this._query.owned(walletAddress);
  }
  async getTotalCount() {
    return this._query.totalCount();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), ethers.constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async getPackContents(packId) {
    const { contents, perUnitAmounts } = await this.contractWrapper.readContract.getPackContents(packId);
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (let i = 0; i < contents.length; i++) {
      const reward = contents[i];
      const amount = perUnitAmounts[i];
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          const rewardAmount = ethers.utils.formatUnits(reward.totalAmount, tokenMetadata.decimals);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(rewardAmount).div(amount).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(reward.totalAmount).div(amount).toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async create(metadataWithRewards) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    return this.createTo(signerAddress, metadataWithRewards);
  }
  async createTo(to, metadataWithRewards) {
    const uri = await uploadOrExtractURI(metadataWithRewards.packMetadata, this.storage);
    const parsedMetadata = PackMetadataInputSchema.parse(metadataWithRewards);
    const { contents, numOfRewardUnits } = await this.toPackContentArgs(parsedMetadata);
    const receipt = await this.contractWrapper.sendTransaction("createPack", [
      contents,
      numOfRewardUnits,
      uri,
      parsedMetadata.openStartTime,
      parsedMetadata.rewardsPerPack,
      to
    ]);
    const event = this.contractWrapper.parseLogs("PackCreated", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("PackCreated event not found");
    }
    const packId = event[0].args.packId;
    return {
      id: packId,
      receipt,
      data: () => this.get(packId)
    };
  }
  async open(tokenId, amount = 1) {
    const receipt = await this.contractWrapper.sendTransaction("openPack", [
      tokenId,
      amount
    ]);
    const event = this.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("PackOpened event not found");
    }
    const rewards = event[0].args.rewardUnitsDistributed;
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (const reward of rewards) {
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: ethers.utils.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: reward.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async toPackContentArgs(metadataWithRewards) {
    const contents = [];
    const numOfRewardUnits = [];
    const { erc20Rewards, erc721Rewards, erc1155Rewards } = metadataWithRewards;
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    for (const erc20 of erc20Rewards) {
      const normalizedQuantity = await normalizePriceValue(provider, erc20.quantityPerReward, erc20.contractAddress);
      const totalQuantity = normalizedQuantity.mul(erc20.totalRewards);
      const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, totalQuantity);
      if (!hasAllowance) {
        throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${totalQuantity});

`);
      }
      numOfRewardUnits.push(erc20.totalRewards);
      contents.push({
        assetContract: erc20.contractAddress,
        tokenType: 0,
        totalAmount: totalQuantity,
        tokenId: 0
      });
    }
    for (const erc721 of erc721Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
      }
      numOfRewardUnits.push(1);
      contents.push({
        assetContract: erc721.contractAddress,
        tokenType: 1,
        totalAmount: 1,
        tokenId: erc721.tokenId
      });
    }
    for (const erc1155 of erc1155Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
      }
      numOfRewardUnits.push(erc1155.totalRewards);
      contents.push({
        assetContract: erc1155.contractAddress,
        tokenType: 2,
        totalAmount: BigNumber.from(erc1155.quantityPerReward).mul(BigNumber.from(erc1155.totalRewards)),
        tokenId: erc1155.tokenId
      });
    }
    return {
      contents,
      numOfRewardUnits
    };
  }
};
var Pack = _Pack;
__name(Pack, "Pack");
__publicField(Pack, "contractType", "pack");
__publicField(Pack, "contractRoles", [
  "admin",
  "minter",
  "pauser",
  "transfer"
]);
__publicField(Pack, "contractAbi", require_Pack());
__publicField(Pack, "schema", PackContractSchema);

// src/contracts/nft-drop.ts
init_esm_shims();
var _NFTDrop = class extends Erc721 {
  _query = this.query;
  _owned = this._query.owned;
  _burn = this.burn;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _NFTDrop.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _NFTDrop.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _NFTDrop.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.sales = new ContractPrimarySale(this.contractWrapper);
    this.claimConditions = new DropClaimConditions(this.contractWrapper, this.metadata, this.storage);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.revealer = new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.nextTokenIdToMint());
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getOwned(walletAddress) {
    return this._owned.all(walletAddress);
  }
  async getOwnedTokenIds(walletAddress) {
    return this._owned.tokenIds(walletAddress);
  }
  async totalSupply() {
    const claimed = await this.totalClaimedSupply();
    const unclaimed = await this.totalUnclaimedSupply();
    return claimed.add(unclaimed);
  }
  async getAllClaimed(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.contractWrapper.readContract.nextTokenIdToClaim()).toNumber(), start + count);
    return await Promise.all(Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())));
  }
  async getAllUnclaimed(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const firstTokenId = BigNumber.from(Math.max((await this.contractWrapper.readContract.nextTokenIdToClaim()).toNumber(), start));
    const maxId = BigNumber.from(Math.min((await this.contractWrapper.readContract.nextTokenIdToMint()).toNumber(), firstTokenId.toNumber() + count));
    return await Promise.all(Array.from(Array(maxId.sub(firstTokenId).toNumber()).keys()).map((i) => this.getTokenMetadata(firstTokenId.add(i).toString())));
  }
  async totalClaimedSupply() {
    return await this.contractWrapper.readContract.nextTokenIdToClaim();
  }
  async totalUnclaimedSupply() {
    return (await this.contractWrapper.readContract.nextTokenIdToMint()).sub(await this.totalClaimedSupply());
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async createBatch(metadatas, options) {
    var _a3;
    const startFileNumber = await this.contractWrapper.readContract.nextTokenIdToMint();
    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), this.contractWrapper.readContract.address, await ((_a3 = this.contractWrapper.getSigner()) == null ? void 0 : _a3.getAddress()), options);
    const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
    for (let i = 0; i < batch.length; i++) {
      const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
      if (baseUri !== uri) {
        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
      }
    }
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [
      batch.length,
      baseUri.endsWith("/") ? baseUri : `${baseUri}/`,
      ethers.utils.toUtf8Bytes("")
    ]);
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = event[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.getTokenMetadata(id)
      });
    }
    return results;
  }
  async getClaimTransaction(destinationAddress, quantity, checkERC20Allowance = true) {
    const claimVerification = await this.prepareClaim(quantity, checkERC20Allowance);
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: [
        destinationAddress,
        quantity,
        claimVerification.currencyAddress,
        claimVerification.price,
        claimVerification.proofs,
        claimVerification.maxQuantityPerTransaction
      ],
      overrides: claimVerification.overrides
    });
  }
  async claimTo(destinationAddress, quantity, checkERC20Allowance = true) {
    const task = await this.getClaimTransaction(destinationAddress, quantity, checkERC20Allowance);
    const { receipt } = await task.execute();
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(quantity);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.get(id)
      });
    }
    return results;
  }
  async claim(quantity, checkERC20Allowance = true) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), quantity, checkERC20Allowance);
  }
  async burnToken(tokenId) {
    return this._burn.token(tokenId);
  }
  async prepareClaim(quantity, checkERC20Allowance) {
    return prepareClaim(quantity, await this.claimConditions.getActive(), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance);
  }
};
var NFTDrop = _NFTDrop;
__name(NFTDrop, "NFTDrop");
__publicField(NFTDrop, "contractType", "nft-drop");
__publicField(NFTDrop, "contractRoles", [
  "admin",
  "minter",
  "transfer"
]);
__publicField(NFTDrop, "contractAbi", require_DropERC721());
__publicField(NFTDrop, "schema", DropErc721ContractSchema);

// src/contracts/token-drop.ts
init_esm_shims();

// src/schema/contracts/drop-erc20.ts
init_esm_shims();
var DropErc20ContractInput = CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc20ContractOutput = CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc20ContractDeploy = DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};

// src/contracts/token-drop.ts
var _TokenDrop = class extends Erc20 {
  _burn = this.burn;
  _drop = this.drop;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _TokenDrop.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _TokenDrop.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _TokenDrop.contractRoles);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.sales = new ContractPrimarySale(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.claimConditions = new DropClaimConditions(this.contractWrapper, this.metadata, this.storage);
  }
  async getVoteBalance() {
    return await this.getVoteBalanceOf(await this.contractWrapper.getSignerAddress());
  }
  async getVoteBalanceOf(account) {
    return await this.getValue(await this.contractWrapper.readContract.getVotes(account));
  }
  async getDelegation() {
    return await this.getDelegationOf(await this.contractWrapper.getSignerAddress());
  }
  async getDelegationOf(account) {
    return await this.contractWrapper.readContract.delegates(account);
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async claim(amount, checkERC20Allowance = true) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), amount, checkERC20Allowance);
  }
  async claimTo(destinationAddress, amount, checkERC20Allowance = true) {
    return this._drop.claimTo(destinationAddress, amount, checkERC20Allowance);
  }
  async delegateTo(delegateeAddress) {
    return {
      receipt: await this.contractWrapper.sendTransaction("delegate", [
        delegateeAddress
      ])
    };
  }
  async burnTokens(amount) {
    return this._burn.tokens(amount);
  }
  async burnFrom(holder, amount) {
    return this._burn.from(holder, amount);
  }
};
var TokenDrop = _TokenDrop;
__name(TokenDrop, "TokenDrop");
__publicField(TokenDrop, "contractType", "token-drop");
__publicField(TokenDrop, "contractRoles", [
  "admin",
  "transfer"
]);
__publicField(TokenDrop, "contractAbi", require_DropERC20());
__publicField(TokenDrop, "schema", DropErc20ContractSchema);

// src/contracts/smart-contract.ts
init_esm_shims();

// src/core/classes/contract-published-metadata.ts
init_esm_shims();
var ContractPublishedMetadata = class {
  constructor(contractWrapper, storage) {
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async get() {
    if (this._cachedMetadata) {
      return this._cachedMetadata;
    }
    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);
    return this._cachedMetadata;
  }
  async extractFunctions() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
  async extractEvents() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
};
__name(ContractPublishedMetadata, "ContractPublishedMetadata");

// src/contracts/smart-contract.ts
var _SmartContract = class {
  constructor(network, address, abi, storage, options = {}, contractWrapper = new ContractWrapper(network, address, abi, options)) {
    this.options = options;
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);
    this.metadata = new ContractMetadata(this.contractWrapper, _SmartContract.schema, this.storage);
    this.royalties = this.detectRoyalties();
    this.roles = this.detectRoles();
    this.sales = this.detectPrimarySales();
    this.platformFees = this.detectPlatformFees();
    this.token = this.detectErc20();
    this.nft = this.detectErc721();
    this.edition = this.detectErc1155();
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async call(functionName, ...args) {
    let txOptions;
    try {
      if (args.length > 0 && typeof args[args.length - 1] === "object") {
        const last = args[args.length - 1];
        txOptions = CallOverrideSchema.parse(last);
        args = args.slice(0, args.length - 1);
      }
    } catch (e) {
    }
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi));
    const fn = functions.find((f) => f.name === functionName);
    if (!fn) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    if (fn.inputs.length !== args.length) {
      throw new Error(`Function "${functionName}" requires ${fn.inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${fn.signature}`);
    }
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      return this.contractWrapper.readContract[functionName](...args);
    } else {
      const receipt = await this.contractWrapper.sendTransaction(functionName, args, txOptions);
      return {
        receipt
      };
    }
  }
  detectRoyalties() {
    if (detectContractFeature(this.contractWrapper, "Royalty")) {
      const metadata = new ContractMetadata(this.contractWrapper, _SmartContract.schema, this.storage);
      return new ContractRoyalty(this.contractWrapper, metadata);
    }
    return void 0;
  }
  detectRoles() {
    if (detectContractFeature(this.contractWrapper, "Permissions")) {
      return new ContractRoles(this.contractWrapper, ALL_ROLES);
    }
    return void 0;
  }
  detectPrimarySales() {
    if (detectContractFeature(this.contractWrapper, "PrimarySale")) {
      return new ContractPrimarySale(this.contractWrapper);
    }
    return void 0;
  }
  detectPlatformFees() {
    if (detectContractFeature(this.contractWrapper, "PlatformFee")) {
      return new ContractPlatformFee(this.contractWrapper);
    }
    return void 0;
  }
  detectErc20() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20(this.contractWrapper, this.storage, this.options);
    }
    return void 0;
  }
  detectErc721() {
    if (detectContractFeature(this.contractWrapper, "ERC721")) {
      return new Erc721(this.contractWrapper, this.storage, this.options);
    }
    return void 0;
  }
  detectErc1155() {
    if (detectContractFeature(this.contractWrapper, "ERC1155")) {
      return new Erc1155(this.contractWrapper, this.storage, this.options);
    }
    return void 0;
  }
};
var SmartContract = _SmartContract;
__name(SmartContract, "SmartContract");
__publicField(SmartContract, "contractType", "custom");
__publicField(SmartContract, "schema", CustomContractSchema);

// src/contracts/signature-drop.ts
init_esm_shims();
var _a2, _b, _c;
var _SignatureDrop = class extends Erc721 {
  claimConditions = (_b = (_a2 = this.drop) == null ? void 0 : _a2.claim) == null ? void 0 : _b.conditions;
  signature = super.signature;
  _query = this.query;
  _owned = this._query.owned;
  _burn = this.burn;
  _drop = this.drop;
  _claim = (_c = this.drop) == null ? void 0 : _c.claim;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _SignatureDrop.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _SignatureDrop.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _SignatureDrop.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.sales = new ContractPrimarySale(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.revealer = new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.nextTokenIdToMint());
    this.signature = new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getOwned(walletAddress) {
    return this._owned.all(walletAddress);
  }
  async getOwnedTokenIds(walletAddress) {
    return this._owned.tokenIds(walletAddress);
  }
  async totalSupply() {
    const claimed = await this.totalClaimedSupply();
    const unclaimed = await this.totalUnclaimedSupply();
    return claimed.add(unclaimed);
  }
  async getAllClaimed(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.totalClaimedSupply()).toNumber(), start + count);
    return await Promise.all(Array.from(Array(maxId).keys()).map((i) => this.get(i.toString())));
  }
  async getAllUnclaimed(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const firstTokenId = BigNumber.from(Math.max((await this.totalClaimedSupply()).toNumber(), start));
    const maxId = BigNumber.from(Math.min((await this.contractWrapper.readContract.nextTokenIdToMint()).toNumber(), firstTokenId.toNumber() + count));
    return await Promise.all(Array.from(Array(maxId.sub(firstTokenId).toNumber()).keys()).map((i) => this.getTokenMetadata(firstTokenId.add(i).toString())));
  }
  async totalClaimedSupply() {
    return await this.contractWrapper.readContract.totalMinted();
  }
  async totalUnclaimedSupply() {
    const maxSupply = await this.contractWrapper.readContract.nextTokenIdToMint();
    return maxSupply.sub(await this.totalClaimedSupply());
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async createBatch(metadatas, options) {
    return this._drop.lazyMint(metadatas, options);
  }
  async getClaimTransaction(destinationAddress, quantity, checkERC20Allowance = true) {
    return this._claim.getClaimTransaction(destinationAddress, quantity, checkERC20Allowance);
  }
  async claimTo(destinationAddress, quantity, checkERC20Allowance = true) {
    return this._claim.to(destinationAddress, quantity, checkERC20Allowance);
  }
  async claim(quantity, checkERC20Allowance = true) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), quantity, checkERC20Allowance);
  }
  async burnToken(tokenId) {
    return this._burn.token(tokenId);
  }
};
var SignatureDrop = _SignatureDrop;
__name(SignatureDrop, "SignatureDrop");
__publicField(SignatureDrop, "contractType", "signature-drop");
__publicField(SignatureDrop, "contractRoles", [
  "admin",
  "minter",
  "transfer"
]);
__publicField(SignatureDrop, "contractAbi", require_SignatureDrop());
__publicField(SignatureDrop, "schema", DropErc721ContractSchema);

// src/contracts/multiwrap.ts
init_esm_shims();

// src/schema/contracts/multiwrap.ts
init_esm_shims();
var MultiwrapContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var MultiwrapContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var MultiwrapContractDeploy = MultiwrapContractInput.merge(CommonTrustedForwarderSchema);
var MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};
var _Multiwrap = class extends Erc721 {
  _query = this.query;
  constructor(network, address, storage, options = {}, contractWrapper = new ContractWrapper(network, address, _Multiwrap.contractAbi, options)) {
    super(contractWrapper, storage, options);
    this.metadata = new ContractMetadata(this.contractWrapper, _Multiwrap.schema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Multiwrap.contractRoles);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
  }
  async getAll(queryParams) {
    return this._query.all(queryParams);
  }
  async getWrappedContents(wrappedTokenId) {
    const wrappedTokens = await this.contractWrapper.readContract.getWrappedContents(wrappedTokenId);
    const erc20Tokens = [];
    const erc721Tokens = [];
    const erc1155Tokens = [];
    for (const token of wrappedTokens) {
      switch (token.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), token.assetContract);
          erc20Tokens.push({
            contractAddress: token.assetContract,
            quantity: ethers.utils.formatUnits(token.totalAmount, tokenMetadata.decimals)
          });
          break;
        }
        case 1: {
          erc721Tokens.push({
            contractAddress: token.assetContract,
            tokenId: token.tokenId
          });
          break;
        }
        case 2: {
          erc1155Tokens.push({
            contractAddress: token.assetContract,
            tokenId: token.tokenId,
            quantity: token.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Tokens,
      erc721Tokens,
      erc1155Tokens
    };
  }
  async wrap(contents, wrappedTokenMetadata, recipientAddress) {
    const uri = await uploadOrExtractURI(wrappedTokenMetadata, this.storage);
    const recipient = recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress();
    const tokens = await this.toTokenStructList(contents);
    const receipt = await this.contractWrapper.sendTransaction("wrap", [
      tokens,
      uri,
      recipient
    ]);
    const event = this.contractWrapper.parseLogs("TokensWrapped", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("TokensWrapped event not found");
    }
    const tokenId = event[0].args.tokenIdOfWrappedToken;
    return {
      id: tokenId,
      receipt,
      data: () => this.get(tokenId)
    };
  }
  async unwrap(wrappedTokenId, recipientAddress) {
    const recipient = recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress();
    return {
      receipt: await this.contractWrapper.sendTransaction("unwrap", [
        wrappedTokenId,
        recipient
      ])
    };
  }
  async toTokenStructList(contents) {
    const tokens = [];
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    if (contents.erc20Tokens) {
      for (const erc20 of contents.erc20Tokens) {
        const normalizedQuantity = await normalizePriceValue(provider, erc20.quantity, erc20.contractAddress);
        const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, normalizedQuantity);
        if (!hasAllowance) {
          throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${erc20.quantity});

`);
        }
        tokens.push({
          assetContract: erc20.contractAddress,
          totalAmount: normalizedQuantity,
          tokenId: 0,
          tokenType: 0
        });
      }
    }
    if (contents.erc721Tokens) {
      for (const erc721 of contents.erc721Tokens) {
        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
        if (!isApproved) {
          throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
        }
        tokens.push({
          assetContract: erc721.contractAddress,
          totalAmount: 0,
          tokenId: erc721.tokenId,
          tokenType: 1
        });
      }
    }
    if (contents.erc1155Tokens) {
      for (const erc1155 of contents.erc1155Tokens) {
        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
        if (!isApproved) {
          throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
        }
        tokens.push({
          assetContract: erc1155.contractAddress,
          totalAmount: erc1155.quantity,
          tokenId: erc1155.tokenId,
          tokenType: 2
        });
      }
    }
    return tokens;
  }
};
var Multiwrap = _Multiwrap;
__name(Multiwrap, "Multiwrap");
__publicField(Multiwrap, "contractType", "multiwrap");
__publicField(Multiwrap, "contractRoles", [
  "transfer",
  "minter",
  "unwrap",
  "asset"
]);
__publicField(Multiwrap, "contractAbi", require_Multiwrap());
__publicField(Multiwrap, "schema", MultiwrapContractSchema);

// src/contracts/maps.ts
var KNOWN_CONTRACTS_MAP = {
  [NFTDrop.contractType]: NFTDrop,
  [SignatureDrop.contractType]: SignatureDrop,
  [NFTCollection.contractType]: NFTCollection,
  [EditionDrop.contractType]: EditionDrop,
  [Edition.contractType]: Edition,
  [TokenDrop.contractType]: TokenDrop,
  [Token.contractType]: Token,
  [Vote.contractType]: Vote,
  [Split.contractType]: Split,
  [Marketplace.contractType]: Marketplace,
  [Pack.contractType]: Pack,
  [Multiwrap.contractType]: Multiwrap
};
var CONTRACTS_MAP = __spreadProps(__spreadValues({}, KNOWN_CONTRACTS_MAP), {
  [SmartContract.contractType]: SmartContract
});
var REMOTE_CONTRACT_NAME = {
  [NFTDrop.contractType]: "DropERC721",
  [SignatureDrop.contractType]: "SignatureDrop",
  [NFTCollection.contractType]: "TokenERC721",
  [EditionDrop.contractType]: "DropERC1155",
  [Edition.contractType]: "TokenERC1155",
  [TokenDrop.contractType]: "DropERC20",
  [Token.contractType]: "TokenERC20",
  [Vote.contractType]: "VoteERC20",
  [Split.contractType]: "Split",
  [Marketplace.contractType]: "Marketplace",
  [Pack.contractType]: "Pack",
  [SmartContract.contractType]: "Custom",
  [Multiwrap.contractType]: "Multiwrap"
};
var REMOTE_CONTRACT_TO_CONTRACT_TYPE = {
  DropERC721: NFTDrop.contractType,
  SignatureDrop: SignatureDrop.contractType,
  TokenERC721: NFTCollection.contractType,
  DropERC1155: EditionDrop.contractType,
  TokenERC1155: Edition.contractType,
  DropERC20: TokenDrop.contractType,
  TokenERC20: Token.contractType,
  VoteERC20: Vote.contractType,
  Split: Split.contractType,
  Marketplace: Marketplace.contractType,
  Pack: Pack.contractType,
  Multiwrap: Multiwrap.contractType
};

// src/core/classes/factory.ts
var ContractFactory4 = class extends ContractWrapper {
  constructor(factoryAddr, network, storage, options) {
    super(network, factoryAddr, TWFactory__factory.abi, options);
    this.storage = storage;
  }
  async deploy(contractType, contractMetadata) {
    var _a3;
    const contract = CONTRACTS_MAP[contractType];
    const metadata = contract.schema.deploy.parse(contractMetadata);
    const contractURI = await this.storage.uploadMetadata(metadata, this.readContract.address, await ((_a3 = this.getSigner()) == null ? void 0 : _a3.getAddress()));
    const encodedFunc = Contract.getInterface(contract.contractAbi).encodeFunctionData("initialize", await this.getDeployArguments(contractType, metadata, contractURI));
    const contractName = REMOTE_CONTRACT_NAME[contractType];
    const encodedType = ethers.utils.formatBytes32String(contractName);
    let receipt;
    try {
      receipt = await this.sendTransaction("deployProxy", [
        encodedType,
        encodedFunc
      ]);
    } catch (e) {
      const blockNumber = await this.getProvider().getBlockNumber();
      receipt = await this.sendTransaction("deployProxyDeterministic", [
        encodedType,
        encodedFunc,
        ethers.utils.formatBytes32String(blockNumber.toString())
      ]);
    }
    const events = this.parseLogs("ProxyDeployed", receipt.logs);
    if (events.length < 1) {
      throw new Error("No ProxyDeployed event found");
    }
    return events[0].args.proxy;
  }
  async deployProxyByImplementation(implementationAddress, implementationAbi, initializerFunction, initializerArgs) {
    const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
    const blockNumber = await this.getProvider().getBlockNumber();
    const receipt = await this.sendTransaction("deployProxyByImplementation", [
      implementationAddress,
      encodedFunc,
      ethers.utils.formatBytes32String(blockNumber.toString())
    ]);
    const events = this.parseLogs("ProxyDeployed", receipt.logs);
    if (events.length < 1) {
      throw new Error("No ProxyDeployed event found");
    }
    return events[0].args.proxy;
  }
  async getDeployArguments(contractType, metadata, contractURI) {
    let trustedForwarders = await this.getDefaultTrustedForwarders();
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    switch (contractType) {
      case NFTDrop.contractType:
      case NFTCollection.contractType:
        const erc721metadata = NFTDrop.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          erc721metadata.name,
          erc721metadata.symbol,
          contractURI,
          trustedForwarders,
          erc721metadata.primary_sale_recipient,
          erc721metadata.fee_recipient,
          erc721metadata.seller_fee_basis_points,
          erc721metadata.platform_fee_basis_points,
          erc721metadata.platform_fee_recipient
        ];
      case SignatureDrop.contractType:
        const signatureDropmetadata = SignatureDrop.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          signatureDropmetadata.name,
          signatureDropmetadata.symbol,
          contractURI,
          trustedForwarders,
          signatureDropmetadata.primary_sale_recipient,
          signatureDropmetadata.fee_recipient,
          signatureDropmetadata.seller_fee_basis_points,
          signatureDropmetadata.platform_fee_basis_points,
          signatureDropmetadata.platform_fee_recipient
        ];
      case Multiwrap.contractType:
        const multiwrapMetadata = Multiwrap.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          multiwrapMetadata.name,
          multiwrapMetadata.symbol,
          contractURI,
          trustedForwarders,
          multiwrapMetadata.fee_recipient,
          multiwrapMetadata.seller_fee_basis_points
        ];
      case EditionDrop.contractType:
      case Edition.contractType:
        const erc1155metadata = EditionDrop.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          erc1155metadata.name,
          erc1155metadata.symbol,
          contractURI,
          trustedForwarders,
          erc1155metadata.primary_sale_recipient,
          erc1155metadata.fee_recipient,
          erc1155metadata.seller_fee_basis_points,
          erc1155metadata.platform_fee_basis_points,
          erc1155metadata.platform_fee_recipient
        ];
      case TokenDrop.contractType:
      case Token.contractType:
        const erc20metadata = Token.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          erc20metadata.name,
          erc20metadata.symbol,
          contractURI,
          trustedForwarders,
          erc20metadata.primary_sale_recipient,
          erc20metadata.platform_fee_recipient,
          erc20metadata.platform_fee_basis_points
        ];
      case Vote.contractType:
        const voteMetadata = Vote.schema.deploy.parse(metadata);
        return [
          voteMetadata.name,
          contractURI,
          trustedForwarders,
          voteMetadata.voting_token_address,
          voteMetadata.voting_delay_in_blocks,
          voteMetadata.voting_period_in_blocks,
          BigNumber.from(voteMetadata.proposal_token_threshold),
          voteMetadata.voting_quorum_fraction
        ];
      case Split.contractType:
        const splitsMetadata = Split.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          contractURI,
          trustedForwarders,
          splitsMetadata.recipients.map((s) => s.address),
          splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))
        ];
      case Marketplace.contractType:
        const marketplaceMetadata = Marketplace.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          contractURI,
          trustedForwarders,
          marketplaceMetadata.platform_fee_recipient,
          marketplaceMetadata.platform_fee_basis_points
        ];
      case Pack.contractType:
        const packsMetadata = Pack.schema.deploy.parse(metadata);
        return [
          await this.getSignerAddress(),
          packsMetadata.name,
          packsMetadata.symbol,
          contractURI,
          trustedForwarders,
          packsMetadata.fee_recipient,
          packsMetadata.seller_fee_basis_points
        ];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    const chainId = await this.getChainID();
    const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
    const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].biconomyForwarder : constants.AddressZero;
    return biconomyForwarder !== constants.AddressZero ? [
      OZ_DEFENDER_FORWARDER_ADDRESS,
      biconomyForwarder
    ] : [
      OZ_DEFENDER_FORWARDER_ADDRESS
    ];
  }
};
__name(ContractFactory4, "ContractFactory");

// src/core/sdk.ts
init_esm_shims();

// src/core/classes/contract-publisher.ts
init_esm_shims();

// abis/ContractPublisher.json
var ContractPublisher_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "contract IContractPublisher",
        name: "_prevPublisher",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "publishedContract",
        type: "tuple"
      }
    ],
    name: "ContractPublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: true,
        internalType: "string",
        name: "contractId",
        type: "string"
      }
    ],
    name: "ContractUnpublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isPaused",
        type: "bool"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      }
    ],
    name: "getAllPublishedContracts",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContract",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "published",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContractVersions",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "compilerMetadataUri",
        type: "string"
      }
    ],
    name: "getPublishedUriFromCompilerUri",
    outputs: [
      {
        internalType: "string[]",
        name: "publishedMetadataUris",
        type: "string[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      }
    ],
    name: "getPublisherProfileUri",
    outputs: [
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "prevPublisher",
    outputs: [
      {
        internalType: "contract IContractPublisher",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      },
      {
        internalType: "string",
        name: "_publishMetadataUri",
        type: "string"
      },
      {
        internalType: "string",
        name: "_compilerMetadataUri",
        type: "string"
      },
      {
        internalType: "bytes32",
        name: "_bytecodeHash",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "publishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_pause",
        type: "bool"
      }
    ],
    name: "setPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "setPublisherProfileUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "unpublishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/core/classes/contract-publisher.ts
var ContractPublisher = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    this.storage = storage;
    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisher_default, options);
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.publisher.updateSignerOrProvider(network);
  }
  async extractConstructorParams(metadataUri) {
    return extractConstructorParams(metadataUri, this.storage);
  }
  async extractFunctions(predeployMetadataUri) {
    return extractFunctions(predeployMetadataUri, this.storage);
  }
  async fetchCompilerMetadataFromPredeployURI(predeployUri) {
    return fetchPreDeployMetadata(predeployUri, this.storage);
  }
  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {
    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);
    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : void 0;
    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : void 0;
    return {
      preDeployMetadata: preDeployMetadataFetched,
      latestPublishedContractMetadata
    };
  }
  async fetchCompilerMetadataFromAddress(address) {
    return fetchContractMetadataFromAddress(address, this.getProvider(), this.storage);
  }
  async fetchPublishedContractInfo(contract) {
    return {
      name: contract.id,
      publishedTimestamp: contract.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)
    };
  }
  async fetchFullPublishMetadata(publishedMetadataUri) {
    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);
  }
  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {
    const publishedMetadataUri = await this.publisher.readContract.getPublishedUriFromCompilerUri(compilerMetadataUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);
    }
    return await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => this.fetchFullPublishMetadata(uri)));
  }
  async fetchContractSourcesFromAddress(address) {
    const metadata = await this.fetchCompilerMetadataFromAddress(address);
    return await fetchSourceFilesFromMetadata(metadata, this.storage);
  }
  async updatePublisherProfile(profileMetadata) {
    const signer = this.getSigner();
    invariant13(signer, "A signer is required");
    const publisher = await signer.getAddress();
    const profileUri = await this.storage.uploadMetadata(profileMetadata);
    return {
      receipt: await this.publisher.sendTransaction("setPublisherProfileUri", [
        publisher,
        profileUri
      ])
    };
  }
  async getPublisherProfile(publisherAddress) {
    const profileUri = await this.publisher.readContract.getPublisherProfileUri(publisherAddress);
    if (!profileUri || profileUri.length === 0) {
      return {};
    }
    return ProfileSchemaOutput.parse(await this.storage.get(profileUri));
  }
  async getAll(publisherAddress) {
    const data = await this.publisher.readContract.getAllPublishedContracts(publisherAddress);
    const map = data.reduce((acc, curr) => {
      acc[curr.contractId] = curr;
      return acc;
    }, {});
    return Object.entries(map).map(([_, struct]) => this.toPublishedContract(struct));
  }
  async getAllVersions(publisherAddress, contractId) {
    const contractStructs = await this.publisher.readContract.getPublishedContractVersions(publisherAddress, contractId);
    if (contractStructs.length === 0) {
      throw Error("Not found");
    }
    return contractStructs.map((d) => this.toPublishedContract(d));
  }
  async getLatest(publisherAddress, contractId) {
    const model = await this.publisher.readContract.getPublishedContract(publisherAddress, contractId);
    return this.toPublishedContract(model);
  }
  async publish(predeployUri, extraMetadata) {
    const signer = this.getSigner();
    invariant13(signer, "A signer is required");
    const publisher = await signer.getAddress();
    const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);
    const latestContract = await this.getLatest(publisher, predeployMetadata.name);
    if (latestContract && latestContract.metadataUri) {
      const latestMetadata = await this.fetchPublishedContractInfo(latestContract);
      const latestVersion = latestMetadata.publishedMetadata.version;
      if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {
        throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);
      }
    }
    const fetchedBytecode = await this.storage.getRaw(predeployMetadata.bytecodeUri);
    const bytecode = fetchedBytecode.startsWith("0x") ? fetchedBytecode : `0x${fetchedBytecode}`;
    const bytecodeHash = utils.solidityKeccak256([
      "bytes"
    ], [
      bytecode
    ]);
    const contractId = predeployMetadata.name;
    const fullMetadata = FullPublishMetadataSchema.parse(__spreadProps(__spreadValues(__spreadValues({}, extraMetadata), predeployMetadata), {
      publisher
    }));
    const fullMetadataUri = await this.storage.uploadMetadata(fullMetadata);
    const receipt = await this.publisher.sendTransaction("publishContract", [
      publisher,
      contractId,
      fullMetadataUri,
      predeployMetadata.metadataUri,
      bytecodeHash,
      constants.AddressZero
    ]);
    const events = this.publisher.parseLogs("ContractPublished", receipt.logs);
    if (events.length < 1) {
      throw new Error("No ContractPublished event found");
    }
    const contract = events[0].args.publishedContract;
    return {
      receipt,
      data: async () => this.toPublishedContract(contract)
    };
  }
  async unpublish(publisher, contractId) {
    return {
      receipt: await this.publisher.sendTransaction("unpublishContract", [
        publisher,
        contractId
      ])
    };
  }
  toPublishedContract(contractModel) {
    return PublishedContractSchema.parse({
      id: contractModel.contractId,
      timestamp: contractModel.publishTimestamp,
      metadataUri: contractModel.publishMetadataUri
    });
  }
};
__name(ContractPublisher, "ContractPublisher");

// src/core/wallet/UserWallet.ts
init_esm_shims();
var UserWallet = class {
  constructor(network, options) {
    this.connection = new RPCConnectionHandler(network, options);
    this.options = options;
  }
  onNetworkUpdated(network) {
    this.connection.updateSignerOrProvider(network);
  }
  async transfer(to, amount, currencyAddress = NATIVE_TOKEN_ADDRESS) {
    const signer = this.requireWallet();
    const amountInWei = await normalizePriceValue(this.connection.getProvider(), amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const from = await signer.getAddress();
      const tx = await signer.sendTransaction({
        from,
        to,
        value: amountInWei
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      return {
        receipt: await this.createErc20(currencyAddress).sendTransaction("transfer", [
          to,
          amountInWei
        ])
      };
    }
  }
  async balance(currencyAddress = NATIVE_TOKEN_ADDRESS) {
    this.requireWallet();
    const provider = this.connection.getProvider();
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await provider.getBalance(await this.getAddress());
    } else {
      balance = await this.createErc20(currencyAddress).readContract.balanceOf(await this.getAddress());
    }
    return await fetchCurrencyValue(provider, currencyAddress, balance);
  }
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  recoverAddress(message, signature) {
    const messageHash = ethers.utils.hashMessage(message);
    const messageHashBytes = ethers.utils.arrayify(messageHash);
    return ethers.utils.recoverAddress(messageHashBytes, signature);
  }
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const tx = await signer.sendTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant13(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, IERC20_default, this.options);
  }
};
__name(UserWallet, "UserWallet");

// src/core/sdk.ts
var ThirdwebSDK = class extends RPCConnectionHandler {
  static fromSigner(signer, network, options = {}, storage = new IpfsStorage()) {
    const sdk = new ThirdwebSDK(network || signer, options, storage);
    sdk.updateSignerOrProvider(signer);
    return sdk;
  }
  static fromPrivateKey(privateKey, network, options = {}, storage = new IpfsStorage()) {
    const signerOrProvider = getProviderForNetwork(network);
    const provider = Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : typeof signerOrProvider === "string" ? getReadOnlyProvider(signerOrProvider) : signerOrProvider;
    const signer = new ethers.Wallet(privateKey, provider);
    return ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  contractCache = /* @__PURE__ */ new Map();
  constructor(network, options = {}, storage = new IpfsStorage()) {
    const signerOrProvider = getProviderForNetwork(network);
    super(signerOrProvider, options);
    this.storageHandler = storage;
    this.storage = new RemoteStorage(storage);
    this.wallet = new UserWallet(signerOrProvider, options);
    this.deployer = new ContractDeployer(signerOrProvider, options, storage);
    this.auth = new WalletAuthenticator(signerOrProvider, this.wallet, options);
    this._publisher = new ContractPublisher(signerOrProvider, this.options, this.storageHandler);
  }
  getNFTDrop(contractAddress) {
    return this.getBuiltInContract(contractAddress, NFTDrop.contractType);
  }
  getSignatureDrop(contractAddress) {
    return this.getBuiltInContract(contractAddress, SignatureDrop.contractType);
  }
  getNFTCollection(address) {
    return this.getBuiltInContract(address, NFTCollection.contractType);
  }
  getEditionDrop(address) {
    return this.getBuiltInContract(address, EditionDrop.contractType);
  }
  getEdition(address) {
    return this.getBuiltInContract(address, Edition.contractType);
  }
  getTokenDrop(address) {
    return this.getBuiltInContract(address, TokenDrop.contractType);
  }
  getToken(address) {
    return this.getBuiltInContract(address, Token.contractType);
  }
  getVote(address) {
    return this.getBuiltInContract(address, Vote.contractType);
  }
  getSplit(address) {
    return this.getBuiltInContract(address, Split.contractType);
  }
  getMarketplace(address) {
    return this.getBuiltInContract(address, Marketplace.contractType);
  }
  getPack(address) {
    return this.getBuiltInContract(address, Pack.contractType);
  }
  getMultiwrap(address) {
    return this.getBuiltInContract(address, Multiwrap.contractType);
  }
  getBuiltInContract(address, contractType) {
    if (this.contractCache.has(address)) {
      return this.contractCache.get(address);
    }
    if (contractType === "custom") {
      throw new Error("To get an instance of a custom contract, use getContract(address)");
    }
    const newContract = new KNOWN_CONTRACTS_MAP[contractType](this.getSignerOrProvider(), address, this.storageHandler, this.options);
    this.contractCache.set(address, newContract);
    return newContract;
  }
  async resolveContractType(contractAddress) {
    const contract = IThirdwebContract__factory.connect(contractAddress, this.getSignerOrProvider());
    const remoteContractType = ethers.utils.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
    invariant13(remoteContractType in REMOTE_CONTRACT_TO_CONTRACT_TYPE, `${remoteContractType} is not a valid contract type, falling back to custom contract`);
    return REMOTE_CONTRACT_TO_CONTRACT_TYPE[remoteContractType];
  }
  async getContractList(walletAddress) {
    const addresses = await (await this.deployer.getRegistry()).getContractAddresses(walletAddress);
    const addressesWithContractTypes = await Promise.all(addresses.map(async (address) => {
      let contractType = "custom";
      try {
        contractType = await this.resolveContractType(address);
      } catch (e) {
      }
      let metadata;
      if (contractType === "custom") {
        try {
          metadata = (await this.getContract(address)).metadata;
        } catch (e) {
          console.log(`Couldn't get contract metadata for custom contract: ${address}`);
        }
      } else {
        metadata = this.getBuiltInContract(address, contractType).metadata;
      }
      return {
        address,
        contractType,
        metadata
      };
    }));
    return addressesWithContractTypes.filter((e) => e.metadata).map(({ address, contractType, metadata }) => {
      invariant13(metadata, "All ThirdwebContracts require metadata");
      return {
        address,
        contractType,
        metadata: () => metadata.get()
      };
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.auth.updateSignerOrProvider(this.getSignerOrProvider());
    this.wallet.onNetworkUpdated(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  async getContract(address) {
    if (this.contractCache.has(address)) {
      return this.contractCache.get(address);
    }
    try {
      const contractType = await this.resolveContractType(address);
      const abi = KNOWN_CONTRACTS_MAP[contractType].contractAbi;
      return this.getContractFromAbi(address, abi);
    } catch (err) {
      try {
        const publisher = this.getPublisher();
        const metadata = await publisher.fetchCompilerMetadataFromAddress(address);
        return this.getContractFromAbi(address, metadata.abi);
      } catch (e) {
        throw new Error(`Error fetching ABI for this contract

${err}`);
      }
    }
  }
  getContractFromAbi(address, abi) {
    if (this.contractCache.has(address)) {
      return this.contractCache.get(address);
    }
    const contract = new SmartContract(this.getSignerOrProvider(), address, abi, this.storageHandler, this.options);
    this.contractCache.set(address, contract);
    return contract;
  }
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(address));
  }
  getPublisher() {
    return this._publisher;
  }
};
__name(ThirdwebSDK, "ThirdwebSDK");
var ContractDeployer = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    this.storage = storage;
  }
  async deployNFTCollection(metadata) {
    return await this.deployBuiltInContract(NFTCollection.contractType, metadata);
  }
  async deployNFTDrop(metadata) {
    return await this.deployBuiltInContract(NFTDrop.contractType, metadata);
  }
  async deploySignatureDrop(metadata) {
    return await this.deployBuiltInContract(SignatureDrop.contractType, metadata);
  }
  async deployMultiwrap(metadata) {
    return await this.deployBuiltInContract(Multiwrap.contractType, metadata);
  }
  async deployEdition(metadata) {
    return await this.deployBuiltInContract(Edition.contractType, metadata);
  }
  async deployEditionDrop(metadata) {
    const parsed = EditionDrop.schema.deploy.parse(metadata);
    return await this.deployBuiltInContract(EditionDrop.contractType, parsed);
  }
  async deployToken(metadata) {
    return await this.deployBuiltInContract(Token.contractType, metadata);
  }
  async deployTokenDrop(metadata) {
    return await this.deployBuiltInContract(TokenDrop.contractType, metadata);
  }
  async deployMarketplace(metadata) {
    return await this.deployBuiltInContract(Marketplace.contractType, metadata);
  }
  async deployPack(metadata) {
    return await this.deployBuiltInContract(Pack.contractType, metadata);
  }
  async deploySplit(metadata) {
    return await this.deployBuiltInContract(Split.contractType, metadata);
  }
  async deployVote(metadata) {
    return await this.deployBuiltInContract(Vote.contractType, metadata);
  }
  async deployBuiltInContract(contractType, contractMetadata) {
    const factory = await this.getFactory();
    return await factory.deploy(contractType, contractMetadata);
  }
  async deployReleasedContract(releaserAddress, contractName, constructorParams) {
    const release = await new ThirdwebSDK("polygon").getPublisher().getLatest(releaserAddress, contractName);
    return await this.deployContractFromUri(release.metadataUri, constructorParams);
  }
  async deployViaFactory(factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs) {
    const signer = this.getSigner();
    invariant13(signer, "signer is required");
    const proxyFactory = new ContractFactory4(factoryAddress, this.getSignerOrProvider(), this.storage, {});
    return await proxyFactory.deployProxyByImplementation(implementationAddress, implementationAbi, initializerFunction, initializerArgs);
  }
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async ({ chainId }) => {
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async ({ chainId }) => {
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      return new ContractFactory4(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var _a3, _b2;
    (_a3 = this._factory) == null ? void 0 : _a3.then((factory) => {
      factory.updateSignerOrProvider(this.getSignerOrProvider());
    });
    (_b2 = this._registry) == null ? void 0 : _b2.then((registry) => {
      registry.updateSignerOrProvider(this.getSignerOrProvider());
    });
  }
  async deployContractFromUri(publishMetadataUri, constructorParamValues) {
    const signer = this.getSigner();
    invariant13(signer, "A signer is required");
    const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, this.storage);
    let isDeployableViaFactory;
    let factoryDeploymentData;
    try {
      const extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, this.storage);
      isDeployableViaFactory = extendedMetadata.isDeployableViaFactory;
      factoryDeploymentData = FactoryDeploymentSchema.parse(extendedMetadata.factoryDeploymentData);
    } catch (e) {
    }
    if (isDeployableViaFactory && factoryDeploymentData) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      invariant13(factoryDeploymentData.factoryAddresses, "factoryAddresses is required");
      invariant13(factoryDeploymentData.implementationAddresses, "implementationAddresses is required");
      const factoryAddress = factoryDeploymentData.factoryAddresses[chainId];
      const implementationAddress = factoryDeploymentData.implementationAddresses[chainId];
      invariant13(factoryAddress, `factoryAddress not found for chainId '${chainId}'`);
      invariant13(implementationAddress, `implementationAddress not found for chainId '${chainId}'`);
      invariant13(factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
      const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction).map((p) => p.type);
      const paramValues2 = this.convertParamValues(initializerParamTypes, constructorParamValues);
      return await this.deployViaFactory(factoryAddress, implementationAddress, compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction, paramValues2);
    }
    const bytecode = compilerMetadata.bytecode.startsWith("0x") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;
    if (!ethers.utils.isHexString(bytecode)) {
      throw new Error(`Contract bytecode is invalid.

${bytecode}`);
    }
    const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map((p) => p.type);
    const paramValues = this.convertParamValues(constructorParamTypes, constructorParamValues);
    return this.deployContractWithAbi(compilerMetadata.abi, bytecode, paramValues);
  }
  convertParamValues(constructorParamTypes, constructorParamValues) {
    if (constructorParamTypes.length !== constructorParamValues.length) {
      throw Error("Passed the wrong number of constructor arguments");
    }
    return constructorParamTypes.map((p, index) => {
      if (p === "tuple" || p.endsWith("[]")) {
        if (typeof constructorParamValues[index] === "string") {
          return JSON.parse(constructorParamValues[index]);
        } else {
          return constructorParamValues[index];
        }
      }
      if (p === "bytes32") {
        invariant13(ethers.utils.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index]}".`);
        return ethers.utils.hexZeroPad(constructorParamValues[index], 32);
      }
      if (p.startsWith("bytes")) {
        invariant13(ethers.utils.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index]}".`);
        return ethers.utils.toUtf8Bytes(constructorParamValues[index]);
      }
      if (p.startsWith("uint") || p.startsWith("int")) {
        return BigNumber.from(constructorParamValues[index].toString());
      }
      return constructorParamValues[index];
    });
  }
  async deployContractWithAbi(abi, bytecode, constructorParams) {
    const signer = this.getSigner();
    invariant13(signer, "Signer is required to deploy contracts");
    const deployer = await new ethers.ContractFactory(abi, bytecode).connect(signer).deploy(...constructorParams);
    const deployedContract = await deployer.deployed();
    return deployedContract.address;
  }
};
__name(ContractDeployer, "ContractDeployer");
/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
/** @preserve
* Counter block mode compatible with  Dr Brian Gladman fileenc.c
* derived from CryptoJS.mode.CTR
* Jan Hruby jhruby.web@gmail.com
*/

export { ALL_ROLES, AbiObjectSchema, AbiSchema, AbiTypeSchema, AdminRoleMissingError, AssetNotFoundError, AuctionAlreadyStartedError, AuctionHasNotEndedError, BYOCContractMetadataSchema, BaseSignaturePayloadInput, CONTRACTS_MAP, CONTRACT_ADDRESSES, ChainId, ChainIdToAddressSchema, ClaimConditionInputArray, ClaimConditionInputSchema, ClaimConditionOutputSchema, ClaimEligibility, CommonContractOutputSchema, CommonContractSchema, CommonPlatformFeeSchema, CommonPrimarySaleSchema, CommonRoyaltySchema, CommonSymbolSchema, CommonTrustedForwarderSchema, CompilerMetadataFetchedSchema, ContractDeployer, ContractEncoder, ContractEvents, ContractInfoSchema, ContractInterceptor, ContractMetadata, ContractPlatformFee, ContractPrimarySale, ContractPublishedMetadata, ContractRoles, ContractRoyalty, CurrencySchema, CurrencyValueSchema, CustomContractDeploy, CustomContractInput, CustomContractOutput, CustomContractSchema, DEFAULT_IPFS_GATEWAY, DEFAULT_QUERY_ALL_COUNT, DelayedReveal, DropClaimConditions, DropErc1155ClaimConditions, DropErc1155History, DuplicateFileNameError, DuplicateLeafsError, Edition, EditionDrop, EditionMetadataInputOrUriSchema, EditionMetadataInputSchema, EditionMetadataOutputSchema, EditionMetadataWithOwnerOutputSchema, Erc1155, Erc1155BatchMintable, Erc1155Burnable, Erc1155Droppable, Erc1155Enumerable, Erc1155Mintable, Erc1155SignatureMintable, Erc20, Erc20BatchMintable, Erc20Burnable, Erc20Mintable, Erc20SignatureMintable, Erc721, Erc721BatchMintable, Erc721Burnable, Erc721Claimable, Erc721Droppable, Erc721Enumerable, Erc721Mintable, Erc721Supply, Erc721WithQuantitySignatureMintable, EventType, ExtraPublishMetadataSchema, FactoryDeploymentSchema, FetchError, FileNameMissingError, FullPublishMetadataSchema, FunctionDeprecatedError, GasCostEstimator, InterfaceId_IERC1155, InterfaceId_IERC721, InvalidAddressError, IpfsStorage, KNOWN_CONTRACTS_MAP, ListingNotFoundError, ListingType, Marketplace, MarketplaceAuction, MarketplaceDirect, MerkleSchema, MintRequest1155, MintRequest20, MintRequest721, MintRequest721withQuantity, MissingOwnerRoleError, MissingRoleError, Multiwrap, NATIVE_TOKENS, NATIVE_TOKEN_ADDRESS, NFTCollection, NFTDrop, NotEnoughTokensError, NotFoundError, OZ_DEFENDER_FORWARDER_ADDRESS, OptionalPropertiesInput, PINATA_IPFS_URL, PUBLIC_GATEWAYS, Pack, PartialClaimConditionInputSchema, PreDeployMetadata, PreDeployMetadataFetchedSchema, ProfileSchemaInput, ProfileSchemaOutput, ProposalState, PublishedContractSchema, QuantityAboveLimitError, QuantitySchema, REMOTE_CONTRACT_NAME, REMOTE_CONTRACT_TO_CONTRACT_TYPE, RemoteStorage, RestrictedTransferError, SUPPORTED_CHAIN_IDS, Signature1155PayloadInput, Signature1155PayloadInputWithTokenId, Signature1155PayloadOutput, Signature20PayloadInput, Signature20PayloadOutput, Signature721PayloadInput, Signature721PayloadOutput, Signature721WithQuantityInput, Signature721WithQuantityOutput, SignatureDrop, SmartContract, SnapshotAddressInput, SnapshotInfoSchema, SnapshotInputSchema, SnapshotSchema, Split, TW_IPFS_SERVER_URL, ThirdwebSDK, Token, TokenDrop, TokenERC20History, TokenMintInputSchema, TransactionError, UploadError, UserWallet, Vote, VoteType, WalletAuthenticator, WrongListingTypeError, convertToTWError, createSnapshot, detectContractFeature, detectFeatures, extractConstructorParams, extractConstructorParamsFromAbi, extractEventsFromAbi, extractFunctionParamsFromAbi, extractFunctions, extractFunctionsFromAbi, fetchContractMetadata, fetchContractMetadataFromAddress, fetchExtendedReleaseMetadata, fetchPreDeployMetadata, fetchRawPredeployMetadata, fetchSourceFilesFromMetadata, getContractAddressByChainId, getContractPublisherAddress, getNativeTokenByChainId, getProviderForNetwork, getReadOnlyProvider, getRoleHash, hasFunction, hashLeafNode, includesErrorMessage, isFeatureEnabled, isIncrementalVersion, resolveContractUriFromAddress, toSemver };
//# sourceMappingURL=index.mjs.map